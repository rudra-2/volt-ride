"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const endpoint_util_1 = __importDefault(require("@alicloud/endpoint-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class ActivateMigrationTargetInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            forceSwitch: 'ForceSwitch',
            resourceOwnerId: 'ResourceOwnerId',
            switchTime: 'SwitchTime',
            switchTimeMode: 'SwitchTimeMode',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            forceSwitch: 'string',
            resourceOwnerId: 'number',
            switchTime: 'string',
            switchTimeMode: 'string',
        };
    }
}
exports.ActivateMigrationTargetInstanceRequest = ActivateMigrationTargetInstanceRequest;
class ActivateMigrationTargetInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            requestId: 'RequestId',
            sourceIpAddress: 'SourceIpAddress',
            sourcePort: 'SourcePort',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            requestId: 'string',
            sourceIpAddress: 'string',
            sourcePort: 'number',
            taskId: 'number',
        };
    }
}
exports.ActivateMigrationTargetInstanceResponseBody = ActivateMigrationTargetInstanceResponseBody;
class ActivateMigrationTargetInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ActivateMigrationTargetInstanceResponseBody,
        };
    }
}
exports.ActivateMigrationTargetInstanceResponse = ActivateMigrationTargetInstanceResponse;
class AddTagsToResourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tag: 'Tag',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            tags: 'Tags',
            proxyId: 'proxyId',
        };
    }
    static types() {
        return {
            tag: { 'type': 'array', 'itemType': AddTagsToResourceRequestTag },
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            tags: 'string',
            proxyId: 'string',
        };
    }
}
exports.AddTagsToResourceRequest = AddTagsToResourceRequest;
class AddTagsToResourceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.AddTagsToResourceResponseBody = AddTagsToResourceResponseBody;
class AddTagsToResourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddTagsToResourceResponseBody,
        };
    }
}
exports.AddTagsToResourceResponse = AddTagsToResourceResponse;
class AllocateInstancePublicConnectionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            babelfishPort: 'BabelfishPort',
            connectionStringPrefix: 'ConnectionStringPrefix',
            DBInstanceId: 'DBInstanceId',
            generalGroupName: 'GeneralGroupName',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            PGBouncerPort: 'PGBouncerPort',
            port: 'Port',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            babelfishPort: 'string',
            connectionStringPrefix: 'string',
            DBInstanceId: 'string',
            generalGroupName: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            PGBouncerPort: 'string',
            port: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.AllocateInstancePublicConnectionRequest = AllocateInstancePublicConnectionRequest;
class AllocateInstancePublicConnectionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectionString: 'ConnectionString',
            dbInstanceName: 'DbInstanceName',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            connectionString: 'string',
            dbInstanceName: 'string',
            requestId: 'string',
        };
    }
}
exports.AllocateInstancePublicConnectionResponseBody = AllocateInstancePublicConnectionResponseBody;
class AllocateInstancePublicConnectionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AllocateInstancePublicConnectionResponseBody,
        };
    }
}
exports.AllocateInstancePublicConnectionResponse = AllocateInstancePublicConnectionResponse;
class AllocateReadWriteSplittingConnectionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectionStringPrefix: 'ConnectionStringPrefix',
            DBInstanceId: 'DBInstanceId',
            distributionType: 'DistributionType',
            maxDelayTime: 'MaxDelayTime',
            netType: 'NetType',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            port: 'Port',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            weight: 'Weight',
        };
    }
    static types() {
        return {
            connectionStringPrefix: 'string',
            DBInstanceId: 'string',
            distributionType: 'string',
            maxDelayTime: 'string',
            netType: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            port: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            weight: 'string',
        };
    }
}
exports.AllocateReadWriteSplittingConnectionRequest = AllocateReadWriteSplittingConnectionRequest;
class AllocateReadWriteSplittingConnectionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.AllocateReadWriteSplittingConnectionResponseBody = AllocateReadWriteSplittingConnectionResponseBody;
class AllocateReadWriteSplittingConnectionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AllocateReadWriteSplittingConnectionResponseBody,
        };
    }
}
exports.AllocateReadWriteSplittingConnectionResponse = AllocateReadWriteSplittingConnectionResponse;
class AttachWhitelistTemplateToInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            insName: 'InsName',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            templateId: 'TemplateId',
        };
    }
    static types() {
        return {
            insName: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            templateId: 'number',
        };
    }
}
exports.AttachWhitelistTemplateToInstanceRequest = AttachWhitelistTemplateToInstanceRequest;
class AttachWhitelistTemplateToInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            httpStatusCode: 'HttpStatusCode',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: AttachWhitelistTemplateToInstanceResponseBodyData,
            httpStatusCode: 'number',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.AttachWhitelistTemplateToInstanceResponseBody = AttachWhitelistTemplateToInstanceResponseBody;
class AttachWhitelistTemplateToInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AttachWhitelistTemplateToInstanceResponseBody,
        };
    }
}
exports.AttachWhitelistTemplateToInstanceResponse = AttachWhitelistTemplateToInstanceResponse;
class CalculateDBInstanceWeightRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.CalculateDBInstanceWeightRequest = CalculateDBInstanceWeightRequest;
class CalculateDBInstanceWeightResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            items: CalculateDBInstanceWeightResponseBodyItems,
            requestId: 'string',
        };
    }
}
exports.CalculateDBInstanceWeightResponseBody = CalculateDBInstanceWeightResponseBody;
class CalculateDBInstanceWeightResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CalculateDBInstanceWeightResponseBody,
        };
    }
}
exports.CalculateDBInstanceWeightResponse = CalculateDBInstanceWeightResponse;
class CancelImportRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            importId: 'ImportId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            importId: 'number',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.CancelImportRequest = CancelImportRequest;
class CancelImportResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.CancelImportResponseBody = CancelImportResponseBody;
class CancelImportResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CancelImportResponseBody,
        };
    }
}
exports.CancelImportResponse = CancelImportResponse;
class CheckAccountNameAvailableRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountName: 'AccountName',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
        };
    }
    static types() {
        return {
            accountName: 'string',
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
        };
    }
}
exports.CheckAccountNameAvailableRequest = CheckAccountNameAvailableRequest;
class CheckAccountNameAvailableResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.CheckAccountNameAvailableResponseBody = CheckAccountNameAvailableResponseBody;
class CheckAccountNameAvailableResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CheckAccountNameAvailableResponseBody,
        };
    }
}
exports.CheckAccountNameAvailableResponse = CheckAccountNameAvailableResponse;
class CheckCloudResourceAuthorizedRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityToken: 'SecurityToken',
            targetRegionId: 'TargetRegionId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            securityToken: 'string',
            targetRegionId: 'string',
        };
    }
}
exports.CheckCloudResourceAuthorizedRequest = CheckCloudResourceAuthorizedRequest;
class CheckCloudResourceAuthorizedResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            authorizationState: 'AuthorizationState',
            requestId: 'RequestId',
            roleArn: 'RoleArn',
        };
    }
    static types() {
        return {
            authorizationState: 'number',
            requestId: 'string',
            roleArn: 'string',
        };
    }
}
exports.CheckCloudResourceAuthorizedResponseBody = CheckCloudResourceAuthorizedResponseBody;
class CheckCloudResourceAuthorizedResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CheckCloudResourceAuthorizedResponseBody,
        };
    }
}
exports.CheckCloudResourceAuthorizedResponse = CheckCloudResourceAuthorizedResponse;
class CheckCreateDdrDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupSetId: 'BackupSetId',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceStorage: 'DBInstanceStorage',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            restoreTime: 'RestoreTime',
            restoreType: 'RestoreType',
            sourceDBInstanceName: 'SourceDBInstanceName',
            sourceRegion: 'SourceRegion',
        };
    }
    static types() {
        return {
            backupSetId: 'string',
            DBInstanceClass: 'string',
            DBInstanceStorage: 'number',
            engine: 'string',
            engineVersion: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            restoreTime: 'string',
            restoreType: 'string',
            sourceDBInstanceName: 'string',
            sourceRegion: 'string',
        };
    }
}
exports.CheckCreateDdrDBInstanceRequest = CheckCreateDdrDBInstanceRequest;
class CheckCreateDdrDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            isValid: 'IsValid',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            isValid: 'string',
            requestId: 'string',
        };
    }
}
exports.CheckCreateDdrDBInstanceResponseBody = CheckCreateDdrDBInstanceResponseBody;
class CheckCreateDdrDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CheckCreateDdrDBInstanceResponseBody,
        };
    }
}
exports.CheckCreateDdrDBInstanceResponse = CheckCreateDdrDBInstanceResponse;
class CheckDBNameAvailableRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            DBName: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.CheckDBNameAvailableRequest = CheckDBNameAvailableRequest;
class CheckDBNameAvailableResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.CheckDBNameAvailableResponseBody = CheckDBNameAvailableResponseBody;
class CheckDBNameAvailableResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CheckDBNameAvailableResponseBody,
        };
    }
}
exports.CheckDBNameAvailableResponse = CheckDBNameAvailableResponse;
class CheckInstanceExistRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.CheckInstanceExistRequest = CheckInstanceExistRequest;
class CheckInstanceExistResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            isExistInstance: 'IsExistInstance',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            isExistInstance: 'boolean',
            requestId: 'string',
        };
    }
}
exports.CheckInstanceExistResponseBody = CheckInstanceExistResponseBody;
class CheckInstanceExistResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CheckInstanceExistResponseBody,
        };
    }
}
exports.CheckInstanceExistResponse = CheckInstanceExistResponse;
class CheckServiceLinkedRoleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            serviceLinkedRole: 'ServiceLinkedRole',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            serviceLinkedRole: 'string',
        };
    }
}
exports.CheckServiceLinkedRoleRequest = CheckServiceLinkedRoleRequest;
class CheckServiceLinkedRoleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasServiceLinkedRole: 'HasServiceLinkedRole',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            hasServiceLinkedRole: 'string',
            requestId: 'string',
        };
    }
}
exports.CheckServiceLinkedRoleResponseBody = CheckServiceLinkedRoleResponseBody;
class CheckServiceLinkedRoleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CheckServiceLinkedRoleResponseBody,
        };
    }
}
exports.CheckServiceLinkedRoleResponse = CheckServiceLinkedRoleResponse;
class CloneDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPay: 'AutoPay',
            backupId: 'BackupId',
            backupType: 'BackupType',
            bpeEnabled: 'BpeEnabled',
            burstingEnabled: 'BurstingEnabled',
            category: 'Category',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            dbNames: 'DbNames',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            deletionProtection: 'DeletionProtection',
            instanceNetworkType: 'InstanceNetworkType',
            payType: 'PayType',
            period: 'Period',
            privateIpAddress: 'PrivateIpAddress',
            regionId: 'RegionId',
            resourceOwnerId: 'ResourceOwnerId',
            restoreTable: 'RestoreTable',
            restoreTime: 'RestoreTime',
            serverlessConfig: 'ServerlessConfig',
            tableMeta: 'TableMeta',
            usedTime: 'UsedTime',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
            zoneId: 'ZoneId',
            zoneIdSlave1: 'ZoneIdSlave1',
            zoneIdSlave2: 'ZoneIdSlave2',
        };
    }
    static types() {
        return {
            autoPay: 'boolean',
            backupId: 'string',
            backupType: 'string',
            bpeEnabled: 'string',
            burstingEnabled: 'boolean',
            category: 'string',
            DBInstanceClass: 'string',
            DBInstanceId: 'string',
            DBInstanceStorage: 'number',
            DBInstanceStorageType: 'string',
            dbNames: 'string',
            dedicatedHostGroupId: 'string',
            deletionProtection: 'boolean',
            instanceNetworkType: 'string',
            payType: 'string',
            period: 'string',
            privateIpAddress: 'string',
            regionId: 'string',
            resourceOwnerId: 'number',
            restoreTable: 'string',
            restoreTime: 'string',
            serverlessConfig: CloneDBInstanceRequestServerlessConfig,
            tableMeta: 'string',
            usedTime: 'number',
            VPCId: 'string',
            vSwitchId: 'string',
            zoneId: 'string',
            zoneIdSlave1: 'string',
            zoneIdSlave2: 'string',
        };
    }
}
exports.CloneDBInstanceRequest = CloneDBInstanceRequest;
class CloneDBInstanceShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPay: 'AutoPay',
            backupId: 'BackupId',
            backupType: 'BackupType',
            bpeEnabled: 'BpeEnabled',
            burstingEnabled: 'BurstingEnabled',
            category: 'Category',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            dbNames: 'DbNames',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            deletionProtection: 'DeletionProtection',
            instanceNetworkType: 'InstanceNetworkType',
            payType: 'PayType',
            period: 'Period',
            privateIpAddress: 'PrivateIpAddress',
            regionId: 'RegionId',
            resourceOwnerId: 'ResourceOwnerId',
            restoreTable: 'RestoreTable',
            restoreTime: 'RestoreTime',
            serverlessConfigShrink: 'ServerlessConfig',
            tableMeta: 'TableMeta',
            usedTime: 'UsedTime',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
            zoneId: 'ZoneId',
            zoneIdSlave1: 'ZoneIdSlave1',
            zoneIdSlave2: 'ZoneIdSlave2',
        };
    }
    static types() {
        return {
            autoPay: 'boolean',
            backupId: 'string',
            backupType: 'string',
            bpeEnabled: 'string',
            burstingEnabled: 'boolean',
            category: 'string',
            DBInstanceClass: 'string',
            DBInstanceId: 'string',
            DBInstanceStorage: 'number',
            DBInstanceStorageType: 'string',
            dbNames: 'string',
            dedicatedHostGroupId: 'string',
            deletionProtection: 'boolean',
            instanceNetworkType: 'string',
            payType: 'string',
            period: 'string',
            privateIpAddress: 'string',
            regionId: 'string',
            resourceOwnerId: 'number',
            restoreTable: 'string',
            restoreTime: 'string',
            serverlessConfigShrink: 'string',
            tableMeta: 'string',
            usedTime: 'number',
            VPCId: 'string',
            vSwitchId: 'string',
            zoneId: 'string',
            zoneIdSlave1: 'string',
            zoneIdSlave2: 'string',
        };
    }
}
exports.CloneDBInstanceShrinkRequest = CloneDBInstanceShrinkRequest;
class CloneDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            orderId: 'OrderId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            orderId: 'string',
            requestId: 'string',
        };
    }
}
exports.CloneDBInstanceResponseBody = CloneDBInstanceResponseBody;
class CloneDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CloneDBInstanceResponseBody,
        };
    }
}
exports.CloneDBInstanceResponse = CloneDBInstanceResponse;
class CloneParameterGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
            parameterGroupDesc: 'ParameterGroupDesc',
            parameterGroupId: 'ParameterGroupId',
            parameterGroupName: 'ParameterGroupName',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            targetRegionId: 'TargetRegionId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            parameterGroupDesc: 'string',
            parameterGroupId: 'string',
            parameterGroupName: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            targetRegionId: 'string',
        };
    }
}
exports.CloneParameterGroupRequest = CloneParameterGroupRequest;
class CloneParameterGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.CloneParameterGroupResponseBody = CloneParameterGroupResponseBody;
class CloneParameterGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CloneParameterGroupResponseBody,
        };
    }
}
exports.CloneParameterGroupResponse = CloneParameterGroupResponse;
class ConfirmNotifyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            confirmor: 'Confirmor',
            notifyIdList: 'NotifyIdList',
        };
    }
    static types() {
        return {
            confirmor: 'number',
            notifyIdList: { 'type': 'array', 'itemType': 'number' },
        };
    }
}
exports.ConfirmNotifyRequest = ConfirmNotifyRequest;
class ConfirmNotifyShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            confirmor: 'Confirmor',
            notifyIdListShrink: 'NotifyIdList',
        };
    }
    static types() {
        return {
            confirmor: 'number',
            notifyIdListShrink: 'string',
        };
    }
}
exports.ConfirmNotifyShrinkRequest = ConfirmNotifyShrinkRequest;
class ConfirmNotifyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ConfirmNotifyResponseBody = ConfirmNotifyResponseBody;
class ConfirmNotifyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ConfirmNotifyResponseBody,
        };
    }
}
exports.ConfirmNotifyResponse = ConfirmNotifyResponse;
class CopyDatabaseRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.CopyDatabaseRequest = CopyDatabaseRequest;
class CopyDatabaseResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBName: 'DBName',
            DBStatus: 'DBStatus',
            requestId: 'RequestId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            DBName: 'string',
            DBStatus: 'string',
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.CopyDatabaseResponseBody = CopyDatabaseResponseBody;
class CopyDatabaseResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CopyDatabaseResponseBody,
        };
    }
}
exports.CopyDatabaseResponse = CopyDatabaseResponse;
class CopyDatabaseBetweenInstancesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            DBInstanceId: 'DBInstanceId',
            dbNames: 'DbNames',
            resourceOwnerId: 'ResourceOwnerId',
            restoreTime: 'RestoreTime',
            syncUserPrivilege: 'SyncUserPrivilege',
            targetDBInstanceId: 'TargetDBInstanceId',
        };
    }
    static types() {
        return {
            backupId: 'string',
            DBInstanceId: 'string',
            dbNames: 'string',
            resourceOwnerId: 'number',
            restoreTime: 'string',
            syncUserPrivilege: 'string',
            targetDBInstanceId: 'string',
        };
    }
}
exports.CopyDatabaseBetweenInstancesRequest = CopyDatabaseBetweenInstancesRequest;
class CopyDatabaseBetweenInstancesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.CopyDatabaseBetweenInstancesResponseBody = CopyDatabaseBetweenInstancesResponseBody;
class CopyDatabaseBetweenInstancesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CopyDatabaseBetweenInstancesResponseBody,
        };
    }
}
exports.CopyDatabaseBetweenInstancesResponse = CopyDatabaseBetweenInstancesResponse;
class CreateAccountRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountDescription: 'AccountDescription',
            accountName: 'AccountName',
            accountPassword: 'AccountPassword',
            accountType: 'AccountType',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            accountDescription: 'string',
            accountName: 'string',
            accountPassword: 'string',
            accountType: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.CreateAccountRequest = CreateAccountRequest;
class CreateAccountResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.CreateAccountResponseBody = CreateAccountResponseBody;
class CreateAccountResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateAccountResponseBody,
        };
    }
}
exports.CreateAccountResponse = CreateAccountResponse;
class CreateBackupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupMethod: 'BackupMethod',
            backupStrategy: 'BackupStrategy',
            backupType: 'BackupType',
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            backupMethod: 'string',
            backupStrategy: 'string',
            backupType: 'string',
            DBInstanceId: 'string',
            DBName: 'string',
            resourceGroupId: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.CreateBackupRequest = CreateBackupRequest;
class CreateBackupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupJobId: 'BackupJobId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            backupJobId: 'string',
            requestId: 'string',
        };
    }
}
exports.CreateBackupResponseBody = CreateBackupResponseBody;
class CreateBackupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateBackupResponseBody,
        };
    }
}
exports.CreateBackupResponse = CreateBackupResponse;
class CreateCloudMigrationPrecheckTaskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            resourceOwnerId: 'ResourceOwnerId',
            sourceAccount: 'SourceAccount',
            sourceCategory: 'SourceCategory',
            sourceIpAddress: 'SourceIpAddress',
            sourcePassword: 'SourcePassword',
            sourcePort: 'SourcePort',
            taskName: 'TaskName',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            resourceOwnerId: 'number',
            sourceAccount: 'string',
            sourceCategory: 'string',
            sourceIpAddress: 'string',
            sourcePassword: 'string',
            sourcePort: 'number',
            taskName: 'string',
        };
    }
}
exports.CreateCloudMigrationPrecheckTaskRequest = CreateCloudMigrationPrecheckTaskRequest;
class CreateCloudMigrationPrecheckTaskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            requestId: 'RequestId',
            taskId: 'TaskId',
            taskName: 'TaskName',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            requestId: 'string',
            taskId: 'number',
            taskName: 'string',
        };
    }
}
exports.CreateCloudMigrationPrecheckTaskResponseBody = CreateCloudMigrationPrecheckTaskResponseBody;
class CreateCloudMigrationPrecheckTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateCloudMigrationPrecheckTaskResponseBody,
        };
    }
}
exports.CreateCloudMigrationPrecheckTaskResponse = CreateCloudMigrationPrecheckTaskResponse;
class CreateCloudMigrationTaskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            resourceOwnerId: 'ResourceOwnerId',
            sourceAccount: 'SourceAccount',
            sourceCategory: 'SourceCategory',
            sourceIpAddress: 'SourceIpAddress',
            sourcePassword: 'SourcePassword',
            sourcePort: 'SourcePort',
            taskName: 'TaskName',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            resourceOwnerId: 'number',
            sourceAccount: 'string',
            sourceCategory: 'string',
            sourceIpAddress: 'string',
            sourcePassword: 'string',
            sourcePort: 'number',
            taskName: 'string',
        };
    }
}
exports.CreateCloudMigrationTaskRequest = CreateCloudMigrationTaskRequest;
class CreateCloudMigrationTaskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            requestId: 'RequestId',
            taskId: 'TaskId',
            taskName: 'TaskName',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            requestId: 'string',
            taskId: 'number',
            taskName: 'string',
        };
    }
}
exports.CreateCloudMigrationTaskResponseBody = CreateCloudMigrationTaskResponseBody;
class CreateCloudMigrationTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateCloudMigrationTaskResponseBody,
        };
    }
}
exports.CreateCloudMigrationTaskResponse = CreateCloudMigrationTaskResponse;
class CreateDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'Amount',
            autoPay: 'AutoPay',
            autoRenew: 'AutoRenew',
            babelfishConfig: 'BabelfishConfig',
            bpeEnabled: 'BpeEnabled',
            burstingEnabled: 'BurstingEnabled',
            businessInfo: 'BusinessInfo',
            category: 'Category',
            clientToken: 'ClientToken',
            connectionMode: 'ConnectionMode',
            connectionString: 'ConnectionString',
            createStrategy: 'CreateStrategy',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceNetType: 'DBInstanceNetType',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            DBIsIgnoreCase: 'DBIsIgnoreCase',
            DBParamGroupId: 'DBParamGroupId',
            DBTimeZone: 'DBTimeZone',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            deletionProtection: 'DeletionProtection',
            dryRun: 'DryRun',
            encryptionKey: 'EncryptionKey',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            instanceNetworkType: 'InstanceNetworkType',
            payType: 'PayType',
            period: 'Period',
            port: 'Port',
            privateIpAddress: 'PrivateIpAddress',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerId: 'ResourceOwnerId',
            roleARN: 'RoleARN',
            securityIPList: 'SecurityIPList',
            serverlessConfig: 'ServerlessConfig',
            storageAutoScale: 'StorageAutoScale',
            storageThreshold: 'StorageThreshold',
            storageUpperBound: 'StorageUpperBound',
            systemDBCharset: 'SystemDBCharset',
            tag: 'Tag',
            targetDedicatedHostIdForLog: 'TargetDedicatedHostIdForLog',
            targetDedicatedHostIdForMaster: 'TargetDedicatedHostIdForMaster',
            targetDedicatedHostIdForSlave: 'TargetDedicatedHostIdForSlave',
            targetMinorVersion: 'TargetMinorVersion',
            usedTime: 'UsedTime',
            userBackupId: 'UserBackupId',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
            zoneId: 'ZoneId',
            zoneIdSlave1: 'ZoneIdSlave1',
            zoneIdSlave2: 'ZoneIdSlave2',
        };
    }
    static types() {
        return {
            amount: 'number',
            autoPay: 'boolean',
            autoRenew: 'string',
            babelfishConfig: 'string',
            bpeEnabled: 'string',
            burstingEnabled: 'boolean',
            businessInfo: 'string',
            category: 'string',
            clientToken: 'string',
            connectionMode: 'string',
            connectionString: 'string',
            createStrategy: 'string',
            DBInstanceClass: 'string',
            DBInstanceDescription: 'string',
            DBInstanceNetType: 'string',
            DBInstanceStorage: 'number',
            DBInstanceStorageType: 'string',
            DBIsIgnoreCase: 'string',
            DBParamGroupId: 'string',
            DBTimeZone: 'string',
            dedicatedHostGroupId: 'string',
            deletionProtection: 'boolean',
            dryRun: 'boolean',
            encryptionKey: 'string',
            engine: 'string',
            engineVersion: 'string',
            instanceNetworkType: 'string',
            payType: 'string',
            period: 'string',
            port: 'string',
            privateIpAddress: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerId: 'number',
            roleARN: 'string',
            securityIPList: 'string',
            serverlessConfig: CreateDBInstanceRequestServerlessConfig,
            storageAutoScale: 'string',
            storageThreshold: 'number',
            storageUpperBound: 'number',
            systemDBCharset: 'string',
            tag: { 'type': 'array', 'itemType': CreateDBInstanceRequestTag },
            targetDedicatedHostIdForLog: 'string',
            targetDedicatedHostIdForMaster: 'string',
            targetDedicatedHostIdForSlave: 'string',
            targetMinorVersion: 'string',
            usedTime: 'string',
            userBackupId: 'string',
            VPCId: 'string',
            vSwitchId: 'string',
            zoneId: 'string',
            zoneIdSlave1: 'string',
            zoneIdSlave2: 'string',
        };
    }
}
exports.CreateDBInstanceRequest = CreateDBInstanceRequest;
class CreateDBInstanceShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'Amount',
            autoPay: 'AutoPay',
            autoRenew: 'AutoRenew',
            babelfishConfig: 'BabelfishConfig',
            bpeEnabled: 'BpeEnabled',
            burstingEnabled: 'BurstingEnabled',
            businessInfo: 'BusinessInfo',
            category: 'Category',
            clientToken: 'ClientToken',
            connectionMode: 'ConnectionMode',
            connectionString: 'ConnectionString',
            createStrategy: 'CreateStrategy',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceNetType: 'DBInstanceNetType',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            DBIsIgnoreCase: 'DBIsIgnoreCase',
            DBParamGroupId: 'DBParamGroupId',
            DBTimeZone: 'DBTimeZone',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            deletionProtection: 'DeletionProtection',
            dryRun: 'DryRun',
            encryptionKey: 'EncryptionKey',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            instanceNetworkType: 'InstanceNetworkType',
            payType: 'PayType',
            period: 'Period',
            port: 'Port',
            privateIpAddress: 'PrivateIpAddress',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerId: 'ResourceOwnerId',
            roleARN: 'RoleARN',
            securityIPList: 'SecurityIPList',
            serverlessConfigShrink: 'ServerlessConfig',
            storageAutoScale: 'StorageAutoScale',
            storageThreshold: 'StorageThreshold',
            storageUpperBound: 'StorageUpperBound',
            systemDBCharset: 'SystemDBCharset',
            tag: 'Tag',
            targetDedicatedHostIdForLog: 'TargetDedicatedHostIdForLog',
            targetDedicatedHostIdForMaster: 'TargetDedicatedHostIdForMaster',
            targetDedicatedHostIdForSlave: 'TargetDedicatedHostIdForSlave',
            targetMinorVersion: 'TargetMinorVersion',
            usedTime: 'UsedTime',
            userBackupId: 'UserBackupId',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
            zoneId: 'ZoneId',
            zoneIdSlave1: 'ZoneIdSlave1',
            zoneIdSlave2: 'ZoneIdSlave2',
        };
    }
    static types() {
        return {
            amount: 'number',
            autoPay: 'boolean',
            autoRenew: 'string',
            babelfishConfig: 'string',
            bpeEnabled: 'string',
            burstingEnabled: 'boolean',
            businessInfo: 'string',
            category: 'string',
            clientToken: 'string',
            connectionMode: 'string',
            connectionString: 'string',
            createStrategy: 'string',
            DBInstanceClass: 'string',
            DBInstanceDescription: 'string',
            DBInstanceNetType: 'string',
            DBInstanceStorage: 'number',
            DBInstanceStorageType: 'string',
            DBIsIgnoreCase: 'string',
            DBParamGroupId: 'string',
            DBTimeZone: 'string',
            dedicatedHostGroupId: 'string',
            deletionProtection: 'boolean',
            dryRun: 'boolean',
            encryptionKey: 'string',
            engine: 'string',
            engineVersion: 'string',
            instanceNetworkType: 'string',
            payType: 'string',
            period: 'string',
            port: 'string',
            privateIpAddress: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerId: 'number',
            roleARN: 'string',
            securityIPList: 'string',
            serverlessConfigShrink: 'string',
            storageAutoScale: 'string',
            storageThreshold: 'number',
            storageUpperBound: 'number',
            systemDBCharset: 'string',
            tag: { 'type': 'array', 'itemType': CreateDBInstanceShrinkRequestTag },
            targetDedicatedHostIdForLog: 'string',
            targetDedicatedHostIdForMaster: 'string',
            targetDedicatedHostIdForSlave: 'string',
            targetMinorVersion: 'string',
            usedTime: 'string',
            userBackupId: 'string',
            VPCId: 'string',
            vSwitchId: 'string',
            zoneId: 'string',
            zoneIdSlave1: 'string',
            zoneIdSlave2: 'string',
        };
    }
}
exports.CreateDBInstanceShrinkRequest = CreateDBInstanceShrinkRequest;
class CreateDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectionString: 'ConnectionString',
            DBInstanceId: 'DBInstanceId',
            dryRun: 'DryRun',
            dryRunResult: 'DryRunResult',
            message: 'Message',
            orderId: 'OrderId',
            port: 'Port',
            requestId: 'RequestId',
            tagResult: 'TagResult',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            connectionString: 'string',
            DBInstanceId: 'string',
            dryRun: 'boolean',
            dryRunResult: 'boolean',
            message: 'string',
            orderId: 'string',
            port: 'string',
            requestId: 'string',
            tagResult: 'boolean',
            taskId: 'string',
        };
    }
}
exports.CreateDBInstanceResponseBody = CreateDBInstanceResponseBody;
class CreateDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDBInstanceResponseBody,
        };
    }
}
exports.CreateDBInstanceResponse = CreateDBInstanceResponse;
class CreateDBInstanceEndpointRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            connectionStringPrefix: 'ConnectionStringPrefix',
            DBInstanceEndpointDescription: 'DBInstanceEndpointDescription',
            DBInstanceEndpointType: 'DBInstanceEndpointType',
            DBInstanceId: 'DBInstanceId',
            nodeItems: 'NodeItems',
            port: 'Port',
            privateIpAddress: 'PrivateIpAddress',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerId: 'ResourceOwnerId',
            vSwitchId: 'VSwitchId',
            vpcId: 'VpcId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            connectionStringPrefix: 'string',
            DBInstanceEndpointDescription: 'string',
            DBInstanceEndpointType: 'string',
            DBInstanceId: 'string',
            nodeItems: { 'type': 'array', 'itemType': CreateDBInstanceEndpointRequestNodeItems },
            port: 'string',
            privateIpAddress: 'string',
            resourceGroupId: 'string',
            resourceOwnerId: 'number',
            vSwitchId: 'string',
            vpcId: 'string',
        };
    }
}
exports.CreateDBInstanceEndpointRequest = CreateDBInstanceEndpointRequest;
class CreateDBInstanceEndpointShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            connectionStringPrefix: 'ConnectionStringPrefix',
            DBInstanceEndpointDescription: 'DBInstanceEndpointDescription',
            DBInstanceEndpointType: 'DBInstanceEndpointType',
            DBInstanceId: 'DBInstanceId',
            nodeItemsShrink: 'NodeItems',
            port: 'Port',
            privateIpAddress: 'PrivateIpAddress',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerId: 'ResourceOwnerId',
            vSwitchId: 'VSwitchId',
            vpcId: 'VpcId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            connectionStringPrefix: 'string',
            DBInstanceEndpointDescription: 'string',
            DBInstanceEndpointType: 'string',
            DBInstanceId: 'string',
            nodeItemsShrink: 'string',
            port: 'string',
            privateIpAddress: 'string',
            resourceGroupId: 'string',
            resourceOwnerId: 'number',
            vSwitchId: 'string',
            vpcId: 'string',
        };
    }
}
exports.CreateDBInstanceEndpointShrinkRequest = CreateDBInstanceEndpointShrinkRequest;
class CreateDBInstanceEndpointResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: CreateDBInstanceEndpointResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.CreateDBInstanceEndpointResponseBody = CreateDBInstanceEndpointResponseBody;
class CreateDBInstanceEndpointResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDBInstanceEndpointResponseBody,
        };
    }
}
exports.CreateDBInstanceEndpointResponse = CreateDBInstanceEndpointResponse;
class CreateDBInstanceEndpointAddressRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            connectionStringPrefix: 'ConnectionStringPrefix',
            DBInstanceEndpointId: 'DBInstanceEndpointId',
            DBInstanceId: 'DBInstanceId',
            ipType: 'IpType',
            port: 'Port',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            connectionStringPrefix: 'string',
            DBInstanceEndpointId: 'string',
            DBInstanceId: 'string',
            ipType: 'string',
            port: 'string',
            resourceGroupId: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.CreateDBInstanceEndpointAddressRequest = CreateDBInstanceEndpointAddressRequest;
class CreateDBInstanceEndpointAddressResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: CreateDBInstanceEndpointAddressResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.CreateDBInstanceEndpointAddressResponseBody = CreateDBInstanceEndpointAddressResponseBody;
class CreateDBInstanceEndpointAddressResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDBInstanceEndpointAddressResponseBody,
        };
    }
}
exports.CreateDBInstanceEndpointAddressResponse = CreateDBInstanceEndpointAddressResponse;
class CreateDBInstanceForRebuildRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceId: 'DBInstanceId',
            DBInstanceNetType: 'DBInstanceNetType',
            instanceNetworkType: 'InstanceNetworkType',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            payType: 'PayType',
            period: 'Period',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityIPList: 'SecurityIPList',
            securityToken: 'SecurityToken',
            usedTime: 'UsedTime',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
            zoneId: 'ZoneId',
            zoneIdSlave1: 'ZoneIdSlave1',
            zoneIdSlave2: 'ZoneIdSlave2',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceDescription: 'string',
            DBInstanceId: 'string',
            DBInstanceNetType: 'string',
            instanceNetworkType: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            payType: 'string',
            period: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            securityIPList: 'string',
            securityToken: 'string',
            usedTime: 'string',
            VPCId: 'string',
            vSwitchId: 'string',
            zoneId: 'string',
            zoneIdSlave1: 'string',
            zoneIdSlave2: 'string',
        };
    }
}
exports.CreateDBInstanceForRebuildRequest = CreateDBInstanceForRebuildRequest;
class CreateDBInstanceForRebuildResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            message: 'Message',
            orderId: 'OrderId',
            requestId: 'RequestId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            message: 'string',
            orderId: 'string',
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.CreateDBInstanceForRebuildResponseBody = CreateDBInstanceForRebuildResponseBody;
class CreateDBInstanceForRebuildResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDBInstanceForRebuildResponseBody,
        };
    }
}
exports.CreateDBInstanceForRebuildResponse = CreateDBInstanceForRebuildResponse;
class CreateDBNodesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            DBNode: 'DBNode',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            DBNode: { 'type': 'array', 'itemType': CreateDBNodesRequestDBNode },
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.CreateDBNodesRequest = CreateDBNodesRequest;
class CreateDBNodesShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            DBNodeShrink: 'DBNode',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            DBNodeShrink: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.CreateDBNodesShrinkRequest = CreateDBNodesShrinkRequest;
class CreateDBNodesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            nodeIds: 'NodeIds',
            orderId: 'OrderId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            nodeIds: 'string',
            orderId: 'number',
            requestId: 'string',
        };
    }
}
exports.CreateDBNodesResponseBody = CreateDBNodesResponseBody;
class CreateDBNodesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDBNodesResponseBody,
        };
    }
}
exports.CreateDBNodesResponse = CreateDBNodesResponse;
class CreateDBProxyEndpointAddressRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectionStringPrefix: 'ConnectionStringPrefix',
            DBInstanceId: 'DBInstanceId',
            DBProxyConnectStringNetType: 'DBProxyConnectStringNetType',
            DBProxyEndpointId: 'DBProxyEndpointId',
            DBProxyEngineType: 'DBProxyEngineType',
            DBProxyNewConnectStringPort: 'DBProxyNewConnectStringPort',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
        };
    }
    static types() {
        return {
            connectionStringPrefix: 'string',
            DBInstanceId: 'string',
            DBProxyConnectStringNetType: 'string',
            DBProxyEndpointId: 'string',
            DBProxyEngineType: 'string',
            DBProxyNewConnectStringPort: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            VPCId: 'string',
            vSwitchId: 'string',
        };
    }
}
exports.CreateDBProxyEndpointAddressRequest = CreateDBProxyEndpointAddressRequest;
class CreateDBProxyEndpointAddressResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.CreateDBProxyEndpointAddressResponseBody = CreateDBProxyEndpointAddressResponseBody;
class CreateDBProxyEndpointAddressResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDBProxyEndpointAddressResponseBody,
        };
    }
}
exports.CreateDBProxyEndpointAddressResponse = CreateDBProxyEndpointAddressResponse;
class CreateDatabaseRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            characterSetName: 'CharacterSetName',
            DBDescription: 'DBDescription',
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            characterSetName: 'string',
            DBDescription: 'string',
            DBInstanceId: 'string',
            DBName: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.CreateDatabaseRequest = CreateDatabaseRequest;
class CreateDatabaseResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.CreateDatabaseResponseBody = CreateDatabaseResponseBody;
class CreateDatabaseResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDatabaseResponseBody,
        };
    }
}
exports.CreateDatabaseResponse = CreateDatabaseResponse;
class CreateDdrInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupSetId: 'BackupSetId',
            clientToken: 'ClientToken',
            connectionMode: 'ConnectionMode',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceNetType: 'DBInstanceNetType',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            instanceNetworkType: 'InstanceNetworkType',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            payType: 'PayType',
            period: 'Period',
            privateIpAddress: 'PrivateIpAddress',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            restoreTime: 'RestoreTime',
            restoreType: 'RestoreType',
            securityIPList: 'SecurityIPList',
            sourceDBInstanceName: 'SourceDBInstanceName',
            sourceRegion: 'SourceRegion',
            systemDBCharset: 'SystemDBCharset',
            usedTime: 'UsedTime',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            backupSetId: 'string',
            clientToken: 'string',
            connectionMode: 'string',
            DBInstanceClass: 'string',
            DBInstanceDescription: 'string',
            DBInstanceNetType: 'string',
            DBInstanceStorage: 'number',
            DBInstanceStorageType: 'string',
            engine: 'string',
            engineVersion: 'string',
            instanceNetworkType: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            payType: 'string',
            period: 'string',
            privateIpAddress: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            restoreTime: 'string',
            restoreType: 'string',
            securityIPList: 'string',
            sourceDBInstanceName: 'string',
            sourceRegion: 'string',
            systemDBCharset: 'string',
            usedTime: 'string',
            VPCId: 'string',
            vSwitchId: 'string',
            zoneId: 'string',
        };
    }
}
exports.CreateDdrInstanceRequest = CreateDdrInstanceRequest;
class CreateDdrInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectionString: 'ConnectionString',
            DBInstanceId: 'DBInstanceId',
            orderId: 'OrderId',
            port: 'Port',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            connectionString: 'string',
            DBInstanceId: 'string',
            orderId: 'string',
            port: 'string',
            requestId: 'string',
        };
    }
}
exports.CreateDdrInstanceResponseBody = CreateDdrInstanceResponseBody;
class CreateDdrInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDdrInstanceResponseBody,
        };
    }
}
exports.CreateDdrInstanceResponse = CreateDdrInstanceResponse;
class CreateDiagnosticReportRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            endTime: 'string',
            startTime: 'string',
        };
    }
}
exports.CreateDiagnosticReportRequest = CreateDiagnosticReportRequest;
class CreateDiagnosticReportResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            reportId: 'ReportId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            reportId: 'string',
            requestId: 'string',
        };
    }
}
exports.CreateDiagnosticReportResponseBody = CreateDiagnosticReportResponseBody;
class CreateDiagnosticReportResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDiagnosticReportResponseBody,
        };
    }
}
exports.CreateDiagnosticReportResponse = CreateDiagnosticReportResponse;
class CreateGADInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            centralDBInstanceId: 'CentralDBInstanceId',
            centralRdsDtsAdminAccount: 'CentralRdsDtsAdminAccount',
            centralRdsDtsAdminPassword: 'CentralRdsDtsAdminPassword',
            centralRegionId: 'CentralRegionId',
            DBList: 'DBList',
            description: 'Description',
            resourceGroupId: 'ResourceGroupId',
            tag: 'Tag',
            unitNode: 'UnitNode',
        };
    }
    static types() {
        return {
            centralDBInstanceId: 'string',
            centralRdsDtsAdminAccount: 'string',
            centralRdsDtsAdminPassword: 'string',
            centralRegionId: 'string',
            DBList: 'string',
            description: 'string',
            resourceGroupId: 'string',
            tag: { 'type': 'array', 'itemType': CreateGADInstanceRequestTag },
            unitNode: { 'type': 'array', 'itemType': CreateGADInstanceRequestUnitNode },
        };
    }
}
exports.CreateGADInstanceRequest = CreateGADInstanceRequest;
class CreateGADInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
            result: 'Result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: CreateGADInstanceResponseBodyResult,
        };
    }
}
exports.CreateGADInstanceResponseBody = CreateGADInstanceResponseBody;
class CreateGADInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateGADInstanceResponseBody,
        };
    }
}
exports.CreateGADInstanceResponse = CreateGADInstanceResponse;
class CreateGadInstanceMemberRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            centralDBInstanceId: 'CentralDBInstanceId',
            centralRdsDtsAdminAccount: 'CentralRdsDtsAdminAccount',
            centralRdsDtsAdminPassword: 'CentralRdsDtsAdminPassword',
            centralRegionId: 'CentralRegionId',
            DBList: 'DBList',
            gadInstanceId: 'GadInstanceId',
            unitNode: 'UnitNode',
        };
    }
    static types() {
        return {
            centralDBInstanceId: 'string',
            centralRdsDtsAdminAccount: 'string',
            centralRdsDtsAdminPassword: 'string',
            centralRegionId: 'string',
            DBList: 'string',
            gadInstanceId: 'string',
            unitNode: { 'type': 'array', 'itemType': CreateGadInstanceMemberRequestUnitNode },
        };
    }
}
exports.CreateGadInstanceMemberRequest = CreateGadInstanceMemberRequest;
class CreateGadInstanceMemberResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
            result: 'Result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: CreateGadInstanceMemberResponseBodyResult,
        };
    }
}
exports.CreateGadInstanceMemberResponseBody = CreateGadInstanceMemberResponseBody;
class CreateGadInstanceMemberResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateGadInstanceMemberResponseBody,
        };
    }
}
exports.CreateGadInstanceMemberResponse = CreateGadInstanceMemberResponse;
class CreateMigrateTaskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupMode: 'BackupMode',
            checkDBMode: 'CheckDBMode',
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            isOnlineDB: 'IsOnlineDB',
            migrateTaskId: 'MigrateTaskId',
            OSSUrls: 'OSSUrls',
            ossObjectPositions: 'OssObjectPositions',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            backupMode: 'string',
            checkDBMode: 'string',
            DBInstanceId: 'string',
            DBName: 'string',
            isOnlineDB: 'string',
            migrateTaskId: 'string',
            OSSUrls: 'string',
            ossObjectPositions: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.CreateMigrateTaskRequest = CreateMigrateTaskRequest;
class CreateMigrateTaskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupMode: 'BackupMode',
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            migrateTaskId: 'MigrateTaskId',
            requestId: 'RequestId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            backupMode: 'string',
            DBInstanceId: 'string',
            DBName: 'string',
            migrateTaskId: 'string',
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.CreateMigrateTaskResponseBody = CreateMigrateTaskResponseBody;
class CreateMigrateTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateMigrateTaskResponseBody,
        };
    }
}
exports.CreateMigrateTaskResponse = CreateMigrateTaskResponse;
class CreateOnlineDatabaseTaskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkDBMode: 'CheckDBMode',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            migrateTaskId: 'MigrateTaskId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            checkDBMode: 'string',
            clientToken: 'string',
            DBInstanceId: 'string',
            DBName: 'string',
            migrateTaskId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.CreateOnlineDatabaseTaskRequest = CreateOnlineDatabaseTaskRequest;
class CreateOnlineDatabaseTaskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.CreateOnlineDatabaseTaskResponseBody = CreateOnlineDatabaseTaskResponseBody;
class CreateOnlineDatabaseTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateOnlineDatabaseTaskResponseBody,
        };
    }
}
exports.CreateOnlineDatabaseTaskResponse = CreateOnlineDatabaseTaskResponse;
class CreateOrderForCreateDBNodesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPay: 'AutoPay',
            businessInfo: 'BusinessInfo',
            clientToken: 'ClientToken',
            commodityCode: 'CommodityCode',
            DBInstanceId: 'DBInstanceId',
            DBNode: 'DBNode',
            engineVersion: 'EngineVersion',
            nodeType: 'NodeType',
            ownerId: 'OwnerId',
            promotionCode: 'PromotionCode',
            regionId: 'RegionId',
            resource: 'Resource',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            autoPay: 'boolean',
            businessInfo: 'string',
            clientToken: 'string',
            commodityCode: 'string',
            DBInstanceId: 'string',
            DBNode: { 'type': 'array', 'itemType': CreateOrderForCreateDBNodesRequestDBNode },
            engineVersion: 'string',
            nodeType: 'string',
            ownerId: 'number',
            promotionCode: 'string',
            regionId: 'string',
            resource: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            zoneId: 'string',
        };
    }
}
exports.CreateOrderForCreateDBNodesRequest = CreateOrderForCreateDBNodesRequest;
class CreateOrderForCreateDBNodesShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPay: 'AutoPay',
            businessInfo: 'BusinessInfo',
            clientToken: 'ClientToken',
            commodityCode: 'CommodityCode',
            DBInstanceId: 'DBInstanceId',
            DBNodeShrink: 'DBNode',
            engineVersion: 'EngineVersion',
            nodeType: 'NodeType',
            ownerId: 'OwnerId',
            promotionCode: 'PromotionCode',
            regionId: 'RegionId',
            resource: 'Resource',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            autoPay: 'boolean',
            businessInfo: 'string',
            clientToken: 'string',
            commodityCode: 'string',
            DBInstanceId: 'string',
            DBNodeShrink: 'string',
            engineVersion: 'string',
            nodeType: 'string',
            ownerId: 'number',
            promotionCode: 'string',
            regionId: 'string',
            resource: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            zoneId: 'string',
        };
    }
}
exports.CreateOrderForCreateDBNodesShrinkRequest = CreateOrderForCreateDBNodesShrinkRequest;
class CreateOrderForCreateDBNodesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            orderId: 'OrderId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            orderId: 'number',
            requestId: 'string',
        };
    }
}
exports.CreateOrderForCreateDBNodesResponseBody = CreateOrderForCreateDBNodesResponseBody;
class CreateOrderForCreateDBNodesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateOrderForCreateDBNodesResponseBody,
        };
    }
}
exports.CreateOrderForCreateDBNodesResponse = CreateOrderForCreateDBNodesResponse;
class CreateOrderForDeleteDBNodesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPay: 'AutoPay',
            businessInfo: 'BusinessInfo',
            clientToken: 'ClientToken',
            commodityCode: 'CommodityCode',
            DBInstanceId: 'DBInstanceId',
            DBNodeId: 'DBNodeId',
            engineVersion: 'EngineVersion',
            nodeType: 'NodeType',
            ownerId: 'OwnerId',
            promotionCode: 'PromotionCode',
            regionId: 'RegionId',
            resource: 'Resource',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            autoPay: 'boolean',
            businessInfo: 'string',
            clientToken: 'string',
            commodityCode: 'string',
            DBInstanceId: 'string',
            DBNodeId: { 'type': 'array', 'itemType': 'string' },
            engineVersion: 'string',
            nodeType: 'string',
            ownerId: 'number',
            promotionCode: 'string',
            regionId: 'string',
            resource: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            zoneId: 'string',
        };
    }
}
exports.CreateOrderForDeleteDBNodesRequest = CreateOrderForDeleteDBNodesRequest;
class CreateOrderForDeleteDBNodesShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPay: 'AutoPay',
            businessInfo: 'BusinessInfo',
            clientToken: 'ClientToken',
            commodityCode: 'CommodityCode',
            DBInstanceId: 'DBInstanceId',
            DBNodeIdShrink: 'DBNodeId',
            engineVersion: 'EngineVersion',
            nodeType: 'NodeType',
            ownerId: 'OwnerId',
            promotionCode: 'PromotionCode',
            regionId: 'RegionId',
            resource: 'Resource',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            autoPay: 'boolean',
            businessInfo: 'string',
            clientToken: 'string',
            commodityCode: 'string',
            DBInstanceId: 'string',
            DBNodeIdShrink: 'string',
            engineVersion: 'string',
            nodeType: 'string',
            ownerId: 'number',
            promotionCode: 'string',
            regionId: 'string',
            resource: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            zoneId: 'string',
        };
    }
}
exports.CreateOrderForDeleteDBNodesShrinkRequest = CreateOrderForDeleteDBNodesShrinkRequest;
class CreateOrderForDeleteDBNodesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            orderId: 'OrderId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            orderId: 'number',
            requestId: 'string',
        };
    }
}
exports.CreateOrderForDeleteDBNodesResponseBody = CreateOrderForDeleteDBNodesResponseBody;
class CreateOrderForDeleteDBNodesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateOrderForDeleteDBNodesResponseBody,
        };
    }
}
exports.CreateOrderForDeleteDBNodesResponse = CreateOrderForDeleteDBNodesResponse;
class CreateParameterGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            ownerId: 'OwnerId',
            parameterGroupDesc: 'ParameterGroupDesc',
            parameterGroupName: 'ParameterGroupName',
            parameters: 'Parameters',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            engine: 'string',
            engineVersion: 'string',
            ownerId: 'number',
            parameterGroupDesc: 'string',
            parameterGroupName: 'string',
            parameters: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.CreateParameterGroupRequest = CreateParameterGroupRequest;
class CreateParameterGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            parameterGroupId: 'ParameterGroupId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            parameterGroupId: 'string',
            requestId: 'string',
        };
    }
}
exports.CreateParameterGroupResponseBody = CreateParameterGroupResponseBody;
class CreateParameterGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateParameterGroupResponseBody,
        };
    }
}
exports.CreateParameterGroupResponse = CreateParameterGroupResponse;
class CreatePostgresExtensionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountName: 'AccountName',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            DBNames: 'DBNames',
            extensions: 'Extensions',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            sourceDatabase: 'SourceDatabase',
        };
    }
    static types() {
        return {
            accountName: 'string',
            clientToken: 'string',
            DBInstanceId: 'string',
            DBNames: 'string',
            extensions: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            sourceDatabase: 'string',
        };
    }
}
exports.CreatePostgresExtensionsRequest = CreatePostgresExtensionsRequest;
class CreatePostgresExtensionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.CreatePostgresExtensionsResponseBody = CreatePostgresExtensionsResponseBody;
class CreatePostgresExtensionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreatePostgresExtensionsResponseBody,
        };
    }
}
exports.CreatePostgresExtensionsResponse = CreatePostgresExtensionsResponse;
class CreateReadOnlyDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPay: 'AutoPay',
            autoRenew: 'AutoRenew',
            bpeEnabled: 'BpeEnabled',
            burstingEnabled: 'BurstingEnabled',
            category: 'Category',
            clientToken: 'ClientToken',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            deletionProtection: 'DeletionProtection',
            engineVersion: 'EngineVersion',
            gdnInstanceName: 'GdnInstanceName',
            instanceNetworkType: 'InstanceNetworkType',
            instructionSetArch: 'InstructionSetArch',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            payType: 'PayType',
            period: 'Period',
            port: 'Port',
            privateIpAddress: 'PrivateIpAddress',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            targetDedicatedHostIdForMaster: 'TargetDedicatedHostIdForMaster',
            tddlBizType: 'TddlBizType',
            tddlRegionConfig: 'TddlRegionConfig',
            usedTime: 'UsedTime',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            autoPay: 'boolean',
            autoRenew: 'string',
            bpeEnabled: 'string',
            burstingEnabled: 'boolean',
            category: 'string',
            clientToken: 'string',
            DBInstanceClass: 'string',
            DBInstanceDescription: 'string',
            DBInstanceId: 'string',
            DBInstanceStorage: 'number',
            DBInstanceStorageType: 'string',
            dedicatedHostGroupId: 'string',
            deletionProtection: 'boolean',
            engineVersion: 'string',
            gdnInstanceName: 'string',
            instanceNetworkType: 'string',
            instructionSetArch: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            payType: 'string',
            period: 'string',
            port: 'string',
            privateIpAddress: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            targetDedicatedHostIdForMaster: 'string',
            tddlBizType: 'string',
            tddlRegionConfig: 'string',
            usedTime: 'string',
            VPCId: 'string',
            vSwitchId: 'string',
            zoneId: 'string',
        };
    }
}
exports.CreateReadOnlyDBInstanceRequest = CreateReadOnlyDBInstanceRequest;
class CreateReadOnlyDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectionString: 'ConnectionString',
            DBInstanceId: 'DBInstanceId',
            orderId: 'OrderId',
            port: 'Port',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            connectionString: 'string',
            DBInstanceId: 'string',
            orderId: 'string',
            port: 'string',
            requestId: 'string',
        };
    }
}
exports.CreateReadOnlyDBInstanceResponseBody = CreateReadOnlyDBInstanceResponseBody;
class CreateReadOnlyDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateReadOnlyDBInstanceResponseBody,
        };
    }
}
exports.CreateReadOnlyDBInstanceResponse = CreateReadOnlyDBInstanceResponse;
class CreateSecretRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            dbInstanceId: 'DbInstanceId',
            dbNames: 'DbNames',
            description: 'Description',
            engine: 'Engine',
            ownerId: 'OwnerId',
            password: 'Password',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            secretName: 'SecretName',
            username: 'Username',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            dbInstanceId: 'string',
            dbNames: 'string',
            description: 'string',
            engine: 'string',
            ownerId: 'number',
            password: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            secretName: 'string',
            username: 'string',
        };
    }
}
exports.CreateSecretRequest = CreateSecretRequest;
class CreateSecretResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
            secretArn: 'SecretArn',
            secretName: 'SecretName',
            success: 'Success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            secretArn: 'string',
            secretName: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateSecretResponseBody = CreateSecretResponseBody;
class CreateSecretResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSecretResponseBody,
        };
    }
}
exports.CreateSecretResponse = CreateSecretResponse;
class CreateServiceLinkedRoleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            serviceLinkedRole: 'ServiceLinkedRole',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            serviceLinkedRole: 'string',
        };
    }
}
exports.CreateServiceLinkedRoleRequest = CreateServiceLinkedRoleRequest;
class CreateServiceLinkedRoleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.CreateServiceLinkedRoleResponseBody = CreateServiceLinkedRoleResponseBody;
class CreateServiceLinkedRoleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateServiceLinkedRoleResponseBody,
        };
    }
}
exports.CreateServiceLinkedRoleResponse = CreateServiceLinkedRoleResponse;
class CreateTempDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            restoreTime: 'RestoreTime',
        };
    }
    static types() {
        return {
            backupId: 'number',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            restoreTime: 'string',
        };
    }
}
exports.CreateTempDBInstanceRequest = CreateTempDBInstanceRequest;
class CreateTempDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
            tempDBInstanceId: 'TempDBInstanceId',
        };
    }
    static types() {
        return {
            requestId: 'string',
            tempDBInstanceId: 'string',
        };
    }
}
exports.CreateTempDBInstanceResponseBody = CreateTempDBInstanceResponseBody;
class CreateTempDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateTempDBInstanceResponseBody,
        };
    }
}
exports.CreateTempDBInstanceResponse = CreateTempDBInstanceResponse;
class CreateYouhuiForOrderRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            activityId: 'ActivityId',
            ownerId: 'OwnerId',
            promotionId: 'PromotionId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            activityId: 'number',
            ownerId: 'string',
            promotionId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'string',
        };
    }
}
exports.CreateYouhuiForOrderRequest = CreateYouhuiForOrderRequest;
class CreateYouhuiForOrderResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            message: 'Message',
            requestId: 'RequestId',
            youhuiId: 'YouhuiId',
        };
    }
    static types() {
        return {
            message: 'string',
            requestId: 'string',
            youhuiId: 'string',
        };
    }
}
exports.CreateYouhuiForOrderResponseBody = CreateYouhuiForOrderResponseBody;
class CreateYouhuiForOrderResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateYouhuiForOrderResponseBody,
        };
    }
}
exports.CreateYouhuiForOrderResponse = CreateYouhuiForOrderResponse;
class DeleteADSettingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DeleteADSettingRequest = DeleteADSettingRequest;
class DeleteADSettingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteADSettingResponseBody = DeleteADSettingResponseBody;
class DeleteADSettingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteADSettingResponseBody,
        };
    }
}
exports.DeleteADSettingResponse = DeleteADSettingResponse;
class DeleteAccountRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountName: 'AccountName',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            accountName: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DeleteAccountRequest = DeleteAccountRequest;
class DeleteAccountResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteAccountResponseBody = DeleteAccountResponseBody;
class DeleteAccountResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteAccountResponseBody,
        };
    }
}
exports.DeleteAccountResponse = DeleteAccountResponse;
class DeleteBackupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            backupId: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DeleteBackupRequest = DeleteBackupRequest;
class DeleteBackupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteBackupResponseBody = DeleteBackupResponseBody;
class DeleteBackupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteBackupResponseBody,
        };
    }
}
exports.DeleteBackupResponse = DeleteBackupResponse;
class DeleteBackupFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            backupTime: 'BackupTime',
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            backupId: 'string',
            backupTime: 'string',
            DBInstanceId: 'string',
            DBName: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DeleteBackupFileRequest = DeleteBackupFileRequest;
class DeleteBackupFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deletedBaksetIds: 'DeletedBaksetIds',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            deletedBaksetIds: DeleteBackupFileResponseBodyDeletedBaksetIds,
            requestId: 'string',
        };
    }
}
exports.DeleteBackupFileResponseBody = DeleteBackupFileResponseBody;
class DeleteBackupFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteBackupFileResponseBody,
        };
    }
}
exports.DeleteBackupFileResponse = DeleteBackupFileResponse;
class DeleteDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            releasedKeepPolicy: 'ReleasedKeepPolicy',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            releasedKeepPolicy: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DeleteDBInstanceRequest = DeleteDBInstanceRequest;
class DeleteDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            regionId: 'RegionId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            regionId: 'string',
            requestId: 'string',
        };
    }
}
exports.DeleteDBInstanceResponseBody = DeleteDBInstanceResponseBody;
class DeleteDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDBInstanceResponseBody,
        };
    }
}
exports.DeleteDBInstanceResponse = DeleteDBInstanceResponse;
class DeleteDBInstanceEndpointRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceEndpointId: 'DBInstanceEndpointId',
            DBInstanceId: 'DBInstanceId',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceEndpointId: 'string',
            DBInstanceId: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DeleteDBInstanceEndpointRequest = DeleteDBInstanceEndpointRequest;
class DeleteDBInstanceEndpointResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: DeleteDBInstanceEndpointResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.DeleteDBInstanceEndpointResponseBody = DeleteDBInstanceEndpointResponseBody;
class DeleteDBInstanceEndpointResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDBInstanceEndpointResponseBody,
        };
    }
}
exports.DeleteDBInstanceEndpointResponse = DeleteDBInstanceEndpointResponse;
class DeleteDBInstanceEndpointAddressRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            connectionString: 'ConnectionString',
            DBInstanceEndpointId: 'DBInstanceEndpointId',
            DBInstanceId: 'DBInstanceId',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            connectionString: 'string',
            DBInstanceEndpointId: 'string',
            DBInstanceId: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DeleteDBInstanceEndpointAddressRequest = DeleteDBInstanceEndpointAddressRequest;
class DeleteDBInstanceEndpointAddressResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: DeleteDBInstanceEndpointAddressResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.DeleteDBInstanceEndpointAddressResponseBody = DeleteDBInstanceEndpointAddressResponseBody;
class DeleteDBInstanceEndpointAddressResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDBInstanceEndpointAddressResponseBody,
        };
    }
}
exports.DeleteDBInstanceEndpointAddressResponse = DeleteDBInstanceEndpointAddressResponse;
class DeleteDBNodesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            DBNodeId: 'DBNodeId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            DBNodeId: { 'type': 'array', 'itemType': 'string' },
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DeleteDBNodesRequest = DeleteDBNodesRequest;
class DeleteDBNodesShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            DBNodeIdShrink: 'DBNodeId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            DBNodeIdShrink: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DeleteDBNodesShrinkRequest = DeleteDBNodesShrinkRequest;
class DeleteDBNodesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            orderId: 'OrderId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            orderId: 'number',
            requestId: 'string',
        };
    }
}
exports.DeleteDBNodesResponseBody = DeleteDBNodesResponseBody;
class DeleteDBNodesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDBNodesResponseBody,
        };
    }
}
exports.DeleteDBNodesResponse = DeleteDBNodesResponse;
class DeleteDBProxyEndpointAddressRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DBProxyConnectStringNetType: 'DBProxyConnectStringNetType',
            DBProxyEndpointId: 'DBProxyEndpointId',
            DBProxyEngineType: 'DBProxyEngineType',
            regionId: 'RegionId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DBProxyConnectStringNetType: 'string',
            DBProxyEndpointId: 'string',
            DBProxyEngineType: 'string',
            regionId: 'string',
        };
    }
}
exports.DeleteDBProxyEndpointAddressRequest = DeleteDBProxyEndpointAddressRequest;
class DeleteDBProxyEndpointAddressResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteDBProxyEndpointAddressResponseBody = DeleteDBProxyEndpointAddressResponseBody;
class DeleteDBProxyEndpointAddressResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDBProxyEndpointAddressResponseBody,
        };
    }
}
exports.DeleteDBProxyEndpointAddressResponse = DeleteDBProxyEndpointAddressResponse;
class DeleteDatabaseRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DBName: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DeleteDatabaseRequest = DeleteDatabaseRequest;
class DeleteDatabaseResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteDatabaseResponseBody = DeleteDatabaseResponseBody;
class DeleteDatabaseResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDatabaseResponseBody,
        };
    }
}
exports.DeleteDatabaseResponse = DeleteDatabaseResponse;
class DeleteGadInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gadInstanceName: 'GadInstanceName',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
        };
    }
    static types() {
        return {
            gadInstanceName: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
        };
    }
}
exports.DeleteGadInstanceRequest = DeleteGadInstanceRequest;
class DeleteGadInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteGadInstanceResponseBody = DeleteGadInstanceResponseBody;
class DeleteGadInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteGadInstanceResponseBody,
        };
    }
}
exports.DeleteGadInstanceResponse = DeleteGadInstanceResponse;
class DeleteParameterGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
            parameterGroupId: 'ParameterGroupId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            parameterGroupId: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DeleteParameterGroupRequest = DeleteParameterGroupRequest;
class DeleteParameterGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            parameterGroupId: 'ParameterGroupId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            parameterGroupId: 'string',
            requestId: 'string',
        };
    }
}
exports.DeleteParameterGroupResponseBody = DeleteParameterGroupResponseBody;
class DeleteParameterGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteParameterGroupResponseBody,
        };
    }
}
exports.DeleteParameterGroupResponse = DeleteParameterGroupResponse;
class DeletePostgresExtensionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            DBNames: 'DBNames',
            extensions: 'Extensions',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            DBNames: 'string',
            extensions: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DeletePostgresExtensionsRequest = DeletePostgresExtensionsRequest;
class DeletePostgresExtensionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeletePostgresExtensionsResponseBody = DeletePostgresExtensionsResponseBody;
class DeletePostgresExtensionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeletePostgresExtensionsResponseBody,
        };
    }
}
exports.DeletePostgresExtensionsResponse = DeletePostgresExtensionsResponse;
class DeleteSecretRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            dbInstanceId: 'DbInstanceId',
            engine: 'Engine',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            secretArn: 'SecretArn',
            secretName: 'SecretName',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            dbInstanceId: 'string',
            engine: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            secretArn: 'string',
            secretName: 'string',
        };
    }
}
exports.DeleteSecretRequest = DeleteSecretRequest;
class DeleteSecretResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
            secretArn: 'SecretArn',
            secretName: 'SecretName',
            success: 'Success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            secretArn: 'string',
            secretName: 'string',
            success: 'boolean',
        };
    }
}
exports.DeleteSecretResponseBody = DeleteSecretResponseBody;
class DeleteSecretResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteSecretResponseBody,
        };
    }
}
exports.DeleteSecretResponse = DeleteSecretResponse;
class DeleteSlotRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            slotName: 'SlotName',
            slotStatus: 'SlotStatus',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            slotName: 'string',
            slotStatus: 'string',
        };
    }
}
exports.DeleteSlotRequest = DeleteSlotRequest;
class DeleteSlotResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
            slotName: 'SlotName',
        };
    }
    static types() {
        return {
            requestId: 'string',
            slotName: 'string',
        };
    }
}
exports.DeleteSlotResponseBody = DeleteSlotResponseBody;
class DeleteSlotResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteSlotResponseBody,
        };
    }
}
exports.DeleteSlotResponse = DeleteSlotResponse;
class DeleteUserBackupFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            backupId: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DeleteUserBackupFileRequest = DeleteUserBackupFileRequest;
class DeleteUserBackupFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            backupId: 'string',
            requestId: 'string',
        };
    }
}
exports.DeleteUserBackupFileResponseBody = DeleteUserBackupFileResponseBody;
class DeleteUserBackupFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteUserBackupFileResponseBody,
        };
    }
}
exports.DeleteUserBackupFileResponse = DeleteUserBackupFileResponse;
class DescibeImportsFromDatabaseRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            engine: 'Engine',
            importId: 'ImportId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            endTime: 'string',
            engine: 'string',
            importId: 'number',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
        };
    }
}
exports.DescibeImportsFromDatabaseRequest = DescibeImportsFromDatabaseRequest;
class DescibeImportsFromDatabaseResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescibeImportsFromDatabaseResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescibeImportsFromDatabaseResponseBody = DescibeImportsFromDatabaseResponseBody;
class DescibeImportsFromDatabaseResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescibeImportsFromDatabaseResponseBody,
        };
    }
}
exports.DescibeImportsFromDatabaseResponse = DescibeImportsFromDatabaseResponse;
class DescribeADInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeADInfoRequest = DescribeADInfoRequest;
class DescribeADInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ADDNS: 'ADDNS',
            ADServerIpAddress: 'ADServerIpAddress',
            ADStatus: 'ADStatus',
            abnormalReason: 'AbnormalReason',
            requestId: 'RequestId',
            userName: 'UserName',
        };
    }
    static types() {
        return {
            ADDNS: 'string',
            ADServerIpAddress: 'string',
            ADStatus: 'string',
            abnormalReason: 'string',
            requestId: 'string',
            userName: 'string',
        };
    }
}
exports.DescribeADInfoResponseBody = DescribeADInfoResponseBody;
class DescribeADInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeADInfoResponseBody,
        };
    }
}
exports.DescribeADInfoResponse = DescribeADInfoResponse;
class DescribeAccountsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountName: 'AccountName',
            DBInstanceId: 'DBInstanceId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            accountName: 'string',
            DBInstanceId: 'string',
            pageNumber: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeAccountsRequest = DescribeAccountsRequest;
class DescribeAccountsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accounts: 'Accounts',
            pageNumber: 'PageNumber',
            requestId: 'RequestId',
            systemAdminAccountFirstActivationTime: 'SystemAdminAccountFirstActivationTime',
            systemAdminAccountStatus: 'SystemAdminAccountStatus',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            accounts: DescribeAccountsResponseBodyAccounts,
            pageNumber: 'number',
            requestId: 'string',
            systemAdminAccountFirstActivationTime: 'string',
            systemAdminAccountStatus: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeAccountsResponseBody = DescribeAccountsResponseBody;
class DescribeAccountsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeAccountsResponseBody,
        };
    }
}
exports.DescribeAccountsResponse = DescribeAccountsResponse;
class DescribeActionEventPolicyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeActionEventPolicyRequest = DescribeActionEventPolicyRequest;
class DescribeActionEventPolicyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            enableEventLog: 'EnableEventLog',
            regionId: 'RegionId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            enableEventLog: 'string',
            regionId: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeActionEventPolicyResponseBody = DescribeActionEventPolicyResponseBody;
class DescribeActionEventPolicyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeActionEventPolicyResponseBody,
        };
    }
}
exports.DescribeActionEventPolicyResponse = DescribeActionEventPolicyResponse;
class DescribeActiveOperationTasksRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            allowCancel: 'AllowCancel',
            allowChange: 'AllowChange',
            changeLevel: 'ChangeLevel',
            dbType: 'DbType',
            insName: 'InsName',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            productId: 'ProductId',
            region: 'Region',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityToken: 'SecurityToken',
            status: 'Status',
            taskType: 'TaskType',
        };
    }
    static types() {
        return {
            allowCancel: 'number',
            allowChange: 'number',
            changeLevel: 'string',
            dbType: 'string',
            insName: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            productId: 'string',
            region: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            securityToken: 'string',
            status: 'number',
            taskType: 'string',
        };
    }
}
exports.DescribeActiveOperationTasksRequest = DescribeActiveOperationTasksRequest;
class DescribeActiveOperationTasksResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': DescribeActiveOperationTasksResponseBodyItems },
            pageNumber: 'number',
            pageSize: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeActiveOperationTasksResponseBody = DescribeActiveOperationTasksResponseBody;
class DescribeActiveOperationTasksResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeActiveOperationTasksResponseBody,
        };
    }
}
exports.DescribeActiveOperationTasksResponse = DescribeActiveOperationTasksResponse;
class DescribeAllWhitelistTemplateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fuzzySearch: 'FuzzySearch',
            maxRecordsPerPage: 'MaxRecordsPerPage',
            pageNumbers: 'PageNumbers',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            templateName: 'TemplateName',
        };
    }
    static types() {
        return {
            fuzzySearch: 'boolean',
            maxRecordsPerPage: 'number',
            pageNumbers: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            templateName: 'string',
        };
    }
}
exports.DescribeAllWhitelistTemplateRequest = DescribeAllWhitelistTemplateRequest;
class DescribeAllWhitelistTemplateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            httpStatusCode: 'HttpStatusCode',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeAllWhitelistTemplateResponseBodyData,
            httpStatusCode: 'number',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeAllWhitelistTemplateResponseBody = DescribeAllWhitelistTemplateResponseBody;
class DescribeAllWhitelistTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeAllWhitelistTemplateResponseBody,
        };
    }
}
exports.DescribeAllWhitelistTemplateResponse = DescribeAllWhitelistTemplateResponse;
class DescribeAnalyticdbByPrimaryDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeAnalyticdbByPrimaryDBInstanceRequest = DescribeAnalyticdbByPrimaryDBInstanceRequest;
class DescribeAnalyticdbByPrimaryDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            analyticDBCount: 'AnalyticDBCount',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            analyticDBCount: 'number',
            requestId: 'string',
        };
    }
}
exports.DescribeAnalyticdbByPrimaryDBInstanceResponseBody = DescribeAnalyticdbByPrimaryDBInstanceResponseBody;
class DescribeAnalyticdbByPrimaryDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeAnalyticdbByPrimaryDBInstanceResponseBody,
        };
    }
}
exports.DescribeAnalyticdbByPrimaryDBInstanceResponse = DescribeAnalyticdbByPrimaryDBInstanceResponse;
class DescribeAvailableClassesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'Category',
            commodityCode: 'CommodityCode',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStorageType: 'DBInstanceStorageType',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            instanceChargeType: 'InstanceChargeType',
            orderType: 'OrderType',
            regionId: 'RegionId',
            resourceOwnerId: 'ResourceOwnerId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            category: 'string',
            commodityCode: 'string',
            DBInstanceId: 'string',
            DBInstanceStorageType: 'string',
            engine: 'string',
            engineVersion: 'string',
            instanceChargeType: 'string',
            orderType: 'string',
            regionId: 'string',
            resourceOwnerId: 'number',
            zoneId: 'string',
        };
    }
}
exports.DescribeAvailableClassesRequest = DescribeAvailableClassesRequest;
class DescribeAvailableClassesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceClasses: 'DBInstanceClasses',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceClasses: { 'type': 'array', 'itemType': DescribeAvailableClassesResponseBodyDBInstanceClasses },
            requestId: 'string',
        };
    }
}
exports.DescribeAvailableClassesResponseBody = DescribeAvailableClassesResponseBody;
class DescribeAvailableClassesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeAvailableClassesResponseBody,
        };
    }
}
exports.DescribeAvailableClassesResponse = DescribeAvailableClassesResponse;
class DescribeAvailableCrossRegionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeAvailableCrossRegionRequest = DescribeAvailableCrossRegionRequest;
class DescribeAvailableCrossRegionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            regions: 'Regions',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            regions: DescribeAvailableCrossRegionResponseBodyRegions,
            requestId: 'string',
        };
    }
}
exports.DescribeAvailableCrossRegionResponseBody = DescribeAvailableCrossRegionResponseBody;
class DescribeAvailableCrossRegionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeAvailableCrossRegionResponseBody,
        };
    }
}
exports.DescribeAvailableCrossRegionResponse = DescribeAvailableCrossRegionResponse;
class DescribeAvailableMetricsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            resourceGroupId: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeAvailableMetricsRequest = DescribeAvailableMetricsRequest;
class DescribeAvailableMetricsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            items: 'Items',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            items: { 'type': 'array', 'itemType': DescribeAvailableMetricsResponseBodyItems },
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeAvailableMetricsResponseBody = DescribeAvailableMetricsResponseBody;
class DescribeAvailableMetricsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeAvailableMetricsResponseBody,
        };
    }
}
exports.DescribeAvailableMetricsResponse = DescribeAvailableMetricsResponse;
class DescribeAvailableRecoveryTimeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            crossBackupId: 'CrossBackupId',
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            crossBackupId: 'number',
            DBInstanceId: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeAvailableRecoveryTimeRequest = DescribeAvailableRecoveryTimeRequest;
class DescribeAvailableRecoveryTimeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            crossBackupId: 'CrossBackupId',
            recoveryBeginTime: 'RecoveryBeginTime',
            recoveryEndTime: 'RecoveryEndTime',
            regionId: 'RegionId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            crossBackupId: 'number',
            recoveryBeginTime: 'string',
            recoveryEndTime: 'string',
            regionId: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeAvailableRecoveryTimeResponseBody = DescribeAvailableRecoveryTimeResponseBody;
class DescribeAvailableRecoveryTimeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeAvailableRecoveryTimeResponseBody,
        };
    }
}
exports.DescribeAvailableRecoveryTimeResponse = DescribeAvailableRecoveryTimeResponse;
class DescribeAvailableZonesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'Category',
            commodityCode: 'CommodityCode',
            DBInstanceName: 'DBInstanceName',
            dispenseMode: 'DispenseMode',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            regionId: 'RegionId',
            resourceOwnerId: 'ResourceOwnerId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            category: 'string',
            commodityCode: 'string',
            DBInstanceName: 'string',
            dispenseMode: 'string',
            engine: 'string',
            engineVersion: 'string',
            regionId: 'string',
            resourceOwnerId: 'number',
            zoneId: 'string',
        };
    }
}
exports.DescribeAvailableZonesRequest = DescribeAvailableZonesRequest;
class DescribeAvailableZonesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availableZones: 'AvailableZones',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            availableZones: { 'type': 'array', 'itemType': DescribeAvailableZonesResponseBodyAvailableZones },
            requestId: 'string',
        };
    }
}
exports.DescribeAvailableZonesResponseBody = DescribeAvailableZonesResponseBody;
class DescribeAvailableZonesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeAvailableZonesResponseBody,
        };
    }
}
exports.DescribeAvailableZonesResponse = DescribeAvailableZonesResponse;
class DescribeBackupDatabaseRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            backupId: 'string',
            DBInstanceId: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeBackupDatabaseRequest = DescribeBackupDatabaseRequest;
class DescribeBackupDatabaseResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            databaseNames: 'DatabaseNames',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            databaseNames: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeBackupDatabaseResponseBody = DescribeBackupDatabaseResponseBody;
class DescribeBackupDatabaseResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeBackupDatabaseResponseBody,
        };
    }
}
exports.DescribeBackupDatabaseResponse = DescribeBackupDatabaseResponse;
class DescribeBackupPolicyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupPolicyMode: 'BackupPolicyMode',
            compressType: 'CompressType',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            releasedKeepPolicy: 'ReleasedKeepPolicy',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            backupPolicyMode: 'string',
            compressType: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            releasedKeepPolicy: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeBackupPolicyRequest = DescribeBackupPolicyRequest;
class DescribeBackupPolicyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            archiveBackupKeepCount: 'ArchiveBackupKeepCount',
            archiveBackupKeepPolicy: 'ArchiveBackupKeepPolicy',
            archiveBackupRetentionPeriod: 'ArchiveBackupRetentionPeriod',
            backupInterval: 'BackupInterval',
            backupLog: 'BackupLog',
            backupMethod: 'BackupMethod',
            backupPriority: 'BackupPriority',
            backupRetentionPeriod: 'BackupRetentionPeriod',
            category: 'Category',
            compressType: 'CompressType',
            enableBackupLog: 'EnableBackupLog',
            enableIncrementDataBackup: 'EnableIncrementDataBackup',
            highSpaceUsageProtection: 'HighSpaceUsageProtection',
            localLogRetentionHours: 'LocalLogRetentionHours',
            localLogRetentionSpace: 'LocalLogRetentionSpace',
            logBackupFrequency: 'LogBackupFrequency',
            logBackupLocalRetentionNumber: 'LogBackupLocalRetentionNumber',
            logBackupRetentionPeriod: 'LogBackupRetentionPeriod',
            preferredBackupPeriod: 'PreferredBackupPeriod',
            preferredBackupTime: 'PreferredBackupTime',
            preferredNextBackupTime: 'PreferredNextBackupTime',
            releasedKeepPolicy: 'ReleasedKeepPolicy',
            requestId: 'RequestId',
            supportModifyBackupPriority: 'SupportModifyBackupPriority',
            supportReleasedKeep: 'SupportReleasedKeep',
            supportVolumeShadowCopy: 'SupportVolumeShadowCopy',
        };
    }
    static types() {
        return {
            archiveBackupKeepCount: 'string',
            archiveBackupKeepPolicy: 'string',
            archiveBackupRetentionPeriod: 'string',
            backupInterval: 'string',
            backupLog: 'string',
            backupMethod: 'string',
            backupPriority: 'number',
            backupRetentionPeriod: 'number',
            category: 'string',
            compressType: 'string',
            enableBackupLog: 'string',
            enableIncrementDataBackup: 'boolean',
            highSpaceUsageProtection: 'string',
            localLogRetentionHours: 'number',
            localLogRetentionSpace: 'string',
            logBackupFrequency: 'string',
            logBackupLocalRetentionNumber: 'number',
            logBackupRetentionPeriod: 'number',
            preferredBackupPeriod: 'string',
            preferredBackupTime: 'string',
            preferredNextBackupTime: 'string',
            releasedKeepPolicy: 'string',
            requestId: 'string',
            supportModifyBackupPriority: 'boolean',
            supportReleasedKeep: 'number',
            supportVolumeShadowCopy: 'number',
        };
    }
}
exports.DescribeBackupPolicyResponseBody = DescribeBackupPolicyResponseBody;
class DescribeBackupPolicyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeBackupPolicyResponseBody,
        };
    }
}
exports.DescribeBackupPolicyResponse = DescribeBackupPolicyResponse;
class DescribeBackupTasksRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupJobId: 'BackupJobId',
            backupJobStatus: 'BackupJobStatus',
            backupMode: 'BackupMode',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            flag: 'Flag',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            backupJobId: 'number',
            backupJobStatus: 'string',
            backupMode: 'string',
            clientToken: 'string',
            DBInstanceId: 'string',
            flag: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeBackupTasksRequest = DescribeBackupTasksRequest;
class DescribeBackupTasksResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            items: DescribeBackupTasksResponseBodyItems,
            requestId: 'string',
        };
    }
}
exports.DescribeBackupTasksResponseBody = DescribeBackupTasksResponseBody;
class DescribeBackupTasksResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeBackupTasksResponseBody,
        };
    }
}
exports.DescribeBackupTasksResponse = DescribeBackupTasksResponse;
class DescribeBackupsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            backupMode: 'BackupMode',
            backupStatus: 'BackupStatus',
            backupType: 'BackupType',
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            backupId: 'string',
            backupMode: 'string',
            backupStatus: 'string',
            backupType: 'string',
            DBInstanceId: 'string',
            endTime: 'string',
            pageNumber: 'number',
            pageSize: 'number',
            resourceGroupId: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
        };
    }
}
exports.DescribeBackupsRequest = DescribeBackupsRequest;
class DescribeBackupsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalEcsSnapshotSize: 'TotalEcsSnapshotSize',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescribeBackupsResponseBodyItems,
            pageNumber: 'string',
            pageRecordCount: 'string',
            requestId: 'string',
            totalEcsSnapshotSize: 'number',
            totalRecordCount: 'string',
        };
    }
}
exports.DescribeBackupsResponseBody = DescribeBackupsResponseBody;
class DescribeBackupsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeBackupsResponseBody,
        };
    }
}
exports.DescribeBackupsResponse = DescribeBackupsResponse;
class DescribeBinlogFilesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            endTime: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
        };
    }
}
exports.DescribeBinlogFilesRequest = DescribeBinlogFilesRequest;
class DescribeBinlogFilesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalFileSize: 'TotalFileSize',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescribeBinlogFilesResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalFileSize: 'number',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeBinlogFilesResponseBody = DescribeBinlogFilesResponseBody;
class DescribeBinlogFilesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeBinlogFilesResponseBody,
        };
    }
}
exports.DescribeBinlogFilesResponse = DescribeBinlogFilesResponse;
class DescribeCharacterSetNameRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            engine: 'Engine',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            engine: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeCharacterSetNameRequest = DescribeCharacterSetNameRequest;
class DescribeCharacterSetNameResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            characterSetNameItems: 'CharacterSetNameItems',
            engine: 'Engine',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            characterSetNameItems: DescribeCharacterSetNameResponseBodyCharacterSetNameItems,
            engine: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeCharacterSetNameResponseBody = DescribeCharacterSetNameResponseBody;
class DescribeCharacterSetNameResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeCharacterSetNameResponseBody,
        };
    }
}
exports.DescribeCharacterSetNameResponse = DescribeCharacterSetNameResponse;
class DescribeClassDetailsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            classCode: 'ClassCode',
            clientToken: 'ClientToken',
            commodityCode: 'CommodityCode',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            classCode: 'string',
            clientToken: 'string',
            commodityCode: 'string',
            engine: 'string',
            engineVersion: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeClassDetailsRequest = DescribeClassDetailsRequest;
class DescribeClassDetailsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'Category',
            classCode: 'ClassCode',
            classGroup: 'ClassGroup',
            cpu: 'Cpu',
            DBInstanceStorageType: 'DBInstanceStorageType',
            instructionSetArch: 'InstructionSetArch',
            maxConnections: 'MaxConnections',
            maxIOMBPS: 'MaxIOMBPS',
            maxIOPS: 'MaxIOPS',
            memoryClass: 'MemoryClass',
            referencePrice: 'ReferencePrice',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            category: 'string',
            classCode: 'string',
            classGroup: 'string',
            cpu: 'string',
            DBInstanceStorageType: 'string',
            instructionSetArch: 'string',
            maxConnections: 'string',
            maxIOMBPS: 'string',
            maxIOPS: 'string',
            memoryClass: 'string',
            referencePrice: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeClassDetailsResponseBody = DescribeClassDetailsResponseBody;
class DescribeClassDetailsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeClassDetailsResponseBody,
        };
    }
}
exports.DescribeClassDetailsResponse = DescribeClassDetailsResponse;
class DescribeCloudMigrationPrecheckResultRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceOwnerId: 'ResourceOwnerId',
            sourceIpAddress: 'SourceIpAddress',
            sourcePort: 'SourcePort',
            taskId: 'TaskId',
            taskName: 'TaskName',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            pageNumber: 'number',
            pageSize: 'number',
            resourceOwnerId: 'number',
            sourceIpAddress: 'string',
            sourcePort: 'number',
            taskId: 'number',
            taskName: 'string',
        };
    }
}
exports.DescribeCloudMigrationPrecheckResultRequest = DescribeCloudMigrationPrecheckResultRequest;
class DescribeCloudMigrationPrecheckResultResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            totalSize: 'TotalSize',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': DescribeCloudMigrationPrecheckResultResponseBodyItems },
            pageNumber: 'number',
            pageSize: 'number',
            requestId: 'string',
            totalSize: 'number',
        };
    }
}
exports.DescribeCloudMigrationPrecheckResultResponseBody = DescribeCloudMigrationPrecheckResultResponseBody;
class DescribeCloudMigrationPrecheckResultResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeCloudMigrationPrecheckResultResponseBody,
        };
    }
}
exports.DescribeCloudMigrationPrecheckResultResponse = DescribeCloudMigrationPrecheckResultResponse;
class DescribeCloudMigrationResultRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceOwnerId: 'ResourceOwnerId',
            sourceIpAddress: 'SourceIpAddress',
            sourcePort: 'SourcePort',
            taskId: 'TaskId',
            taskName: 'TaskName',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            pageNumber: 'number',
            pageSize: 'number',
            resourceOwnerId: 'number',
            sourceIpAddress: 'string',
            sourcePort: 'number',
            taskId: 'number',
            taskName: 'string',
        };
    }
}
exports.DescribeCloudMigrationResultRequest = DescribeCloudMigrationResultRequest;
class DescribeCloudMigrationResultResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            totalSize: 'TotalSize',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': DescribeCloudMigrationResultResponseBodyItems },
            pageNumber: 'number',
            pageSize: 'number',
            requestId: 'string',
            totalSize: 'number',
        };
    }
}
exports.DescribeCloudMigrationResultResponseBody = DescribeCloudMigrationResultResponseBody;
class DescribeCloudMigrationResultResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeCloudMigrationResultResponseBody,
        };
    }
}
exports.DescribeCloudMigrationResultResponse = DescribeCloudMigrationResultResponse;
class DescribeCollationTimeZonesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeCollationTimeZonesRequest = DescribeCollationTimeZonesRequest;
class DescribeCollationTimeZonesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            collationTimeZones: 'CollationTimeZones',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            collationTimeZones: DescribeCollationTimeZonesResponseBodyCollationTimeZones,
            requestId: 'string',
        };
    }
}
exports.DescribeCollationTimeZonesResponseBody = DescribeCollationTimeZonesResponseBody;
class DescribeCollationTimeZonesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeCollationTimeZonesResponseBody,
        };
    }
}
exports.DescribeCollationTimeZonesResponse = DescribeCollationTimeZonesResponse;
class DescribeCrossBackupMetaListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupSetId: 'BackupSetId',
            getDbName: 'GetDbName',
            ownerId: 'OwnerId',
            pageIndex: 'PageIndex',
            pageSize: 'PageSize',
            pattern: 'Pattern',
            region: 'Region',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            backupSetId: 'string',
            getDbName: 'string',
            ownerId: 'number',
            pageIndex: 'string',
            pageSize: 'string',
            pattern: 'string',
            region: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeCrossBackupMetaListRequest = DescribeCrossBackupMetaListRequest;
class DescribeCrossBackupMetaListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalPageCount: 'TotalPageCount',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            items: DescribeCrossBackupMetaListResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalPageCount: 'number',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeCrossBackupMetaListResponseBody = DescribeCrossBackupMetaListResponseBody;
class DescribeCrossBackupMetaListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeCrossBackupMetaListResponseBody,
        };
    }
}
exports.DescribeCrossBackupMetaListResponse = DescribeCrossBackupMetaListResponse;
class DescribeCrossRegionBackupDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeCrossRegionBackupDBInstanceRequest = DescribeCrossRegionBackupDBInstanceRequest;
class DescribeCrossRegionBackupDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            itemsNumbers: 'ItemsNumbers',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            regionId: 'RegionId',
            requestId: 'RequestId',
            totalRecords: 'TotalRecords',
        };
    }
    static types() {
        return {
            items: DescribeCrossRegionBackupDBInstanceResponseBodyItems,
            itemsNumbers: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            regionId: 'string',
            requestId: 'string',
            totalRecords: 'number',
        };
    }
}
exports.DescribeCrossRegionBackupDBInstanceResponseBody = DescribeCrossRegionBackupDBInstanceResponseBody;
class DescribeCrossRegionBackupDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeCrossRegionBackupDBInstanceResponseBody,
        };
    }
}
exports.DescribeCrossRegionBackupDBInstanceResponse = DescribeCrossRegionBackupDBInstanceResponse;
class DescribeCrossRegionBackupsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            crossBackupId: 'CrossBackupId',
            crossBackupRegion: 'CrossBackupRegion',
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            backupId: 'number',
            crossBackupId: 'number',
            crossBackupRegion: 'string',
            DBInstanceId: 'string',
            endTime: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
        };
    }
}
exports.DescribeCrossRegionBackupsRequest = DescribeCrossRegionBackupsRequest;
class DescribeCrossRegionBackupsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'EndTime',
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            regionId: 'RegionId',
            requestId: 'RequestId',
            startTime: 'StartTime',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            endTime: 'string',
            items: DescribeCrossRegionBackupsResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            regionId: 'string',
            requestId: 'string',
            startTime: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeCrossRegionBackupsResponseBody = DescribeCrossRegionBackupsResponseBody;
class DescribeCrossRegionBackupsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeCrossRegionBackupsResponseBody,
        };
    }
}
exports.DescribeCrossRegionBackupsResponse = DescribeCrossRegionBackupsResponse;
class DescribeCrossRegionLogBackupFilesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            crossBackupRegion: 'CrossBackupRegion',
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            crossBackupRegion: 'string',
            DBInstanceId: 'string',
            endTime: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
        };
    }
}
exports.DescribeCrossRegionLogBackupFilesRequest = DescribeCrossRegionLogBackupFilesRequest;
class DescribeCrossRegionLogBackupFilesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            regionId: 'RegionId',
            requestId: 'RequestId',
            startTime: 'StartTime',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            endTime: 'string',
            items: DescribeCrossRegionLogBackupFilesResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            regionId: 'string',
            requestId: 'string',
            startTime: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeCrossRegionLogBackupFilesResponseBody = DescribeCrossRegionLogBackupFilesResponseBody;
class DescribeCrossRegionLogBackupFilesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeCrossRegionLogBackupFilesResponseBody,
        };
    }
}
exports.DescribeCrossRegionLogBackupFilesResponse = DescribeCrossRegionLogBackupFilesResponse;
class DescribeCurrentModifyOrderRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            dbInstanceId: 'DbInstanceId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            dbInstanceId: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeCurrentModifyOrderRequest = DescribeCurrentModifyOrderRequest;
class DescribeCurrentModifyOrderResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            modifyOrder: 'ModifyOrder',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            modifyOrder: { 'type': 'array', 'itemType': DescribeCurrentModifyOrderResponseBodyModifyOrder },
            requestId: 'string',
        };
    }
}
exports.DescribeCurrentModifyOrderResponseBody = DescribeCurrentModifyOrderResponseBody;
class DescribeCurrentModifyOrderResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeCurrentModifyOrderResponseBody,
        };
    }
}
exports.DescribeCurrentModifyOrderResponse = DescribeCurrentModifyOrderResponse;
class DescribeCustinsResourceInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceIds: 'DBInstanceIds',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceIds: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeCustinsResourceInfoRequest = DescribeCustinsResourceInfoRequest;
class DescribeCustinsResourceInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': DescribeCustinsResourceInfoResponseBodyData },
            requestId: 'string',
        };
    }
}
exports.DescribeCustinsResourceInfoResponseBody = DescribeCustinsResourceInfoResponseBody;
class DescribeCustinsResourceInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeCustinsResourceInfoResponseBody,
        };
    }
}
exports.DescribeCustinsResourceInfoResponse = DescribeCustinsResourceInfoResponse;
class DescribeDBInstanceAttributeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            expired: 'Expired',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            expired: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDBInstanceAttributeRequest = DescribeDBInstanceAttributeRequest;
class DescribeDBInstanceAttributeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            items: DescribeDBInstanceAttributeResponseBodyItems,
            requestId: 'string',
        };
    }
}
exports.DescribeDBInstanceAttributeResponseBody = DescribeDBInstanceAttributeResponseBody;
class DescribeDBInstanceAttributeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceAttributeResponseBody,
        };
    }
}
exports.DescribeDBInstanceAttributeResponse = DescribeDBInstanceAttributeResponse;
class DescribeDBInstanceByTagsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            proxyId: 'proxyId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            proxyId: 'string',
        };
    }
}
exports.DescribeDBInstanceByTagsRequest = DescribeDBInstanceByTagsRequest;
class DescribeDBInstanceByTagsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescribeDBInstanceByTagsResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeDBInstanceByTagsResponseBody = DescribeDBInstanceByTagsResponseBody;
class DescribeDBInstanceByTagsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceByTagsResponseBody,
        };
    }
}
exports.DescribeDBInstanceByTagsResponse = DescribeDBInstanceByTagsResponse;
class DescribeDBInstanceConnectivityRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dbInstanceName: 'DbInstanceName',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityToken: 'SecurityToken',
            sourceIpAddress: 'SourceIpAddress',
        };
    }
    static types() {
        return {
            dbInstanceName: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            securityToken: 'string',
            sourceIpAddress: 'string',
        };
    }
}
exports.DescribeDBInstanceConnectivityRequest = DescribeDBInstanceConnectivityRequest;
class DescribeDBInstanceConnectivityResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connCheckErrorCode: 'ConnCheckErrorCode',
            connCheckErrorMessage: 'ConnCheckErrorMessage',
            connCheckResult: 'ConnCheckResult',
            dbInstanceName: 'DbInstanceName',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            connCheckErrorCode: 'string',
            connCheckErrorMessage: 'string',
            connCheckResult: 'string',
            dbInstanceName: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeDBInstanceConnectivityResponseBody = DescribeDBInstanceConnectivityResponseBody;
class DescribeDBInstanceConnectivityResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceConnectivityResponseBody,
        };
    }
}
exports.DescribeDBInstanceConnectivityResponse = DescribeDBInstanceConnectivityResponse;
class DescribeDBInstanceDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDBInstanceDetailRequest = DescribeDBInstanceDetailRequest;
class DescribeDBInstanceDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            activationState: 'ActivationState',
            DBInstanceId: 'DBInstanceId',
            licenseType: 'LicenseType',
            regionId: 'RegionId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            activationState: 'string',
            DBInstanceId: 'string',
            licenseType: 'string',
            regionId: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeDBInstanceDetailResponseBody = DescribeDBInstanceDetailResponseBody;
class DescribeDBInstanceDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceDetailResponseBody,
        };
    }
}
exports.DescribeDBInstanceDetailResponse = DescribeDBInstanceDetailResponse;
class DescribeDBInstanceEncryptionKeyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            encryptionKey: 'EncryptionKey',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityToken: 'SecurityToken',
            targetRegionId: 'TargetRegionId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            encryptionKey: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            securityToken: 'string',
            targetRegionId: 'string',
        };
    }
}
exports.DescribeDBInstanceEncryptionKeyRequest = DescribeDBInstanceEncryptionKeyRequest;
class DescribeDBInstanceEncryptionKeyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            creator: 'Creator',
            deleteDate: 'DeleteDate',
            description: 'Description',
            encryptionKey: 'EncryptionKey',
            encryptionKeyList: 'EncryptionKeyList',
            encryptionKeyStatus: 'EncryptionKeyStatus',
            keyUsage: 'KeyUsage',
            materialExpireTime: 'MaterialExpireTime',
            origin: 'Origin',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            creator: 'string',
            deleteDate: 'string',
            description: 'string',
            encryptionKey: 'string',
            encryptionKeyList: { 'type': 'array', 'itemType': DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList },
            encryptionKeyStatus: 'string',
            keyUsage: 'string',
            materialExpireTime: 'string',
            origin: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeDBInstanceEncryptionKeyResponseBody = DescribeDBInstanceEncryptionKeyResponseBody;
class DescribeDBInstanceEncryptionKeyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceEncryptionKeyResponseBody,
        };
    }
}
exports.DescribeDBInstanceEncryptionKeyResponse = DescribeDBInstanceEncryptionKeyResponse;
class DescribeDBInstanceEndpointsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceEndpointId: 'DBInstanceEndpointId',
            DBInstanceId: 'DBInstanceId',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceEndpointId: 'string',
            DBInstanceId: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDBInstanceEndpointsRequest = DescribeDBInstanceEndpointsRequest;
class DescribeDBInstanceEndpointsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: DescribeDBInstanceEndpointsResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.DescribeDBInstanceEndpointsResponseBody = DescribeDBInstanceEndpointsResponseBody;
class DescribeDBInstanceEndpointsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceEndpointsResponseBody,
        };
    }
}
exports.DescribeDBInstanceEndpointsResponse = DescribeDBInstanceEndpointsResponse;
class DescribeDBInstanceHAConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDBInstanceHAConfigRequest = DescribeDBInstanceHAConfigRequest;
class DescribeDBInstanceHAConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            HAMode: 'HAMode',
            hostInstanceInfos: 'HostInstanceInfos',
            requestId: 'RequestId',
            syncMode: 'SyncMode',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            HAMode: 'string',
            hostInstanceInfos: DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos,
            requestId: 'string',
            syncMode: 'string',
        };
    }
}
exports.DescribeDBInstanceHAConfigResponseBody = DescribeDBInstanceHAConfigResponseBody;
class DescribeDBInstanceHAConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceHAConfigResponseBody,
        };
    }
}
exports.DescribeDBInstanceHAConfigResponse = DescribeDBInstanceHAConfigResponse;
class DescribeDBInstanceIPArrayListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            whitelistNetworkType: 'WhitelistNetworkType',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            resourceOwnerId: 'number',
            whitelistNetworkType: 'string',
        };
    }
}
exports.DescribeDBInstanceIPArrayListRequest = DescribeDBInstanceIPArrayListRequest;
class DescribeDBInstanceIPArrayListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            items: DescribeDBInstanceIPArrayListResponseBodyItems,
            requestId: 'string',
        };
    }
}
exports.DescribeDBInstanceIPArrayListResponseBody = DescribeDBInstanceIPArrayListResponseBody;
class DescribeDBInstanceIPArrayListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceIPArrayListResponseBody,
        };
    }
}
exports.DescribeDBInstanceIPArrayListResponse = DescribeDBInstanceIPArrayListResponse;
class DescribeDBInstanceIpHostnameRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityToken: 'SecurityToken',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            securityToken: 'string',
        };
    }
}
exports.DescribeDBInstanceIpHostnameRequest = DescribeDBInstanceIpHostnameRequest;
class DescribeDBInstanceIpHostnameResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ipHostnameInfos: 'IpHostnameInfos',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ipHostnameInfos: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeDBInstanceIpHostnameResponseBody = DescribeDBInstanceIpHostnameResponseBody;
class DescribeDBInstanceIpHostnameResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceIpHostnameResponseBody,
        };
    }
}
exports.DescribeDBInstanceIpHostnameResponse = DescribeDBInstanceIpHostnameResponse;
class DescribeDBInstanceMetricsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            resourceGroupId: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDBInstanceMetricsRequest = DescribeDBInstanceMetricsRequest;
class DescribeDBInstanceMetricsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            items: 'Items',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            items: { 'type': 'array', 'itemType': DescribeDBInstanceMetricsResponseBodyItems },
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeDBInstanceMetricsResponseBody = DescribeDBInstanceMetricsResponseBody;
class DescribeDBInstanceMetricsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceMetricsResponseBody,
        };
    }
}
exports.DescribeDBInstanceMetricsResponse = DescribeDBInstanceMetricsResponse;
class DescribeDBInstanceMonitorRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDBInstanceMonitorRequest = DescribeDBInstanceMonitorRequest;
class DescribeDBInstanceMonitorResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            period: 'Period',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            period: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeDBInstanceMonitorResponseBody = DescribeDBInstanceMonitorResponseBody;
class DescribeDBInstanceMonitorResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceMonitorResponseBody,
        };
    }
}
exports.DescribeDBInstanceMonitorResponse = DescribeDBInstanceMonitorResponse;
class DescribeDBInstanceNetInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            DBInstanceNetRWSplitType: 'DBInstanceNetRWSplitType',
            flag: 'Flag',
            generalGroupName: 'GeneralGroupName',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            DBInstanceNetRWSplitType: 'string',
            flag: 'number',
            generalGroupName: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDBInstanceNetInfoRequest = DescribeDBInstanceNetInfoRequest;
class DescribeDBInstanceNetInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceNetInfos: 'DBInstanceNetInfos',
            instanceNetworkType: 'InstanceNetworkType',
            requestId: 'RequestId',
            securityIPMode: 'SecurityIPMode',
        };
    }
    static types() {
        return {
            DBInstanceNetInfos: DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos,
            instanceNetworkType: 'string',
            requestId: 'string',
            securityIPMode: 'string',
        };
    }
}
exports.DescribeDBInstanceNetInfoResponseBody = DescribeDBInstanceNetInfoResponseBody;
class DescribeDBInstanceNetInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceNetInfoResponseBody,
        };
    }
}
exports.DescribeDBInstanceNetInfoResponse = DescribeDBInstanceNetInfoResponse;
class DescribeDBInstanceNetInfoForChannelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            DBInstanceNetRWSplitType: 'DBInstanceNetRWSplitType',
            flag: 'Flag',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            DBInstanceNetRWSplitType: 'string',
            flag: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDBInstanceNetInfoForChannelRequest = DescribeDBInstanceNetInfoForChannelRequest;
class DescribeDBInstanceNetInfoForChannelResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceNetInfos: 'DBInstanceNetInfos',
            instanceNetworkType: 'InstanceNetworkType',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceNetInfos: DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfos,
            instanceNetworkType: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeDBInstanceNetInfoForChannelResponseBody = DescribeDBInstanceNetInfoForChannelResponseBody;
class DescribeDBInstanceNetInfoForChannelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceNetInfoForChannelResponseBody,
        };
    }
}
exports.DescribeDBInstanceNetInfoForChannelResponse = DescribeDBInstanceNetInfoForChannelResponse;
class DescribeDBInstancePerformanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            key: 'Key',
            nodeId: 'NodeId',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            endTime: 'string',
            key: 'string',
            nodeId: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
        };
    }
}
exports.DescribeDBInstancePerformanceRequest = DescribeDBInstancePerformanceRequest;
class DescribeDBInstancePerformanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            engine: 'Engine',
            performanceKeys: 'PerformanceKeys',
            requestId: 'RequestId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            endTime: 'string',
            engine: 'string',
            performanceKeys: DescribeDBInstancePerformanceResponseBodyPerformanceKeys,
            requestId: 'string',
            startTime: 'string',
        };
    }
}
exports.DescribeDBInstancePerformanceResponseBody = DescribeDBInstancePerformanceResponseBody;
class DescribeDBInstancePerformanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstancePerformanceResponseBody,
        };
    }
}
exports.DescribeDBInstancePerformanceResponse = DescribeDBInstancePerformanceResponse;
class DescribeDBInstancePromoteActivityRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliUid: 'AliUid',
            dbInstanceName: 'DbInstanceName',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            aliUid: 'string',
            dbInstanceName: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDBInstancePromoteActivityRequest = DescribeDBInstancePromoteActivityRequest;
class DescribeDBInstancePromoteActivityResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliUid: 'AliUid',
            bid: 'Bid',
            DBInstanceId: 'DBInstanceId',
            DBInstanceName: 'DBInstanceName',
            DBType: 'DBType',
            isActivity: 'IsActivity',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            aliUid: 'string',
            bid: 'string',
            DBInstanceId: 'string',
            DBInstanceName: 'string',
            DBType: 'string',
            isActivity: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeDBInstancePromoteActivityResponseBody = DescribeDBInstancePromoteActivityResponseBody;
class DescribeDBInstancePromoteActivityResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstancePromoteActivityResponseBody,
        };
    }
}
exports.DescribeDBInstancePromoteActivityResponse = DescribeDBInstancePromoteActivityResponse;
class DescribeDBInstanceProxyConfigurationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDBInstanceProxyConfigurationRequest = DescribeDBInstanceProxyConfigurationRequest;
class DescribeDBInstanceProxyConfigurationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attacksProtectionConfiguration: 'AttacksProtectionConfiguration',
            persistentConnectionsConfiguration: 'PersistentConnectionsConfiguration',
            requestId: 'RequestId',
            transparentSwitchConfiguration: 'TransparentSwitchConfiguration',
        };
    }
    static types() {
        return {
            attacksProtectionConfiguration: 'string',
            persistentConnectionsConfiguration: 'string',
            requestId: 'string',
            transparentSwitchConfiguration: 'string',
        };
    }
}
exports.DescribeDBInstanceProxyConfigurationResponseBody = DescribeDBInstanceProxyConfigurationResponseBody;
class DescribeDBInstanceProxyConfigurationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceProxyConfigurationResponseBody,
        };
    }
}
exports.DescribeDBInstanceProxyConfigurationResponse = DescribeDBInstanceProxyConfigurationResponse;
class DescribeDBInstanceSSLRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDBInstanceSSLRequest = DescribeDBInstanceSSLRequest;
class DescribeDBInstanceSSLResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ACL: 'ACL',
            CAType: 'CAType',
            clientCACert: 'ClientCACert',
            clientCACertExpireTime: 'ClientCACertExpireTime',
            clientCertRevocationList: 'ClientCertRevocationList',
            connectionString: 'ConnectionString',
            lastModifyStatus: 'LastModifyStatus',
            modifyStatusReason: 'ModifyStatusReason',
            replicationACL: 'ReplicationACL',
            requestId: 'RequestId',
            requireUpdate: 'RequireUpdate',
            requireUpdateItem: 'RequireUpdateItem',
            requireUpdateReason: 'RequireUpdateReason',
            SSLCreateTime: 'SSLCreateTime',
            SSLEnabled: 'SSLEnabled',
            SSLExpireTime: 'SSLExpireTime',
            serverCAUrl: 'ServerCAUrl',
            serverCert: 'ServerCert',
            serverKey: 'ServerKey',
        };
    }
    static types() {
        return {
            ACL: 'string',
            CAType: 'string',
            clientCACert: 'string',
            clientCACertExpireTime: 'string',
            clientCertRevocationList: 'string',
            connectionString: 'string',
            lastModifyStatus: 'string',
            modifyStatusReason: 'string',
            replicationACL: 'string',
            requestId: 'string',
            requireUpdate: 'string',
            requireUpdateItem: 'string',
            requireUpdateReason: 'string',
            SSLCreateTime: 'string',
            SSLEnabled: 'string',
            SSLExpireTime: 'string',
            serverCAUrl: 'string',
            serverCert: 'string',
            serverKey: 'string',
        };
    }
}
exports.DescribeDBInstanceSSLResponseBody = DescribeDBInstanceSSLResponseBody;
class DescribeDBInstanceSSLResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceSSLResponseBody,
        };
    }
}
exports.DescribeDBInstanceSSLResponse = DescribeDBInstanceSSLResponse;
class DescribeDBInstanceTDERequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDBInstanceTDERequest = DescribeDBInstanceTDERequest;
class DescribeDBInstanceTDEResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            databases: 'Databases',
            requestId: 'RequestId',
            TDEMode: 'TDEMode',
            TDEStatus: 'TDEStatus',
        };
    }
    static types() {
        return {
            databases: DescribeDBInstanceTDEResponseBodyDatabases,
            requestId: 'string',
            TDEMode: 'string',
            TDEStatus: 'string',
        };
    }
}
exports.DescribeDBInstanceTDEResponseBody = DescribeDBInstanceTDEResponseBody;
class DescribeDBInstanceTDEResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstanceTDEResponseBody,
        };
    }
}
exports.DescribeDBInstanceTDEResponse = DescribeDBInstanceTDEResponse;
class DescribeDBInstancesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'Category',
            clientToken: 'ClientToken',
            connectionMode: 'ConnectionMode',
            connectionString: 'ConnectionString',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStatus: 'DBInstanceStatus',
            DBInstanceType: 'DBInstanceType',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            dedicatedHostId: 'DedicatedHostId',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            expired: 'Expired',
            filter: 'Filter',
            instanceLevel: 'InstanceLevel',
            instanceNetworkType: 'InstanceNetworkType',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            payType: 'PayType',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            searchKey: 'SearchKey',
            tags: 'Tags',
            vSwitchId: 'VSwitchId',
            vpcId: 'VpcId',
            zoneId: 'ZoneId',
            proxyId: 'proxyId',
        };
    }
    static types() {
        return {
            category: 'string',
            clientToken: 'string',
            connectionMode: 'string',
            connectionString: 'string',
            DBInstanceClass: 'string',
            DBInstanceId: 'string',
            DBInstanceStatus: 'string',
            DBInstanceType: 'string',
            dedicatedHostGroupId: 'string',
            dedicatedHostId: 'string',
            engine: 'string',
            engineVersion: 'string',
            expired: 'string',
            filter: 'string',
            instanceLevel: 'number',
            instanceNetworkType: 'string',
            maxResults: 'number',
            nextToken: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            payType: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            searchKey: 'string',
            tags: 'string',
            vSwitchId: 'string',
            vpcId: 'string',
            zoneId: 'string',
            proxyId: 'string',
        };
    }
}
exports.DescribeDBInstancesRequest = DescribeDBInstancesRequest;
class DescribeDBInstancesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            nextToken: 'NextToken',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescribeDBInstancesResponseBodyItems,
            nextToken: 'string',
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeDBInstancesResponseBody = DescribeDBInstancesResponseBody;
class DescribeDBInstancesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstancesResponseBody,
        };
    }
}
exports.DescribeDBInstancesResponse = DescribeDBInstancesResponse;
class DescribeDBInstancesAsCsvRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cachedAsync: 'CachedAsync',
            DBInstanceId: 'DBInstanceId',
            exportKey: 'ExportKey',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            cachedAsync: 'boolean',
            DBInstanceId: 'string',
            exportKey: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDBInstancesAsCsvRequest = DescribeDBInstancesAsCsvRequest;
class DescribeDBInstancesAsCsvResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            items: DescribeDBInstancesAsCsvResponseBodyItems,
            requestId: 'string',
        };
    }
}
exports.DescribeDBInstancesAsCsvResponseBody = DescribeDBInstancesAsCsvResponseBody;
class DescribeDBInstancesAsCsvResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstancesAsCsvResponseBody,
        };
    }
}
exports.DescribeDBInstancesAsCsvResponse = DescribeDBInstancesAsCsvResponse;
class DescribeDBInstancesByExpireTimeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expirePeriod: 'ExpirePeriod',
            expired: 'Expired',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            tags: 'Tags',
            proxyId: 'proxyId',
        };
    }
    static types() {
        return {
            expirePeriod: 'number',
            expired: 'boolean',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            tags: 'string',
            proxyId: 'string',
        };
    }
}
exports.DescribeDBInstancesByExpireTimeRequest = DescribeDBInstancesByExpireTimeRequest;
class DescribeDBInstancesByExpireTimeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescribeDBInstancesByExpireTimeResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeDBInstancesByExpireTimeResponseBody = DescribeDBInstancesByExpireTimeResponseBody;
class DescribeDBInstancesByExpireTimeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstancesByExpireTimeResponseBody,
        };
    }
}
exports.DescribeDBInstancesByExpireTimeResponse = DescribeDBInstancesByExpireTimeResponse;
class DescribeDBInstancesByPerformanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tag: 'Tag',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            sortKey: 'SortKey',
            sortMethod: 'SortMethod',
            tags: 'Tags',
            proxyId: 'proxyId',
        };
    }
    static types() {
        return {
            tag: { 'type': 'array', 'itemType': DescribeDBInstancesByPerformanceRequestTag },
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            sortKey: 'string',
            sortMethod: 'string',
            tags: 'string',
            proxyId: 'string',
        };
    }
}
exports.DescribeDBInstancesByPerformanceRequest = DescribeDBInstancesByPerformanceRequest;
class DescribeDBInstancesByPerformanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescribeDBInstancesByPerformanceResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeDBInstancesByPerformanceResponseBody = DescribeDBInstancesByPerformanceResponseBody;
class DescribeDBInstancesByPerformanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstancesByPerformanceResponseBody,
        };
    }
}
exports.DescribeDBInstancesByPerformanceResponse = DescribeDBInstancesByPerformanceResponse;
class DescribeDBInstancesForCloneRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            connectionMode: 'ConnectionMode',
            currentInstanceId: 'CurrentInstanceId',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStatus: 'DBInstanceStatus',
            DBInstanceType: 'DBInstanceType',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            expired: 'Expired',
            instanceNetworkType: 'InstanceNetworkType',
            nodeType: 'NodeType',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            payType: 'PayType',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            searchKey: 'SearchKey',
            vSwitchId: 'VSwitchId',
            vpcId: 'VpcId',
            zoneId: 'ZoneId',
            proxyId: 'proxyId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            connectionMode: 'string',
            currentInstanceId: 'string',
            DBInstanceClass: 'string',
            DBInstanceId: 'string',
            DBInstanceStatus: 'string',
            DBInstanceType: 'string',
            engine: 'string',
            engineVersion: 'string',
            expired: 'string',
            instanceNetworkType: 'string',
            nodeType: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            payType: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            searchKey: 'string',
            vSwitchId: 'string',
            vpcId: 'string',
            zoneId: 'string',
            proxyId: 'string',
        };
    }
}
exports.DescribeDBInstancesForCloneRequest = DescribeDBInstancesForCloneRequest;
class DescribeDBInstancesForCloneResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescribeDBInstancesForCloneResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeDBInstancesForCloneResponseBody = DescribeDBInstancesForCloneResponseBody;
class DescribeDBInstancesForCloneResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBInstancesForCloneResponseBody,
        };
    }
}
exports.DescribeDBInstancesForCloneResponse = DescribeDBInstancesForCloneResponse;
class DescribeDBMiniEngineVersionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            minorVersionTag: 'MinorVersionTag',
            nodeType: 'NodeType',
            regionId: 'RegionId',
            resourceOwnerId: 'ResourceOwnerId',
            storageType: 'StorageType',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            dedicatedHostGroupId: 'string',
            engine: 'string',
            engineVersion: 'string',
            minorVersionTag: 'string',
            nodeType: 'string',
            regionId: 'string',
            resourceOwnerId: 'number',
            storageType: 'string',
        };
    }
}
exports.DescribeDBMiniEngineVersionsRequest = DescribeDBMiniEngineVersionsRequest;
class DescribeDBMiniEngineVersionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            maxRecordsPerPage: 'MaxRecordsPerPage',
            minorVersionItems: 'MinorVersionItems',
            pageNumbers: 'PageNumbers',
            requestId: 'RequestId',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            maxRecordsPerPage: 'number',
            minorVersionItems: { 'type': 'array', 'itemType': DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems },
            pageNumbers: 'number',
            requestId: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeDBMiniEngineVersionsResponseBody = DescribeDBMiniEngineVersionsResponseBody;
class DescribeDBMiniEngineVersionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBMiniEngineVersionsResponseBody,
        };
    }
}
exports.DescribeDBMiniEngineVersionsResponse = DescribeDBMiniEngineVersionsResponse;
class DescribeDBProxyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DBProxyEngineType: 'DBProxyEngineType',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DBProxyEngineType: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDBProxyRequest = DescribeDBProxyRequest;
class DescribeDBProxyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBProxyAVZones: 'DBProxyAVZones',
            DBProxyConnectStringItems: 'DBProxyConnectStringItems',
            DBProxyEngineType: 'DBProxyEngineType',
            DBProxyInstanceCurrentMinorVersion: 'DBProxyInstanceCurrentMinorVersion',
            DBProxyInstanceLatestMinorVersion: 'DBProxyInstanceLatestMinorVersion',
            DBProxyInstanceName: 'DBProxyInstanceName',
            DBProxyInstanceNum: 'DBProxyInstanceNum',
            DBProxyInstanceSize: 'DBProxyInstanceSize',
            DBProxyInstanceStatus: 'DBProxyInstanceStatus',
            DBProxyInstanceType: 'DBProxyInstanceType',
            DBProxyPersistentConnectionSupport: 'DBProxyPersistentConnectionSupport',
            DBProxyServiceStatus: 'DBProxyServiceStatus',
            dbProxyEndpointItems: 'DbProxyEndpointItems',
            requestId: 'RequestId',
            resourceGroupId: 'ResourceGroupId',
        };
    }
    static types() {
        return {
            DBProxyAVZones: DescribeDBProxyResponseBodyDBProxyAVZones,
            DBProxyConnectStringItems: DescribeDBProxyResponseBodyDBProxyConnectStringItems,
            DBProxyEngineType: 'string',
            DBProxyInstanceCurrentMinorVersion: 'string',
            DBProxyInstanceLatestMinorVersion: 'string',
            DBProxyInstanceName: 'string',
            DBProxyInstanceNum: 'number',
            DBProxyInstanceSize: 'string',
            DBProxyInstanceStatus: 'string',
            DBProxyInstanceType: 'string',
            DBProxyPersistentConnectionSupport: 'string',
            DBProxyServiceStatus: 'string',
            dbProxyEndpointItems: DescribeDBProxyResponseBodyDbProxyEndpointItems,
            requestId: 'string',
            resourceGroupId: 'string',
        };
    }
}
exports.DescribeDBProxyResponseBody = DescribeDBProxyResponseBody;
class DescribeDBProxyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBProxyResponseBody,
        };
    }
}
exports.DescribeDBProxyResponse = DescribeDBProxyResponse;
class DescribeDBProxyEndpointRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DBProxyConnectString: 'DBProxyConnectString',
            DBProxyEndpointId: 'DBProxyEndpointId',
            DBProxyEngineType: 'DBProxyEngineType',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DBProxyConnectString: 'string',
            DBProxyEndpointId: 'string',
            DBProxyEngineType: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDBProxyEndpointRequest = DescribeDBProxyEndpointRequest;
class DescribeDBProxyEndpointResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBProxyConnectString: 'DBProxyConnectString',
            DBProxyConnectStringNetType: 'DBProxyConnectStringNetType',
            DBProxyConnectStringPort: 'DBProxyConnectStringPort',
            DBProxyEndpointId: 'DBProxyEndpointId',
            DBProxyEngineType: 'DBProxyEngineType',
            DBProxyFeatures: 'DBProxyFeatures',
            dbProxyEndpointAliases: 'DbProxyEndpointAliases',
            dbProxyEndpointReadWriteMode: 'DbProxyEndpointReadWriteMode',
            endpointConnectItems: 'EndpointConnectItems',
            readOnlyInstanceDistributionType: 'ReadOnlyInstanceDistributionType',
            readOnlyInstanceMaxDelayTime: 'ReadOnlyInstanceMaxDelayTime',
            readOnlyInstanceWeight: 'ReadOnlyInstanceWeight',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBProxyConnectString: 'string',
            DBProxyConnectStringNetType: 'string',
            DBProxyConnectStringPort: 'string',
            DBProxyEndpointId: 'string',
            DBProxyEngineType: 'string',
            DBProxyFeatures: 'string',
            dbProxyEndpointAliases: 'string',
            dbProxyEndpointReadWriteMode: 'string',
            endpointConnectItems: DescribeDBProxyEndpointResponseBodyEndpointConnectItems,
            readOnlyInstanceDistributionType: 'string',
            readOnlyInstanceMaxDelayTime: 'string',
            readOnlyInstanceWeight: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeDBProxyEndpointResponseBody = DescribeDBProxyEndpointResponseBody;
class DescribeDBProxyEndpointResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBProxyEndpointResponseBody,
        };
    }
}
exports.DescribeDBProxyEndpointResponse = DescribeDBProxyEndpointResponse;
class DescribeDBProxyPerformanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DBProxyEngineType: 'DBProxyEngineType',
            DBProxyInstanceType: 'DBProxyInstanceType',
            endTime: 'EndTime',
            metricsName: 'MetricsName',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DBProxyEngineType: 'string',
            DBProxyInstanceType: 'string',
            endTime: 'string',
            metricsName: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
        };
    }
}
exports.DescribeDBProxyPerformanceRequest = DescribeDBProxyPerformanceRequest;
class DescribeDBProxyPerformanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DBProxyEngineType: 'DBProxyEngineType',
            endTime: 'EndTime',
            performanceKeys: 'PerformanceKeys',
            requestId: 'RequestId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DBProxyEngineType: 'string',
            endTime: 'string',
            performanceKeys: DescribeDBProxyPerformanceResponseBodyPerformanceKeys,
            requestId: 'string',
            startTime: 'string',
        };
    }
}
exports.DescribeDBProxyPerformanceResponseBody = DescribeDBProxyPerformanceResponseBody;
class DescribeDBProxyPerformanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDBProxyPerformanceResponseBody,
        };
    }
}
exports.DescribeDBProxyPerformanceResponse = DescribeDBProxyPerformanceResponse;
class DescribeDTCSecurityIpHostsForSQLServerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityToken: 'SecurityToken',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            securityToken: 'string',
        };
    }
}
exports.DescribeDTCSecurityIpHostsForSQLServerRequest = DescribeDTCSecurityIpHostsForSQLServerRequest;
class DescribeDTCSecurityIpHostsForSQLServerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ipHostPairNum: 'IpHostPairNum',
            items: 'Items',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ipHostPairNum: 'string',
            items: DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems,
            requestId: 'string',
        };
    }
}
exports.DescribeDTCSecurityIpHostsForSQLServerResponseBody = DescribeDTCSecurityIpHostsForSQLServerResponseBody;
class DescribeDTCSecurityIpHostsForSQLServerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDTCSecurityIpHostsForSQLServerResponseBody,
        };
    }
}
exports.DescribeDTCSecurityIpHostsForSQLServerResponse = DescribeDTCSecurityIpHostsForSQLServerResponse;
class DescribeDatabasesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            DBStatus: 'DBStatus',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DBName: 'string',
            DBStatus: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDatabasesRequest = DescribeDatabasesRequest;
class DescribeDatabasesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            databases: 'Databases',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            databases: DescribeDatabasesResponseBodyDatabases,
            requestId: 'string',
        };
    }
}
exports.DescribeDatabasesResponseBody = DescribeDatabasesResponseBody;
class DescribeDatabasesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDatabasesResponseBody,
        };
    }
}
exports.DescribeDatabasesResponse = DescribeDatabasesResponse;
class DescribeDedicatedHostGroupsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            imageCategory: 'ImageCategory',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            dedicatedHostGroupId: 'string',
            imageCategory: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeDedicatedHostGroupsRequest = DescribeDedicatedHostGroupsRequest;
class DescribeDedicatedHostGroupsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dedicatedHostGroups: 'DedicatedHostGroups',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            dedicatedHostGroups: DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups,
            requestId: 'string',
        };
    }
}
exports.DescribeDedicatedHostGroupsResponseBody = DescribeDedicatedHostGroupsResponseBody;
class DescribeDedicatedHostGroupsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDedicatedHostGroupsResponseBody,
        };
    }
}
exports.DescribeDedicatedHostGroupsResponse = DescribeDedicatedHostGroupsResponse;
class DescribeDedicatedHostsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            allocationStatus: 'AllocationStatus',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            dedicatedHostId: 'DedicatedHostId',
            hostStatus: 'HostStatus',
            hostType: 'HostType',
            orderId: 'OrderId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            allocationStatus: 'string',
            dedicatedHostGroupId: 'string',
            dedicatedHostId: 'string',
            hostStatus: 'string',
            hostType: 'string',
            orderId: 'number',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            zoneId: 'string',
        };
    }
}
exports.DescribeDedicatedHostsRequest = DescribeDedicatedHostsRequest;
class DescribeDedicatedHostsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            dedicatedHosts: 'DedicatedHosts',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            dedicatedHostGroupId: 'string',
            dedicatedHosts: DescribeDedicatedHostsResponseBodyDedicatedHosts,
            requestId: 'string',
        };
    }
}
exports.DescribeDedicatedHostsResponseBody = DescribeDedicatedHostsResponseBody;
class DescribeDedicatedHostsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDedicatedHostsResponseBody,
        };
    }
}
exports.DescribeDedicatedHostsResponse = DescribeDedicatedHostsResponse;
class DescribeDetachedBackupsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            backupMode: 'BackupMode',
            backupStatus: 'BackupStatus',
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            region: 'Region',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            backupId: 'string',
            backupMode: 'string',
            backupStatus: 'string',
            DBInstanceId: 'string',
            endTime: 'string',
            pageNumber: 'number',
            pageSize: 'number',
            region: 'string',
            resourceGroupId: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
        };
    }
}
exports.DescribeDetachedBackupsRequest = DescribeDetachedBackupsRequest;
class DescribeDetachedBackupsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescribeDetachedBackupsResponseBodyItems,
            pageNumber: 'string',
            pageRecordCount: 'string',
            requestId: 'string',
            totalRecordCount: 'string',
        };
    }
}
exports.DescribeDetachedBackupsResponseBody = DescribeDetachedBackupsResponseBody;
class DescribeDetachedBackupsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDetachedBackupsResponseBody,
        };
    }
}
exports.DescribeDetachedBackupsResponse = DescribeDetachedBackupsResponse;
class DescribeDiagnosticReportListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            resourceGroupId: 'ResourceGroupId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            resourceGroupId: 'string',
        };
    }
}
exports.DescribeDiagnosticReportListRequest = DescribeDiagnosticReportListRequest;
class DescribeDiagnosticReportListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            reportList: 'ReportList',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            reportList: { 'type': 'array', 'itemType': DescribeDiagnosticReportListResponseBodyReportList },
            requestId: 'string',
        };
    }
}
exports.DescribeDiagnosticReportListResponseBody = DescribeDiagnosticReportListResponseBody;
class DescribeDiagnosticReportListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeDiagnosticReportListResponseBody,
        };
    }
}
exports.DescribeDiagnosticReportListResponse = DescribeDiagnosticReportListResponse;
class DescribeErrorLogsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            endTime: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
        };
    }
}
exports.DescribeErrorLogsRequest = DescribeErrorLogsRequest;
class DescribeErrorLogsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescribeErrorLogsResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeErrorLogsResponseBody = DescribeErrorLogsResponseBody;
class DescribeErrorLogsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeErrorLogsResponseBody,
        };
    }
}
exports.DescribeErrorLogsResponse = DescribeErrorLogsResponse;
class DescribeEventsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'EndTime',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            endTime: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
        };
    }
}
exports.DescribeEventsRequest = DescribeEventsRequest;
class DescribeEventsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eventItems: 'EventItems',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            eventItems: DescribeEventsResponseBodyEventItems,
            pageNumber: 'number',
            pageSize: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeEventsResponseBody = DescribeEventsResponseBody;
class DescribeEventsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeEventsResponseBody,
        };
    }
}
exports.DescribeEventsResponse = DescribeEventsResponse;
class DescribeGadInstancesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gadInstanceName: 'GadInstanceName',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
        };
    }
    static types() {
        return {
            gadInstanceName: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
        };
    }
}
exports.DescribeGadInstancesRequest = DescribeGadInstancesRequest;
class DescribeGadInstancesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gadInstances: 'GadInstances',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            gadInstances: { 'type': 'array', 'itemType': DescribeGadInstancesResponseBodyGadInstances },
            requestId: 'string',
        };
    }
}
exports.DescribeGadInstancesResponseBody = DescribeGadInstancesResponseBody;
class DescribeGadInstancesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeGadInstancesResponseBody,
        };
    }
}
exports.DescribeGadInstancesResponse = DescribeGadInstancesResponse;
class DescribeHADiagnoseConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeHADiagnoseConfigRequest = DescribeHADiagnoseConfigRequest;
class DescribeHADiagnoseConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
            tcpConnectionType: 'TcpConnectionType',
        };
    }
    static types() {
        return {
            requestId: 'string',
            tcpConnectionType: 'string',
        };
    }
}
exports.DescribeHADiagnoseConfigResponseBody = DescribeHADiagnoseConfigResponseBody;
class DescribeHADiagnoseConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeHADiagnoseConfigResponseBody,
        };
    }
}
exports.DescribeHADiagnoseConfigResponse = DescribeHADiagnoseConfigResponse;
class DescribeHASwitchConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeHASwitchConfigRequest = DescribeHASwitchConfigRequest;
class DescribeHASwitchConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            HAConfig: 'HAConfig',
            manualHATime: 'ManualHATime',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            HAConfig: 'string',
            manualHATime: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeHASwitchConfigResponseBody = DescribeHASwitchConfigResponseBody;
class DescribeHASwitchConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeHASwitchConfigResponseBody,
        };
    }
}
exports.DescribeHASwitchConfigResponse = DescribeHASwitchConfigResponse;
class DescribeHistoryEventsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            archiveStatus: 'ArchiveStatus',
            eventCategory: 'EventCategory',
            eventId: 'EventId',
            eventLevel: 'EventLevel',
            eventStatus: 'EventStatus',
            eventType: 'EventType',
            fromStartTime: 'FromStartTime',
            instanceId: 'InstanceId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceType: 'ResourceType',
            securityToken: 'SecurityToken',
            taskId: 'TaskId',
            toStartTime: 'ToStartTime',
        };
    }
    static types() {
        return {
            archiveStatus: 'string',
            eventCategory: 'string',
            eventId: 'string',
            eventLevel: 'string',
            eventStatus: 'string',
            eventType: 'string',
            fromStartTime: 'string',
            instanceId: 'string',
            pageNumber: 'number',
            pageSize: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceType: 'string',
            securityToken: 'string',
            taskId: 'string',
            toStartTime: 'string',
        };
    }
}
exports.DescribeHistoryEventsRequest = DescribeHistoryEventsRequest;
class DescribeHistoryEventsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': DescribeHistoryEventsResponseBodyItems },
            pageNumber: 'number',
            pageSize: 'number',
            requestId: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeHistoryEventsResponseBody = DescribeHistoryEventsResponseBody;
class DescribeHistoryEventsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeHistoryEventsResponseBody,
        };
    }
}
exports.DescribeHistoryEventsResponse = DescribeHistoryEventsResponse;
class DescribeHistoryEventsStatRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            archiveStatus: 'ArchiveStatus',
            fromStartTime: 'FromStartTime',
            regionId: 'RegionId',
            securityToken: 'SecurityToken',
            toStartTime: 'ToStartTime',
        };
    }
    static types() {
        return {
            archiveStatus: 'string',
            fromStartTime: 'string',
            regionId: 'string',
            securityToken: 'string',
            toStartTime: 'string',
        };
    }
}
exports.DescribeHistoryEventsStatRequest = DescribeHistoryEventsStatRequest;
class DescribeHistoryEventsStatResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': DescribeHistoryEventsStatResponseBodyItems },
            requestId: 'string',
        };
    }
}
exports.DescribeHistoryEventsStatResponseBody = DescribeHistoryEventsStatResponseBody;
class DescribeHistoryEventsStatResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeHistoryEventsStatResponseBody,
        };
    }
}
exports.DescribeHistoryEventsStatResponse = DescribeHistoryEventsStatResponse;
class DescribeHistoryTasksRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fromExecTime: 'FromExecTime',
            fromStartTime: 'FromStartTime',
            instanceId: 'InstanceId',
            instanceType: 'InstanceType',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityToken: 'SecurityToken',
            status: 'Status',
            taskId: 'TaskId',
            taskType: 'TaskType',
            toExecTime: 'ToExecTime',
            toStartTime: 'ToStartTime',
        };
    }
    static types() {
        return {
            fromExecTime: 'number',
            fromStartTime: 'string',
            instanceId: 'string',
            instanceType: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'number',
            resourceOwnerId: 'number',
            securityToken: 'string',
            status: 'string',
            taskId: 'string',
            taskType: 'string',
            toExecTime: 'number',
            toStartTime: 'string',
        };
    }
}
exports.DescribeHistoryTasksRequest = DescribeHistoryTasksRequest;
class DescribeHistoryTasksResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': DescribeHistoryTasksResponseBodyItems },
            pageNumber: 'number',
            pageSize: 'number',
            requestId: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeHistoryTasksResponseBody = DescribeHistoryTasksResponseBody;
class DescribeHistoryTasksResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeHistoryTasksResponseBody,
        };
    }
}
exports.DescribeHistoryTasksResponse = DescribeHistoryTasksResponse;
class DescribeHistoryTasksStatRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fromExecTime: 'FromExecTime',
            fromStartTime: 'FromStartTime',
            instanceId: 'InstanceId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityToken: 'SecurityToken',
            status: 'Status',
            taskId: 'TaskId',
            taskType: 'TaskType',
            toExecTime: 'ToExecTime',
            toStartTime: 'ToStartTime',
        };
    }
    static types() {
        return {
            fromExecTime: 'number',
            fromStartTime: 'string',
            instanceId: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'number',
            resourceOwnerId: 'number',
            securityToken: 'string',
            status: 'string',
            taskId: 'string',
            taskType: 'string',
            toExecTime: 'number',
            toStartTime: 'string',
        };
    }
}
exports.DescribeHistoryTasksStatRequest = DescribeHistoryTasksStatRequest;
class DescribeHistoryTasksStatResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': DescribeHistoryTasksStatResponseBodyItems },
            requestId: 'string',
        };
    }
}
exports.DescribeHistoryTasksStatResponseBody = DescribeHistoryTasksStatResponseBody;
class DescribeHistoryTasksStatResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeHistoryTasksStatResponseBody,
        };
    }
}
exports.DescribeHistoryTasksStatResponse = DescribeHistoryTasksStatResponse;
class DescribeHostGroupElasticStrategyParametersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dedicatedHostGroupName: 'DedicatedHostGroupName',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            dedicatedHostGroupName: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeHostGroupElasticStrategyParametersRequest = DescribeHostGroupElasticStrategyParametersRequest;
class DescribeHostGroupElasticStrategyParametersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cpuShar: 'CpuShar',
            cpuZoom: 'CpuZoom',
            iopsZoom: 'IopsZoom',
            maxConnZoom: 'MaxConnZoom',
            memoryZoom: 'MemoryZoom',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            cpuShar: 'number',
            cpuZoom: 'number',
            iopsZoom: 'number',
            maxConnZoom: 'number',
            memoryZoom: 'number',
            requestId: 'string',
        };
    }
}
exports.DescribeHostGroupElasticStrategyParametersResponseBody = DescribeHostGroupElasticStrategyParametersResponseBody;
class DescribeHostGroupElasticStrategyParametersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeHostGroupElasticStrategyParametersResponseBody,
        };
    }
}
exports.DescribeHostGroupElasticStrategyParametersResponse = DescribeHostGroupElasticStrategyParametersResponse;
class DescribeHostWebShellRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountName: 'AccountName',
            accountPassword: 'AccountPassword',
            DBInstanceId: 'DBInstanceId',
            hostName: 'HostName',
            ownerId: 'OwnerId',
            regionID: 'RegionID',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            accountName: 'string',
            accountPassword: 'string',
            DBInstanceId: 'string',
            hostName: 'string',
            ownerId: 'number',
            regionID: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeHostWebShellRequest = DescribeHostWebShellRequest;
class DescribeHostWebShellResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            loginUrl: 'LoginUrl',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            loginUrl: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeHostWebShellResponseBody = DescribeHostWebShellResponseBody;
class DescribeHostWebShellResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeHostWebShellResponseBody,
        };
    }
}
exports.DescribeHostWebShellResponse = DescribeHostWebShellResponse;
class DescribeInstanceAutoRenewalAttributeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            proxyId: 'proxyId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            proxyId: 'string',
        };
    }
}
exports.DescribeInstanceAutoRenewalAttributeRequest = DescribeInstanceAutoRenewalAttributeRequest;
class DescribeInstanceAutoRenewalAttributeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescribeInstanceAutoRenewalAttributeResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeInstanceAutoRenewalAttributeResponseBody = DescribeInstanceAutoRenewalAttributeResponseBody;
class DescribeInstanceAutoRenewalAttributeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeInstanceAutoRenewalAttributeResponseBody,
        };
    }
}
exports.DescribeInstanceAutoRenewalAttributeResponse = DescribeInstanceAutoRenewalAttributeResponse;
class DescribeInstanceCrossBackupPolicyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeInstanceCrossBackupPolicyRequest = DescribeInstanceCrossBackupPolicyRequest;
class DescribeInstanceCrossBackupPolicyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupEnabled: 'BackupEnabled',
            backupEnabledTime: 'BackupEnabledTime',
            crossBackupRegion: 'CrossBackupRegion',
            crossBackupType: 'CrossBackupType',
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStatus: 'DBInstanceStatus',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            lockMode: 'LockMode',
            logBackupEnabled: 'LogBackupEnabled',
            logBackupEnabledTime: 'LogBackupEnabledTime',
            regionId: 'RegionId',
            requestId: 'RequestId',
            retentType: 'RetentType',
            retention: 'Retention',
        };
    }
    static types() {
        return {
            backupEnabled: 'string',
            backupEnabledTime: 'string',
            crossBackupRegion: 'string',
            crossBackupType: 'string',
            DBInstanceDescription: 'string',
            DBInstanceId: 'string',
            DBInstanceStatus: 'string',
            engine: 'string',
            engineVersion: 'string',
            lockMode: 'string',
            logBackupEnabled: 'string',
            logBackupEnabledTime: 'string',
            regionId: 'string',
            requestId: 'string',
            retentType: 'number',
            retention: 'number',
        };
    }
}
exports.DescribeInstanceCrossBackupPolicyResponseBody = DescribeInstanceCrossBackupPolicyResponseBody;
class DescribeInstanceCrossBackupPolicyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeInstanceCrossBackupPolicyResponseBody,
        };
    }
}
exports.DescribeInstanceCrossBackupPolicyResponse = DescribeInstanceCrossBackupPolicyResponse;
class DescribeInstanceKeywordsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            key: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeInstanceKeywordsRequest = DescribeInstanceKeywordsRequest;
class DescribeInstanceKeywordsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            requestId: 'RequestId',
            words: 'Words',
        };
    }
    static types() {
        return {
            key: 'string',
            requestId: 'string',
            words: DescribeInstanceKeywordsResponseBodyWords,
        };
    }
}
exports.DescribeInstanceKeywordsResponseBody = DescribeInstanceKeywordsResponseBody;
class DescribeInstanceKeywordsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeInstanceKeywordsResponseBody,
        };
    }
}
exports.DescribeInstanceKeywordsResponse = DescribeInstanceKeywordsResponse;
class DescribeInstanceLinkedWhitelistTemplateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            insName: 'InsName',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            insName: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeInstanceLinkedWhitelistTemplateRequest = DescribeInstanceLinkedWhitelistTemplateRequest;
class DescribeInstanceLinkedWhitelistTemplateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            httpStatusCode: 'HttpStatusCode',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeInstanceLinkedWhitelistTemplateResponseBodyData,
            httpStatusCode: 'number',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeInstanceLinkedWhitelistTemplateResponseBody = DescribeInstanceLinkedWhitelistTemplateResponseBody;
class DescribeInstanceLinkedWhitelistTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeInstanceLinkedWhitelistTemplateResponseBody,
        };
    }
}
exports.DescribeInstanceLinkedWhitelistTemplateResponse = DescribeInstanceLinkedWhitelistTemplateResponse;
class DescribeLocalAvailableRecoveryTimeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            region: 'Region',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            region: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeLocalAvailableRecoveryTimeRequest = DescribeLocalAvailableRecoveryTimeRequest;
class DescribeLocalAvailableRecoveryTimeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            recoveryBeginTime: 'RecoveryBeginTime',
            recoveryEndTime: 'RecoveryEndTime',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            recoveryBeginTime: 'string',
            recoveryEndTime: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeLocalAvailableRecoveryTimeResponseBody = DescribeLocalAvailableRecoveryTimeResponseBody;
class DescribeLocalAvailableRecoveryTimeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeLocalAvailableRecoveryTimeResponseBody,
        };
    }
}
exports.DescribeLocalAvailableRecoveryTimeResponse = DescribeLocalAvailableRecoveryTimeResponse;
class DescribeLogBackupFilesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            endTime: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
        };
    }
}
exports.DescribeLogBackupFilesRequest = DescribeLogBackupFilesRequest;
class DescribeLogBackupFilesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalFileSize: 'TotalFileSize',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescribeLogBackupFilesResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalFileSize: 'number',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeLogBackupFilesResponseBody = DescribeLogBackupFilesResponseBody;
class DescribeLogBackupFilesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeLogBackupFilesResponseBody,
        };
    }
}
exports.DescribeLogBackupFilesResponse = DescribeLogBackupFilesResponse;
class DescribeMarketingActivityRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliUid: 'AliUid',
            bid: 'Bid',
            clientToken: 'ClientToken',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            upgradeCode: 'UpgradeCode',
        };
    }
    static types() {
        return {
            aliUid: 'number',
            bid: 'string',
            clientToken: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            upgradeCode: 'string',
        };
    }
}
exports.DescribeMarketingActivityRequest = DescribeMarketingActivityRequest;
class DescribeMarketingActivityResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliUid: 'AliUid',
            bid: 'Bid',
            items: 'Items',
            regionId: 'RegionId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            aliUid: 'number',
            bid: 'string',
            items: { 'type': 'array', 'itemType': DescribeMarketingActivityResponseBodyItems },
            regionId: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeMarketingActivityResponseBody = DescribeMarketingActivityResponseBody;
class DescribeMarketingActivityResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeMarketingActivityResponseBody,
        };
    }
}
exports.DescribeMarketingActivityResponse = DescribeMarketingActivityResponse;
class DescribeMetaListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupSetID: 'BackupSetID',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            getDbName: 'GetDbName',
            ownerId: 'OwnerId',
            pageIndex: 'PageIndex',
            pageSize: 'PageSize',
            pattern: 'Pattern',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            restoreTime: 'RestoreTime',
            restoreType: 'RestoreType',
        };
    }
    static types() {
        return {
            backupSetID: 'number',
            clientToken: 'string',
            DBInstanceId: 'string',
            getDbName: 'string',
            ownerId: 'number',
            pageIndex: 'number',
            pageSize: 'number',
            pattern: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            restoreTime: 'string',
            restoreType: 'string',
        };
    }
}
exports.DescribeMetaListRequest = DescribeMetaListRequest;
class DescribeMetaListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalPageCount: 'TotalPageCount',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            items: DescribeMetaListResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalPageCount: 'number',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeMetaListResponseBody = DescribeMetaListResponseBody;
class DescribeMetaListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeMetaListResponseBody,
        };
    }
}
exports.DescribeMetaListResponse = DescribeMetaListResponse;
class DescribeMigrateTaskByIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            migrateTaskId: 'MigrateTaskId',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            migrateTaskId: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeMigrateTaskByIdRequest = DescribeMigrateTaskByIdRequest;
class DescribeMigrateTaskByIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupMode: 'BackupMode',
            createTime: 'CreateTime',
            DBInstanceName: 'DBInstanceName',
            DBName: 'DBName',
            description: 'Description',
            endTime: 'EndTime',
            isDBReplaced: 'IsDBReplaced',
            migrateTaskId: 'MigrateTaskId',
            requestId: 'RequestId',
            status: 'Status',
        };
    }
    static types() {
        return {
            backupMode: 'string',
            createTime: 'string',
            DBInstanceName: 'string',
            DBName: 'string',
            description: 'string',
            endTime: 'string',
            isDBReplaced: 'string',
            migrateTaskId: 'string',
            requestId: 'string',
            status: 'string',
        };
    }
}
exports.DescribeMigrateTaskByIdResponseBody = DescribeMigrateTaskByIdResponseBody;
class DescribeMigrateTaskByIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeMigrateTaskByIdResponseBody,
        };
    }
}
exports.DescribeMigrateTaskByIdResponse = DescribeMigrateTaskByIdResponse;
class DescribeMigrateTasksRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            endTime: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
        };
    }
}
exports.DescribeMigrateTasksRequest = DescribeMigrateTasksRequest;
class DescribeMigrateTasksResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            items: DescribeMigrateTasksResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeMigrateTasksResponseBody = DescribeMigrateTasksResponseBody;
class DescribeMigrateTasksResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeMigrateTasksResponseBody,
        };
    }
}
exports.DescribeMigrateTasksResponse = DescribeMigrateTasksResponse;
class DescribeModifyPGHbaConfigLogRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            endTime: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
        };
    }
}
exports.DescribeModifyPGHbaConfigLogRequest = DescribeModifyPGHbaConfigLogRequest;
class DescribeModifyPGHbaConfigLogResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            hbaLogItems: 'HbaLogItems',
            logItemCount: 'LogItemCount',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            hbaLogItems: DescribeModifyPGHbaConfigLogResponseBodyHbaLogItems,
            logItemCount: 'number',
            requestId: 'string',
        };
    }
}
exports.DescribeModifyPGHbaConfigLogResponseBody = DescribeModifyPGHbaConfigLogResponseBody;
class DescribeModifyPGHbaConfigLogResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeModifyPGHbaConfigLogResponseBody,
        };
    }
}
exports.DescribeModifyPGHbaConfigLogResponse = DescribeModifyPGHbaConfigLogResponse;
class DescribeModifyParameterLogRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            endTime: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
        };
    }
}
exports.DescribeModifyParameterLogRequest = DescribeModifyParameterLogRequest;
class DescribeModifyParameterLogResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            engine: 'string',
            engineVersion: 'string',
            items: DescribeModifyParameterLogResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeModifyParameterLogResponseBody = DescribeModifyParameterLogResponseBody;
class DescribeModifyParameterLogResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeModifyParameterLogResponseBody,
        };
    }
}
exports.DescribeModifyParameterLogResponse = DescribeModifyParameterLogResponse;
class DescribeOssDownloadsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            migrateTaskId: 'MigrateTaskId',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            migrateTaskId: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeOssDownloadsRequest = DescribeOssDownloadsRequest;
class DescribeOssDownloadsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            items: 'Items',
            migrateTaskId: 'MigrateTaskId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            items: DescribeOssDownloadsResponseBodyItems,
            migrateTaskId: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeOssDownloadsResponseBody = DescribeOssDownloadsResponseBody;
class DescribeOssDownloadsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeOssDownloadsResponseBody,
        };
    }
}
exports.DescribeOssDownloadsResponse = DescribeOssDownloadsResponse;
class DescribePGHbaConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribePGHbaConfigRequest = DescribePGHbaConfigRequest;
class DescribePGHbaConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            defaultHbaItems: 'DefaultHbaItems',
            hbaModifyTime: 'HbaModifyTime',
            lastModifyStatus: 'LastModifyStatus',
            modifyStatusReason: 'ModifyStatusReason',
            requestId: 'RequestId',
            runningHbaItems: 'RunningHbaItems',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            defaultHbaItems: DescribePGHbaConfigResponseBodyDefaultHbaItems,
            hbaModifyTime: 'string',
            lastModifyStatus: 'string',
            modifyStatusReason: 'string',
            requestId: 'string',
            runningHbaItems: DescribePGHbaConfigResponseBodyRunningHbaItems,
        };
    }
}
exports.DescribePGHbaConfigResponseBody = DescribePGHbaConfigResponseBody;
class DescribePGHbaConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribePGHbaConfigResponseBody,
        };
    }
}
exports.DescribePGHbaConfigResponse = DescribePGHbaConfigResponse;
class DescribeParameterGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
            parameterGroupId: 'ParameterGroupId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            parameterGroupId: 'string',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeParameterGroupRequest = DescribeParameterGroupRequest;
class DescribeParameterGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            paramGroup: 'ParamGroup',
            relatedCustinsInfo: 'RelatedCustinsInfo',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            paramGroup: DescribeParameterGroupResponseBodyParamGroup,
            relatedCustinsInfo: DescribeParameterGroupResponseBodyRelatedCustinsInfo,
            requestId: 'string',
        };
    }
}
exports.DescribeParameterGroupResponseBody = DescribeParameterGroupResponseBody;
class DescribeParameterGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeParameterGroupResponseBody,
        };
    }
}
exports.DescribeParameterGroupResponse = DescribeParameterGroupResponse;
class DescribeParameterGroupsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeParameterGroupsRequest = DescribeParameterGroupsRequest;
class DescribeParameterGroupsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            parameterGroups: 'ParameterGroups',
            requestId: 'RequestId',
            signalForOptimizeParams: 'SignalForOptimizeParams',
        };
    }
    static types() {
        return {
            parameterGroups: DescribeParameterGroupsResponseBodyParameterGroups,
            requestId: 'string',
            signalForOptimizeParams: 'boolean',
        };
    }
}
exports.DescribeParameterGroupsResponseBody = DescribeParameterGroupsResponseBody;
class DescribeParameterGroupsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeParameterGroupsResponseBody,
        };
    }
}
exports.DescribeParameterGroupsResponse = DescribeParameterGroupsResponse;
class DescribeParameterTemplatesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'Category',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            category: 'string',
            clientToken: 'string',
            DBInstanceId: 'string',
            engine: 'string',
            engineVersion: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeParameterTemplatesRequest = DescribeParameterTemplatesRequest;
class DescribeParameterTemplatesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            parameterCount: 'ParameterCount',
            parameters: 'Parameters',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            engine: 'string',
            engineVersion: 'string',
            parameterCount: 'string',
            parameters: DescribeParameterTemplatesResponseBodyParameters,
            requestId: 'string',
        };
    }
}
exports.DescribeParameterTemplatesResponseBody = DescribeParameterTemplatesResponseBody;
class DescribeParameterTemplatesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeParameterTemplatesResponseBody,
        };
    }
}
exports.DescribeParameterTemplatesResponse = DescribeParameterTemplatesResponse;
class DescribeParametersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeParametersRequest = DescribeParametersRequest;
class DescribeParametersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configParameters: 'ConfigParameters',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            paramGroupInfo: 'ParamGroupInfo',
            requestId: 'RequestId',
            runningParameters: 'RunningParameters',
        };
    }
    static types() {
        return {
            configParameters: DescribeParametersResponseBodyConfigParameters,
            engine: 'string',
            engineVersion: 'string',
            paramGroupInfo: DescribeParametersResponseBodyParamGroupInfo,
            requestId: 'string',
            runningParameters: DescribeParametersResponseBodyRunningParameters,
        };
    }
}
exports.DescribeParametersResponseBody = DescribeParametersResponseBody;
class DescribeParametersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeParametersResponseBody,
        };
    }
}
exports.DescribeParametersResponse = DescribeParametersResponse;
class DescribePostgresExtensionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            DBName: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribePostgresExtensionsRequest = DescribePostgresExtensionsRequest;
class DescribePostgresExtensionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            installedExtensions: 'InstalledExtensions',
            overview: 'Overview',
            requestId: 'RequestId',
            uninstalledExtensions: 'UninstalledExtensions',
        };
    }
    static types() {
        return {
            installedExtensions: { 'type': 'array', 'itemType': DescribePostgresExtensionsResponseBodyInstalledExtensions },
            overview: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            requestId: 'string',
            uninstalledExtensions: { 'type': 'array', 'itemType': DescribePostgresExtensionsResponseBodyUninstalledExtensions },
        };
    }
}
exports.DescribePostgresExtensionsResponseBody = DescribePostgresExtensionsResponseBody;
class DescribePostgresExtensionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribePostgresExtensionsResponseBody,
        };
    }
}
exports.DescribePostgresExtensionsResponse = DescribePostgresExtensionsResponse;
class DescribePriceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            commodityCode: 'CommodityCode',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            DBNode: 'DBNode',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            instanceUsedType: 'InstanceUsedType',
            orderType: 'OrderType',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            payType: 'PayType',
            quantity: 'Quantity',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            serverlessConfig: 'ServerlessConfig',
            timeType: 'TimeType',
            usedTime: 'UsedTime',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            commodityCode: 'string',
            DBInstanceClass: 'string',
            DBInstanceId: 'string',
            DBInstanceStorage: 'number',
            DBInstanceStorageType: 'string',
            DBNode: { 'type': 'array', 'itemType': DescribePriceRequestDBNode },
            engine: 'string',
            engineVersion: 'string',
            instanceUsedType: 'number',
            orderType: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            payType: 'string',
            quantity: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            serverlessConfig: DescribePriceRequestServerlessConfig,
            timeType: 'string',
            usedTime: 'number',
            zoneId: 'string',
        };
    }
}
exports.DescribePriceRequest = DescribePriceRequest;
class DescribePriceShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            commodityCode: 'CommodityCode',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            DBNodeShrink: 'DBNode',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            instanceUsedType: 'InstanceUsedType',
            orderType: 'OrderType',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            payType: 'PayType',
            quantity: 'Quantity',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            serverlessConfigShrink: 'ServerlessConfig',
            timeType: 'TimeType',
            usedTime: 'UsedTime',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            commodityCode: 'string',
            DBInstanceClass: 'string',
            DBInstanceId: 'string',
            DBInstanceStorage: 'number',
            DBInstanceStorageType: 'string',
            DBNodeShrink: 'string',
            engine: 'string',
            engineVersion: 'string',
            instanceUsedType: 'number',
            orderType: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            payType: 'string',
            quantity: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            serverlessConfigShrink: 'string',
            timeType: 'string',
            usedTime: 'number',
            zoneId: 'string',
        };
    }
}
exports.DescribePriceShrinkRequest = DescribePriceShrinkRequest;
class DescribePriceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            priceInfo: 'PriceInfo',
            requestId: 'RequestId',
            rules: 'Rules',
            showDiscount: 'ShowDiscount',
            tradeMaxRCUAmount: 'TradeMaxRCUAmount',
            tradeMinRCUAmount: 'TradeMinRCUAmount',
        };
    }
    static types() {
        return {
            priceInfo: DescribePriceResponseBodyPriceInfo,
            requestId: 'string',
            rules: DescribePriceResponseBodyRules,
            showDiscount: 'boolean',
            tradeMaxRCUAmount: 'number',
            tradeMinRCUAmount: 'number',
        };
    }
}
exports.DescribePriceResponseBody = DescribePriceResponseBody;
class DescribePriceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribePriceResponseBody,
        };
    }
}
exports.DescribePriceResponse = DescribePriceResponse;
class DescribeQuickSaleConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commodity: 'Commodity',
            engine: 'Engine',
            regionId: 'RegionId',
        };
    }
    static types() {
        return {
            commodity: 'string',
            engine: 'string',
            regionId: 'string',
        };
    }
}
exports.DescribeQuickSaleConfigRequest = DescribeQuickSaleConfigRequest;
class DescribeQuickSaleConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commodity: 'Commodity',
            items: 'Items',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            commodity: 'string',
            items: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            requestId: 'string',
        };
    }
}
exports.DescribeQuickSaleConfigResponseBody = DescribeQuickSaleConfigResponseBody;
class DescribeQuickSaleConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeQuickSaleConfigResponseBody,
        };
    }
}
exports.DescribeQuickSaleConfigResponse = DescribeQuickSaleConfigResponse;
class DescribeRdsResourceSettingsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
            resourceNiche: 'ResourceNiche',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            resourceNiche: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeRdsResourceSettingsRequest = DescribeRdsResourceSettingsRequest;
class DescribeRdsResourceSettingsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            rdsInstanceResourceSettings: 'RdsInstanceResourceSettings',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            rdsInstanceResourceSettings: DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings,
            requestId: 'string',
        };
    }
}
exports.DescribeRdsResourceSettingsResponseBody = DescribeRdsResourceSettingsResponseBody;
class DescribeRdsResourceSettingsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeRdsResourceSettingsResponseBody,
        };
    }
}
exports.DescribeRdsResourceSettingsResponse = DescribeRdsResourceSettingsResponse;
class DescribeReadDBInstanceDelayRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            readInstanceId: 'ReadInstanceId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityToken: 'SecurityToken',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            readInstanceId: 'string',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            securityToken: 'string',
        };
    }
}
exports.DescribeReadDBInstanceDelayRequest = DescribeReadDBInstanceDelayRequest;
class DescribeReadDBInstanceDelayResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            delayTime: 'DelayTime',
            items: 'Items',
            readDBInstanceId: 'ReadDBInstanceId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            delayTime: 'number',
            items: DescribeReadDBInstanceDelayResponseBodyItems,
            readDBInstanceId: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeReadDBInstanceDelayResponseBody = DescribeReadDBInstanceDelayResponseBody;
class DescribeReadDBInstanceDelayResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeReadDBInstanceDelayResponseBody,
        };
    }
}
exports.DescribeReadDBInstanceDelayResponse = DescribeReadDBInstanceDelayResponse;
class DescribeRegionInfosRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeRegionInfosRequest = DescribeRegionInfosRequest;
class DescribeRegionInfosResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            regions: 'Regions',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            regions: DescribeRegionInfosResponseBodyRegions,
            requestId: 'string',
        };
    }
}
exports.DescribeRegionInfosResponseBody = DescribeRegionInfosResponseBody;
class DescribeRegionInfosResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeRegionInfosResponseBody,
        };
    }
}
exports.DescribeRegionInfosResponse = DescribeRegionInfosResponse;
class DescribeRegionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            acceptLanguage: 'AcceptLanguage',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            acceptLanguage: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeRegionsRequest = DescribeRegionsRequest;
class DescribeRegionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            regions: 'Regions',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            regions: DescribeRegionsResponseBodyRegions,
            requestId: 'string',
        };
    }
}
exports.DescribeRegionsResponseBody = DescribeRegionsResponseBody;
class DescribeRegionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeRegionsResponseBody,
        };
    }
}
exports.DescribeRegionsResponse = DescribeRegionsResponse;
class DescribeRenewalPriceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            businessInfo: 'BusinessInfo',
            clientToken: 'ClientToken',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceId: 'DBInstanceId',
            orderType: 'OrderType',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            payType: 'PayType',
            quantity: 'Quantity',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            timeType: 'TimeType',
            usedTime: 'UsedTime',
        };
    }
    static types() {
        return {
            businessInfo: 'string',
            clientToken: 'string',
            DBInstanceClass: 'string',
            DBInstanceId: 'string',
            orderType: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            payType: 'string',
            quantity: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            timeType: 'string',
            usedTime: 'number',
        };
    }
}
exports.DescribeRenewalPriceRequest = DescribeRenewalPriceRequest;
class DescribeRenewalPriceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            priceInfo: 'PriceInfo',
            requestId: 'RequestId',
            rules: 'Rules',
        };
    }
    static types() {
        return {
            priceInfo: DescribeRenewalPriceResponseBodyPriceInfo,
            requestId: 'string',
            rules: DescribeRenewalPriceResponseBodyRules,
        };
    }
}
exports.DescribeRenewalPriceResponseBody = DescribeRenewalPriceResponseBody;
class DescribeRenewalPriceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeRenewalPriceResponseBody,
        };
    }
}
exports.DescribeRenewalPriceResponse = DescribeRenewalPriceResponse;
class DescribeResourceDetailsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeResourceDetailsRequest = DescribeResourceDetailsRequest;
class DescribeResourceDetailsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupDataSize: 'BackupDataSize',
            backupLogSize: 'BackupLogSize',
            backupSize: 'BackupSize',
            dbInstanceStorage: 'DbInstanceStorage',
            dbProxyInstanceName: 'DbProxyInstanceName',
            diskUsed: 'DiskUsed',
            instanceStorageType: 'InstanceStorageType',
            rdsEcsSecurityGroupRel: 'RdsEcsSecurityGroupRel',
            region: 'Region',
            requestId: 'RequestId',
            resourceGroupId: 'ResourceGroupId',
            securityIPList: 'SecurityIPList',
            vSwitchId: 'VSwitchId',
            vpcId: 'VpcId',
        };
    }
    static types() {
        return {
            backupDataSize: 'number',
            backupLogSize: 'number',
            backupSize: 'number',
            dbInstanceStorage: 'number',
            dbProxyInstanceName: 'string',
            diskUsed: 'number',
            instanceStorageType: 'string',
            rdsEcsSecurityGroupRel: { 'type': 'array', 'itemType': DescribeResourceDetailsResponseBodyRdsEcsSecurityGroupRel },
            region: 'string',
            requestId: 'string',
            resourceGroupId: 'string',
            securityIPList: 'string',
            vSwitchId: 'string',
            vpcId: 'string',
        };
    }
}
exports.DescribeResourceDetailsResponseBody = DescribeResourceDetailsResponseBody;
class DescribeResourceDetailsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeResourceDetailsResponseBody,
        };
    }
}
exports.DescribeResourceDetailsResponse = DescribeResourceDetailsResponse;
class DescribeResourceUsageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeResourceUsageRequest = DescribeResourceUsageRequest;
class DescribeResourceUsageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            archiveBackupSize: 'ArchiveBackupSize',
            backupDataSize: 'BackupDataSize',
            backupLogSize: 'BackupLogSize',
            backupOssDataSize: 'BackupOssDataSize',
            backupOssLogSize: 'BackupOssLogSize',
            backupSize: 'BackupSize',
            coldBackupSize: 'ColdBackupSize',
            DBInstanceId: 'DBInstanceId',
            dataSize: 'DataSize',
            diskUsed: 'DiskUsed',
            engine: 'Engine',
            logSize: 'LogSize',
            paidBackupSize: 'PaidBackupSize',
            requestId: 'RequestId',
            SQLSize: 'SQLSize',
        };
    }
    static types() {
        return {
            archiveBackupSize: 'number',
            backupDataSize: 'number',
            backupLogSize: 'number',
            backupOssDataSize: 'number',
            backupOssLogSize: 'number',
            backupSize: 'number',
            coldBackupSize: 'number',
            DBInstanceId: 'string',
            dataSize: 'number',
            diskUsed: 'number',
            engine: 'string',
            logSize: 'number',
            paidBackupSize: 'number',
            requestId: 'string',
            SQLSize: 'number',
        };
    }
}
exports.DescribeResourceUsageResponseBody = DescribeResourceUsageResponseBody;
class DescribeResourceUsageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeResourceUsageResponseBody,
        };
    }
}
exports.DescribeResourceUsageResponse = DescribeResourceUsageResponse;
class DescribeSQLCollectorPolicyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeSQLCollectorPolicyRequest = DescribeSQLCollectorPolicyRequest;
class DescribeSQLCollectorPolicyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
            SQLCollectorStatus: 'SQLCollectorStatus',
            storagePeriod: 'StoragePeriod',
        };
    }
    static types() {
        return {
            requestId: 'string',
            SQLCollectorStatus: 'string',
            storagePeriod: 'number',
        };
    }
}
exports.DescribeSQLCollectorPolicyResponseBody = DescribeSQLCollectorPolicyResponseBody;
class DescribeSQLCollectorPolicyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSQLCollectorPolicyResponseBody,
        };
    }
}
exports.DescribeSQLCollectorPolicyResponse = DescribeSQLCollectorPolicyResponse;
class DescribeSQLCollectorRetentionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityToken: 'SecurityToken',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            securityToken: 'string',
        };
    }
}
exports.DescribeSQLCollectorRetentionRequest = DescribeSQLCollectorRetentionRequest;
class DescribeSQLCollectorRetentionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configValue: 'ConfigValue',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            configValue: 'string',
            requestId: 'string',
        };
    }
}
exports.DescribeSQLCollectorRetentionResponseBody = DescribeSQLCollectorRetentionResponseBody;
class DescribeSQLCollectorRetentionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSQLCollectorRetentionResponseBody,
        };
    }
}
exports.DescribeSQLCollectorRetentionResponse = DescribeSQLCollectorRetentionResponse;
class DescribeSQLLogFilesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            fileName: 'FileName',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            fileName: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeSQLLogFilesRequest = DescribeSQLLogFilesRequest;
class DescribeSQLLogFilesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescribeSQLLogFilesResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeSQLLogFilesResponseBody = DescribeSQLLogFilesResponseBody;
class DescribeSQLLogFilesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSQLLogFilesResponseBody,
        };
    }
}
exports.DescribeSQLLogFilesResponse = DescribeSQLLogFilesResponse;
class DescribeSQLLogRecordsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            database: 'Database',
            endTime: 'EndTime',
            form: 'Form',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            queryKeywords: 'QueryKeywords',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            SQLId: 'SQLId',
            startTime: 'StartTime',
            user: 'User',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            database: 'string',
            endTime: 'string',
            form: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            queryKeywords: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            SQLId: 'number',
            startTime: 'string',
            user: 'string',
        };
    }
}
exports.DescribeSQLLogRecordsRequest = DescribeSQLLogRecordsRequest;
class DescribeSQLLogRecordsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescribeSQLLogRecordsResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeSQLLogRecordsResponseBody = DescribeSQLLogRecordsResponseBody;
class DescribeSQLLogRecordsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSQLLogRecordsResponseBody,
        };
    }
}
exports.DescribeSQLLogRecordsResponse = DescribeSQLLogRecordsResponse;
class DescribeSQLLogReportListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            endTime: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
        };
    }
}
exports.DescribeSQLLogReportListRequest = DescribeSQLLogReportListRequest;
class DescribeSQLLogReportListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescribeSQLLogReportListResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeSQLLogReportListResponseBody = DescribeSQLLogReportListResponseBody;
class DescribeSQLLogReportListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSQLLogReportListResponseBody,
        };
    }
}
exports.DescribeSQLLogReportListResponse = DescribeSQLLogReportListResponse;
class DescribeSecretsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            acceptLanguage: 'AcceptLanguage',
            clientToken: 'ClientToken',
            dbInstanceId: 'DbInstanceId',
            engine: 'Engine',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            acceptLanguage: 'string',
            clientToken: 'string',
            dbInstanceId: 'string',
            engine: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeSecretsRequest = DescribeSecretsRequest;
class DescribeSecretsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            secrets: 'Secrets',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
            requestId: 'string',
            secrets: { 'type': 'array', 'itemType': DescribeSecretsResponseBodySecrets },
        };
    }
}
exports.DescribeSecretsResponseBody = DescribeSecretsResponseBody;
class DescribeSecretsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSecretsResponseBody,
        };
    }
}
exports.DescribeSecretsResponse = DescribeSecretsResponse;
class DescribeSecurityGroupConfigurationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeSecurityGroupConfigurationRequest = DescribeSecurityGroupConfigurationRequest;
class DescribeSecurityGroupConfigurationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            items: 'Items',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            items: DescribeSecurityGroupConfigurationResponseBodyItems,
            requestId: 'string',
        };
    }
}
exports.DescribeSecurityGroupConfigurationResponseBody = DescribeSecurityGroupConfigurationResponseBody;
class DescribeSecurityGroupConfigurationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSecurityGroupConfigurationResponseBody,
        };
    }
}
exports.DescribeSecurityGroupConfigurationResponse = DescribeSecurityGroupConfigurationResponse;
class DescribeSlotsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DescribeSlotsRequest = DescribeSlotsRequest;
class DescribeSlotsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
            slots: 'Slots',
        };
    }
    static types() {
        return {
            requestId: 'string',
            slots: { 'type': 'array', 'itemType': DescribeSlotsResponseBodySlots },
        };
    }
}
exports.DescribeSlotsResponseBody = DescribeSlotsResponseBody;
class DescribeSlotsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSlotsResponseBody,
        };
    }
}
exports.DescribeSlotsResponse = DescribeSlotsResponse;
class DescribeSlowLogRecordsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            endTime: 'EndTime',
            nodeId: 'NodeId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            SQLHASH: 'SQLHASH',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DBName: 'string',
            endTime: 'string',
            nodeId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            SQLHASH: 'string',
            startTime: 'string',
        };
    }
}
exports.DescribeSlowLogRecordsRequest = DescribeSlowLogRecordsRequest;
class DescribeSlowLogRecordsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            engine: 'Engine',
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            engine: 'string',
            items: DescribeSlowLogRecordsResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeSlowLogRecordsResponseBody = DescribeSlowLogRecordsResponseBody;
class DescribeSlowLogRecordsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSlowLogRecordsResponseBody,
        };
    }
}
exports.DescribeSlowLogRecordsResponse = DescribeSlowLogRecordsResponse;
class DescribeSlowLogsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            endTime: 'EndTime',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            sortKey: 'SortKey',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DBName: 'string',
            endTime: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            sortKey: 'string',
            startTime: 'string',
        };
    }
}
exports.DescribeSlowLogsRequest = DescribeSlowLogsRequest;
class DescribeSlowLogsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            engine: 'Engine',
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            startTime: 'StartTime',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            endTime: 'string',
            engine: 'string',
            items: DescribeSlowLogsResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            startTime: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeSlowLogsResponseBody = DescribeSlowLogsResponseBody;
class DescribeSlowLogsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSlowLogsResponseBody,
        };
    }
}
exports.DescribeSlowLogsResponse = DescribeSlowLogsResponse;
class DescribeSupportOnlineResizeDiskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
        };
    }
}
exports.DescribeSupportOnlineResizeDiskRequest = DescribeSupportOnlineResizeDiskRequest;
class DescribeSupportOnlineResizeDiskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeSupportOnlineResizeDiskResponseBody = DescribeSupportOnlineResizeDiskResponseBody;
class DescribeSupportOnlineResizeDiskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeSupportOnlineResizeDiskResponseBody,
        };
    }
}
exports.DescribeSupportOnlineResizeDiskResponse = DescribeSupportOnlineResizeDiskResponse;
class DescribeTagsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            resourceType: 'ResourceType',
            tags: 'Tags',
            proxyId: 'proxyId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            resourceType: 'string',
            tags: 'string',
            proxyId: 'string',
        };
    }
}
exports.DescribeTagsRequest = DescribeTagsRequest;
class DescribeTagsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            items: DescribeTagsResponseBodyItems,
            requestId: 'string',
        };
    }
}
exports.DescribeTagsResponseBody = DescribeTagsResponseBody;
class DescribeTagsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeTagsResponseBody,
        };
    }
}
exports.DescribeTagsResponse = DescribeTagsResponse;
class DescribeTasksRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            endTime: 'EndTime',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            startTime: 'StartTime',
            status: 'Status',
            taskAction: 'TaskAction',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            endTime: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            startTime: 'string',
            status: 'string',
            taskAction: 'string',
        };
    }
}
exports.DescribeTasksRequest = DescribeTasksRequest;
class DescribeTasksResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: DescribeTasksResponseBodyItems,
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeTasksResponseBody = DescribeTasksResponseBody;
class DescribeTasksResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeTasksResponseBody,
        };
    }
}
exports.DescribeTasksResponse = DescribeTasksResponse;
class DescribeUpgradeMajorVersionPrecheckTaskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            targetMajorVersion: 'TargetMajorVersion',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            targetMajorVersion: 'string',
            taskId: 'number',
        };
    }
}
exports.DescribeUpgradeMajorVersionPrecheckTaskRequest = DescribeUpgradeMajorVersionPrecheckTaskRequest;
class DescribeUpgradeMajorVersionPrecheckTaskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems },
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeUpgradeMajorVersionPrecheckTaskResponseBody = DescribeUpgradeMajorVersionPrecheckTaskResponseBody;
class DescribeUpgradeMajorVersionPrecheckTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeUpgradeMajorVersionPrecheckTaskResponseBody,
        };
    }
}
exports.DescribeUpgradeMajorVersionPrecheckTaskResponse = DescribeUpgradeMajorVersionPrecheckTaskResponse;
class DescribeUpgradeMajorVersionTasksRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            targetMajorVersion: 'TargetMajorVersion',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            targetMajorVersion: 'string',
            taskId: 'number',
        };
    }
}
exports.DescribeUpgradeMajorVersionTasksRequest = DescribeUpgradeMajorVersionTasksRequest;
class DescribeUpgradeMajorVersionTasksResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            pageNumber: 'PageNumber',
            pageRecordCount: 'PageRecordCount',
            requestId: 'RequestId',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': DescribeUpgradeMajorVersionTasksResponseBodyItems },
            pageNumber: 'number',
            pageRecordCount: 'number',
            requestId: 'string',
            totalRecordCount: 'number',
        };
    }
}
exports.DescribeUpgradeMajorVersionTasksResponseBody = DescribeUpgradeMajorVersionTasksResponseBody;
class DescribeUpgradeMajorVersionTasksResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeUpgradeMajorVersionTasksResponseBody,
        };
    }
}
exports.DescribeUpgradeMajorVersionTasksResponse = DescribeUpgradeMajorVersionTasksResponse;
class DescribeVSwitchesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityToken: 'SecurityToken',
            vpcId: 'VpcId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            dedicatedHostGroupId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            securityToken: 'string',
            vpcId: 'string',
            zoneId: 'string',
        };
    }
}
exports.DescribeVSwitchesRequest = DescribeVSwitchesRequest;
class DescribeVSwitchesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            requestId: 'RequestId',
            totalCount: 'TotalCount',
            vSwitchs: 'VSwitchs',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
            requestId: 'string',
            totalCount: 'number',
            vSwitchs: { 'type': 'array', 'itemType': DescribeVSwitchesResponseBodyVSwitchs },
        };
    }
}
exports.DescribeVSwitchesResponseBody = DescribeVSwitchesResponseBody;
class DescribeVSwitchesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeVSwitchesResponseBody,
        };
    }
}
exports.DescribeVSwitchesResponse = DescribeVSwitchesResponse;
class DescribeWhitelistTemplateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            templateId: 'TemplateId',
        };
    }
    static types() {
        return {
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            templateId: 'number',
        };
    }
}
exports.DescribeWhitelistTemplateRequest = DescribeWhitelistTemplateRequest;
class DescribeWhitelistTemplateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            httpStatusCode: 'HttpStatusCode',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeWhitelistTemplateResponseBodyData,
            httpStatusCode: 'number',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeWhitelistTemplateResponseBody = DescribeWhitelistTemplateResponseBody;
class DescribeWhitelistTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeWhitelistTemplateResponseBody,
        };
    }
}
exports.DescribeWhitelistTemplateResponse = DescribeWhitelistTemplateResponse;
class DescribeWhitelistTemplateLinkedInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            templateId: 'TemplateId',
        };
    }
    static types() {
        return {
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            templateId: 'number',
        };
    }
}
exports.DescribeWhitelistTemplateLinkedInstanceRequest = DescribeWhitelistTemplateLinkedInstanceRequest;
class DescribeWhitelistTemplateLinkedInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            httpStatusCode: 'HttpStatusCode',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeWhitelistTemplateLinkedInstanceResponseBodyData,
            httpStatusCode: 'number',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DescribeWhitelistTemplateLinkedInstanceResponseBody = DescribeWhitelistTemplateLinkedInstanceResponseBody;
class DescribeWhitelistTemplateLinkedInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeWhitelistTemplateLinkedInstanceResponseBody,
        };
    }
}
exports.DescribeWhitelistTemplateLinkedInstanceResponse = DescribeWhitelistTemplateLinkedInstanceResponse;
class DestroyDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.DestroyDBInstanceRequest = DestroyDBInstanceRequest;
class DestroyDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DestroyDBInstanceResponseBody = DestroyDBInstanceResponseBody;
class DestroyDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DestroyDBInstanceResponseBody,
        };
    }
}
exports.DestroyDBInstanceResponse = DestroyDBInstanceResponse;
class DetachGadInstanceMemberRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gadInstanceName: 'GadInstanceName',
            memberInstanceName: 'MemberInstanceName',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
        };
    }
    static types() {
        return {
            gadInstanceName: 'string',
            memberInstanceName: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
        };
    }
}
exports.DetachGadInstanceMemberRequest = DetachGadInstanceMemberRequest;
class DetachGadInstanceMemberResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DetachGadInstanceMemberResponseBody = DetachGadInstanceMemberResponseBody;
class DetachGadInstanceMemberResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DetachGadInstanceMemberResponseBody,
        };
    }
}
exports.DetachGadInstanceMemberResponse = DetachGadInstanceMemberResponse;
class DetachWhitelistTemplateToInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            insName: 'InsName',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            templateId: 'TemplateId',
        };
    }
    static types() {
        return {
            insName: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            templateId: 'number',
        };
    }
}
exports.DetachWhitelistTemplateToInstanceRequest = DetachWhitelistTemplateToInstanceRequest;
class DetachWhitelistTemplateToInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            httpStatusCode: 'HttpStatusCode',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DetachWhitelistTemplateToInstanceResponseBodyData,
            httpStatusCode: 'number',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.DetachWhitelistTemplateToInstanceResponseBody = DetachWhitelistTemplateToInstanceResponseBody;
class DetachWhitelistTemplateToInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DetachWhitelistTemplateToInstanceResponseBody,
        };
    }
}
exports.DetachWhitelistTemplateToInstanceResponse = DetachWhitelistTemplateToInstanceResponse;
class EvaluateLocalExtendDiskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            storage: 'Storage',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            storage: 'number',
        };
    }
}
exports.EvaluateLocalExtendDiskRequest = EvaluateLocalExtendDiskRequest;
class EvaluateLocalExtendDiskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            available: 'Available',
            DBInstanceId: 'DBInstanceId',
            DBInstanceTransType: 'DBInstanceTransType',
            localUpgradeDiskLimit: 'LocalUpgradeDiskLimit',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            available: 'string',
            DBInstanceId: 'string',
            DBInstanceTransType: 'string',
            localUpgradeDiskLimit: 'number',
            requestId: 'string',
        };
    }
}
exports.EvaluateLocalExtendDiskResponseBody = EvaluateLocalExtendDiskResponseBody;
class EvaluateLocalExtendDiskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: EvaluateLocalExtendDiskResponseBody,
        };
    }
}
exports.EvaluateLocalExtendDiskResponse = EvaluateLocalExtendDiskResponse;
class GetDBInstanceTopologyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            resourceOwnerId: 'number',
        };
    }
}
exports.GetDBInstanceTopologyRequest = GetDBInstanceTopologyRequest;
class GetDBInstanceTopologyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetDBInstanceTopologyResponseBodyData,
            message: 'string',
            requestId: 'string',
        };
    }
}
exports.GetDBInstanceTopologyResponseBody = GetDBInstanceTopologyResponseBody;
class GetDBInstanceTopologyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDBInstanceTopologyResponseBody,
        };
    }
}
exports.GetDBInstanceTopologyResponse = GetDBInstanceTopologyResponse;
class GetDbProxyInstanceSslRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBProxyEngineType: 'DBProxyEngineType',
            dbInstanceId: 'DbInstanceId',
            regionId: 'RegionId',
        };
    }
    static types() {
        return {
            DBProxyEngineType: 'string',
            dbInstanceId: 'string',
            regionId: 'string',
        };
    }
}
exports.GetDbProxyInstanceSslRequest = GetDbProxyInstanceSslRequest;
class GetDbProxyInstanceSslResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dbProxyCertListItems: 'DbProxyCertListItems',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            dbProxyCertListItems: GetDbProxyInstanceSslResponseBodyDbProxyCertListItems,
            requestId: 'string',
        };
    }
}
exports.GetDbProxyInstanceSslResponseBody = GetDbProxyInstanceSslResponseBody;
class GetDbProxyInstanceSslResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDbProxyInstanceSslResponseBody,
        };
    }
}
exports.GetDbProxyInstanceSslResponse = GetDbProxyInstanceSslResponse;
class GrantAccountPrivilegeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountName: 'AccountName',
            accountPrivilege: 'AccountPrivilege',
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            accountName: 'string',
            accountPrivilege: 'string',
            DBInstanceId: 'string',
            DBName: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.GrantAccountPrivilegeRequest = GrantAccountPrivilegeRequest;
class GrantAccountPrivilegeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.GrantAccountPrivilegeResponseBody = GrantAccountPrivilegeResponseBody;
class GrantAccountPrivilegeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GrantAccountPrivilegeResponseBody,
        };
    }
}
exports.GrantAccountPrivilegeResponse = GrantAccountPrivilegeResponse;
class GrantOperatorPermissionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            expiredTime: 'ExpiredTime',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            privileges: 'Privileges',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            expiredTime: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            privileges: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.GrantOperatorPermissionRequest = GrantOperatorPermissionRequest;
class GrantOperatorPermissionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.GrantOperatorPermissionResponseBody = GrantOperatorPermissionResponseBody;
class GrantOperatorPermissionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GrantOperatorPermissionResponseBody,
        };
    }
}
exports.GrantOperatorPermissionResponse = GrantOperatorPermissionResponse;
class ImportDatabaseBetweenInstancesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInfo: 'DBInfo',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            sourceDBInstanceId: 'SourceDBInstanceId',
        };
    }
    static types() {
        return {
            DBInfo: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            sourceDBInstanceId: 'string',
        };
    }
}
exports.ImportDatabaseBetweenInstancesRequest = ImportDatabaseBetweenInstancesRequest;
class ImportDatabaseBetweenInstancesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            importId: 'ImportId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            importId: 'string',
            requestId: 'string',
        };
    }
}
exports.ImportDatabaseBetweenInstancesResponseBody = ImportDatabaseBetweenInstancesResponseBody;
class ImportDatabaseBetweenInstancesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ImportDatabaseBetweenInstancesResponseBody,
        };
    }
}
exports.ImportDatabaseBetweenInstancesResponse = ImportDatabaseBetweenInstancesResponse;
class ImportUserBackupFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupFile: 'BackupFile',
            bucketRegion: 'BucketRegion',
            comment: 'Comment',
            engineVersion: 'EngineVersion',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            restoreSize: 'RestoreSize',
            retention: 'Retention',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            backupFile: 'string',
            bucketRegion: 'string',
            comment: 'string',
            engineVersion: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            restoreSize: 'number',
            retention: 'number',
            zoneId: 'string',
        };
    }
}
exports.ImportUserBackupFileRequest = ImportUserBackupFileRequest;
class ImportUserBackupFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            requestId: 'RequestId',
            status: 'Status',
        };
    }
    static types() {
        return {
            backupId: 'string',
            requestId: 'string',
            status: 'boolean',
        };
    }
}
exports.ImportUserBackupFileResponseBody = ImportUserBackupFileResponseBody;
class ImportUserBackupFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ImportUserBackupFileResponseBody,
        };
    }
}
exports.ImportUserBackupFileResponse = ImportUserBackupFileResponse;
class ListClassesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            commodityCode: 'CommodityCode',
            DBInstanceId: 'DBInstanceId',
            orderType: 'OrderType',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            commodityCode: 'string',
            DBInstanceId: 'string',
            orderType: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ListClassesRequest = ListClassesRequest;
class ListClassesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
            regionId: 'RegionId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': ListClassesResponseBodyItems },
            regionId: 'string',
            requestId: 'string',
        };
    }
}
exports.ListClassesResponseBody = ListClassesResponseBody;
class ListClassesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListClassesResponseBody,
        };
    }
}
exports.ListClassesResponse = ListClassesResponse;
class ListTagResourcesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'NextToken',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceId: 'ResourceId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            resourceType: 'ResourceType',
            tag: 'Tag',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceId: { 'type': 'array', 'itemType': 'string' },
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            resourceType: 'string',
            tag: { 'type': 'array', 'itemType': ListTagResourcesRequestTag },
        };
    }
}
exports.ListTagResourcesRequest = ListTagResourcesRequest;
class ListTagResourcesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'NextToken',
            requestId: 'RequestId',
            tagResources: 'TagResources',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            requestId: 'string',
            tagResources: ListTagResourcesResponseBodyTagResources,
        };
    }
}
exports.ListTagResourcesResponseBody = ListTagResourcesResponseBody;
class ListTagResourcesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListTagResourcesResponseBody,
        };
    }
}
exports.ListTagResourcesResponse = ListTagResourcesResponse;
class ListUserBackupFilesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            comment: 'Comment',
            ossUrl: 'OssUrl',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            status: 'Status',
            tags: 'Tags',
        };
    }
    static types() {
        return {
            backupId: 'string',
            comment: 'string',
            ossUrl: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            status: 'string',
            tags: 'string',
        };
    }
}
exports.ListUserBackupFilesRequest = ListUserBackupFilesRequest;
class ListUserBackupFilesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            records: 'Records',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            records: { 'type': 'array', 'itemType': ListUserBackupFilesResponseBodyRecords },
            requestId: 'string',
        };
    }
}
exports.ListUserBackupFilesResponseBody = ListUserBackupFilesResponseBody;
class ListUserBackupFilesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListUserBackupFilesResponseBody,
        };
    }
}
exports.ListUserBackupFilesResponse = ListUserBackupFilesResponse;
class LockAccountRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountName: 'AccountName',
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            accountName: 'string',
            DBInstanceId: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.LockAccountRequest = LockAccountRequest;
class LockAccountResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.LockAccountResponseBody = LockAccountResponseBody;
class LockAccountResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: LockAccountResponseBody,
        };
    }
}
exports.LockAccountResponse = LockAccountResponse;
class MigrateConnectionToOtherZoneRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectionString: 'ConnectionString',
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            resourceOwnerId: 'ResourceOwnerId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            connectionString: 'string',
            DBInstanceId: 'string',
            ownerId: 'number',
            resourceOwnerId: 'number',
            zoneId: 'string',
        };
    }
}
exports.MigrateConnectionToOtherZoneRequest = MigrateConnectionToOtherZoneRequest;
class MigrateConnectionToOtherZoneResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
        };
    }
}
exports.MigrateConnectionToOtherZoneResponseBody = MigrateConnectionToOtherZoneResponseBody;
class MigrateConnectionToOtherZoneResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MigrateConnectionToOtherZoneResponseBody,
        };
    }
}
exports.MigrateConnectionToOtherZoneResponse = MigrateConnectionToOtherZoneResponse;
class MigrateDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            effectiveTime: 'EffectiveTime',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            specifiedTime: 'SpecifiedTime',
            targetDedicatedHostIdForMaster: 'TargetDedicatedHostIdForMaster',
            targetDedicatedHostIdForSlave: 'TargetDedicatedHostIdForSlave',
            zoneIdForFollower: 'ZoneIdForFollower',
            zoneIdForLog: 'ZoneIdForLog',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            dedicatedHostGroupId: 'string',
            effectiveTime: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            specifiedTime: 'string',
            targetDedicatedHostIdForMaster: 'string',
            targetDedicatedHostIdForSlave: 'string',
            zoneIdForFollower: 'string',
            zoneIdForLog: 'string',
        };
    }
}
exports.MigrateDBInstanceRequest = MigrateDBInstanceRequest;
class MigrateDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            migrationId: 'MigrationId',
            requestId: 'RequestId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            migrationId: 'number',
            requestId: 'string',
            taskId: 'number',
        };
    }
}
exports.MigrateDBInstanceResponseBody = MigrateDBInstanceResponseBody;
class MigrateDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MigrateDBInstanceResponseBody,
        };
    }
}
exports.MigrateDBInstanceResponse = MigrateDBInstanceResponse;
class MigrateSecurityIPModeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.MigrateSecurityIPModeRequest = MigrateSecurityIPModeRequest;
class MigrateSecurityIPModeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            requestId: 'RequestId',
            securityIPMode: 'SecurityIPMode',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            requestId: 'string',
            securityIPMode: 'string',
        };
    }
}
exports.MigrateSecurityIPModeResponseBody = MigrateSecurityIPModeResponseBody;
class MigrateSecurityIPModeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MigrateSecurityIPModeResponseBody,
        };
    }
}
exports.MigrateSecurityIPModeResponse = MigrateSecurityIPModeResponse;
class MigrateToOtherZoneRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'Category',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStorage: 'DBInstanceStorage',
            effectiveTime: 'EffectiveTime',
            isModifySpec: 'IsModifySpec',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            switchTime: 'SwitchTime',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
            zoneId: 'ZoneId',
            zoneIdSlave1: 'ZoneIdSlave1',
            zoneIdSlave2: 'ZoneIdSlave2',
        };
    }
    static types() {
        return {
            category: 'string',
            DBInstanceClass: 'string',
            DBInstanceId: 'string',
            DBInstanceStorage: 'number',
            effectiveTime: 'string',
            isModifySpec: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            switchTime: 'string',
            VPCId: 'string',
            vSwitchId: 'string',
            zoneId: 'string',
            zoneIdSlave1: 'string',
            zoneIdSlave2: 'string',
        };
    }
}
exports.MigrateToOtherZoneRequest = MigrateToOtherZoneRequest;
class MigrateToOtherZoneResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            orderId: 'OrderId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            orderId: 'number',
            requestId: 'string',
        };
    }
}
exports.MigrateToOtherZoneResponseBody = MigrateToOtherZoneResponseBody;
class MigrateToOtherZoneResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MigrateToOtherZoneResponseBody,
        };
    }
}
exports.MigrateToOtherZoneResponse = MigrateToOtherZoneResponse;
class ModifyADInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ADAccountName: 'ADAccountName',
            ADDNS: 'ADDNS',
            ADPassword: 'ADPassword',
            ADServerIpAddress: 'ADServerIpAddress',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            ADAccountName: 'string',
            ADDNS: 'string',
            ADPassword: 'string',
            ADServerIpAddress: 'string',
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyADInfoRequest = ModifyADInfoRequest;
class ModifyADInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyADInfoResponseBody = ModifyADInfoResponseBody;
class ModifyADInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyADInfoResponseBody,
        };
    }
}
exports.ModifyADInfoResponse = ModifyADInfoResponse;
class ModifyAccountDescriptionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountDescription: 'AccountDescription',
            accountName: 'AccountName',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            accountDescription: 'string',
            accountName: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyAccountDescriptionRequest = ModifyAccountDescriptionRequest;
class ModifyAccountDescriptionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyAccountDescriptionResponseBody = ModifyAccountDescriptionResponseBody;
class ModifyAccountDescriptionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyAccountDescriptionResponseBody,
        };
    }
}
exports.ModifyAccountDescriptionResponse = ModifyAccountDescriptionResponse;
class ModifyActionEventPolicyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            enableEventLog: 'EnableEventLog',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            enableEventLog: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyActionEventPolicyRequest = ModifyActionEventPolicyRequest;
class ModifyActionEventPolicyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            enableEventLog: 'EnableEventLog',
            regionId: 'RegionId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            enableEventLog: 'string',
            regionId: 'string',
            requestId: 'string',
        };
    }
}
exports.ModifyActionEventPolicyResponseBody = ModifyActionEventPolicyResponseBody;
class ModifyActionEventPolicyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyActionEventPolicyResponseBody,
        };
    }
}
exports.ModifyActionEventPolicyResponse = ModifyActionEventPolicyResponse;
class ModifyActiveOperationTasksRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ids: 'Ids',
            immediateStart: 'ImmediateStart',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityToken: 'SecurityToken',
            switchTime: 'SwitchTime',
        };
    }
    static types() {
        return {
            ids: 'string',
            immediateStart: 'number',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            securityToken: 'string',
            switchTime: 'string',
        };
    }
}
exports.ModifyActiveOperationTasksRequest = ModifyActiveOperationTasksRequest;
class ModifyActiveOperationTasksResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ids: 'Ids',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            ids: 'string',
            requestId: 'string',
        };
    }
}
exports.ModifyActiveOperationTasksResponseBody = ModifyActiveOperationTasksResponseBody;
class ModifyActiveOperationTasksResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyActiveOperationTasksResponseBody,
        };
    }
}
exports.ModifyActiveOperationTasksResponse = ModifyActiveOperationTasksResponse;
class ModifyBackupPolicyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            archiveBackupKeepCount: 'ArchiveBackupKeepCount',
            archiveBackupKeepPolicy: 'ArchiveBackupKeepPolicy',
            archiveBackupRetentionPeriod: 'ArchiveBackupRetentionPeriod',
            backupInterval: 'BackupInterval',
            backupLog: 'BackupLog',
            backupMethod: 'BackupMethod',
            backupPolicyMode: 'BackupPolicyMode',
            backupPriority: 'BackupPriority',
            backupRetentionPeriod: 'BackupRetentionPeriod',
            category: 'Category',
            compressType: 'CompressType',
            DBInstanceId: 'DBInstanceId',
            enableBackupLog: 'EnableBackupLog',
            enableIncrementDataBackup: 'EnableIncrementDataBackup',
            highSpaceUsageProtection: 'HighSpaceUsageProtection',
            localLogRetentionHours: 'LocalLogRetentionHours',
            localLogRetentionSpace: 'LocalLogRetentionSpace',
            logBackupFrequency: 'LogBackupFrequency',
            logBackupLocalRetentionNumber: 'LogBackupLocalRetentionNumber',
            logBackupRetentionPeriod: 'LogBackupRetentionPeriod',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            preferredBackupPeriod: 'PreferredBackupPeriod',
            preferredBackupTime: 'PreferredBackupTime',
            releasedKeepPolicy: 'ReleasedKeepPolicy',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            archiveBackupKeepCount: 'number',
            archiveBackupKeepPolicy: 'string',
            archiveBackupRetentionPeriod: 'string',
            backupInterval: 'string',
            backupLog: 'string',
            backupMethod: 'string',
            backupPolicyMode: 'string',
            backupPriority: 'number',
            backupRetentionPeriod: 'string',
            category: 'string',
            compressType: 'string',
            DBInstanceId: 'string',
            enableBackupLog: 'string',
            enableIncrementDataBackup: 'boolean',
            highSpaceUsageProtection: 'string',
            localLogRetentionHours: 'string',
            localLogRetentionSpace: 'string',
            logBackupFrequency: 'string',
            logBackupLocalRetentionNumber: 'number',
            logBackupRetentionPeriod: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            preferredBackupPeriod: 'string',
            preferredBackupTime: 'string',
            releasedKeepPolicy: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyBackupPolicyRequest = ModifyBackupPolicyRequest;
class ModifyBackupPolicyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            compressType: 'CompressType',
            DBInstanceID: 'DBInstanceID',
            enableBackupLog: 'EnableBackupLog',
            highSpaceUsageProtection: 'HighSpaceUsageProtection',
            localLogRetentionHours: 'LocalLogRetentionHours',
            localLogRetentionSpace: 'LocalLogRetentionSpace',
            logBackupLocalRetentionNumber: 'LogBackupLocalRetentionNumber',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            compressType: 'string',
            DBInstanceID: 'string',
            enableBackupLog: 'string',
            highSpaceUsageProtection: 'string',
            localLogRetentionHours: 'number',
            localLogRetentionSpace: 'string',
            logBackupLocalRetentionNumber: 'number',
            requestId: 'string',
        };
    }
}
exports.ModifyBackupPolicyResponseBody = ModifyBackupPolicyResponseBody;
class ModifyBackupPolicyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyBackupPolicyResponseBody,
        };
    }
}
exports.ModifyBackupPolicyResponse = ModifyBackupPolicyResponse;
class ModifyCollationTimeZoneRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            collation: 'Collation',
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            timezone: 'Timezone',
        };
    }
    static types() {
        return {
            collation: 'string',
            DBInstanceId: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            timezone: 'string',
        };
    }
}
exports.ModifyCollationTimeZoneRequest = ModifyCollationTimeZoneRequest;
class ModifyCollationTimeZoneResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            collation: 'Collation',
            DBInstanceId: 'DBInstanceId',
            requestId: 'RequestId',
            taskId: 'TaskId',
            timezone: 'Timezone',
        };
    }
    static types() {
        return {
            collation: 'string',
            DBInstanceId: 'string',
            requestId: 'string',
            taskId: 'string',
            timezone: 'string',
        };
    }
}
exports.ModifyCollationTimeZoneResponseBody = ModifyCollationTimeZoneResponseBody;
class ModifyCollationTimeZoneResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyCollationTimeZoneResponseBody,
        };
    }
}
exports.ModifyCollationTimeZoneResponse = ModifyCollationTimeZoneResponse;
class ModifyCustinsResourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            adjustDeadline: 'AdjustDeadline',
            DBInstanceId: 'DBInstanceId',
            increaseRatio: 'IncreaseRatio',
            resourceOwnerId: 'ResourceOwnerId',
            resourceType: 'ResourceType',
            restoreOriginalSpecification: 'RestoreOriginalSpecification',
            targetValue: 'TargetValue',
        };
    }
    static types() {
        return {
            adjustDeadline: 'string',
            DBInstanceId: 'string',
            increaseRatio: 'string',
            resourceOwnerId: 'number',
            resourceType: 'string',
            restoreOriginalSpecification: 'string',
            targetValue: 'number',
        };
    }
}
exports.ModifyCustinsResourceRequest = ModifyCustinsResourceRequest;
class ModifyCustinsResourceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            requestId: 'string',
            taskId: 'number',
        };
    }
}
exports.ModifyCustinsResourceResponseBody = ModifyCustinsResourceResponseBody;
class ModifyCustinsResourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyCustinsResourceResponseBody,
        };
    }
}
exports.ModifyCustinsResourceResponse = ModifyCustinsResourceResponse;
class ModifyDBDescriptionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBDescription: 'DBDescription',
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBDescription: 'string',
            DBInstanceId: 'string',
            DBName: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBDescriptionRequest = ModifyDBDescriptionRequest;
class ModifyDBDescriptionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBDescriptionResponseBody = ModifyDBDescriptionResponseBody;
class ModifyDBDescriptionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBDescriptionResponseBody,
        };
    }
}
exports.ModifyDBDescriptionResponse = ModifyDBDescriptionResponse;
class ModifyDBInstanceAutoUpgradeMinorVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoUpgradeMinorVersion: 'AutoUpgradeMinorVersion',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            autoUpgradeMinorVersion: 'string',
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBInstanceAutoUpgradeMinorVersionRequest = ModifyDBInstanceAutoUpgradeMinorVersionRequest;
class ModifyDBInstanceAutoUpgradeMinorVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceAutoUpgradeMinorVersionResponseBody = ModifyDBInstanceAutoUpgradeMinorVersionResponseBody;
class ModifyDBInstanceAutoUpgradeMinorVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceAutoUpgradeMinorVersionResponseBody,
        };
    }
}
exports.ModifyDBInstanceAutoUpgradeMinorVersionResponse = ModifyDBInstanceAutoUpgradeMinorVersionResponse;
class ModifyDBInstanceConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            configName: 'ConfigName',
            configValue: 'ConfigValue',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            configName: 'string',
            configValue: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBInstanceConfigRequest = ModifyDBInstanceConfigRequest;
class ModifyDBInstanceConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceConfigResponseBody = ModifyDBInstanceConfigResponseBody;
class ModifyDBInstanceConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceConfigResponseBody,
        };
    }
}
exports.ModifyDBInstanceConfigResponse = ModifyDBInstanceConfigResponse;
class ModifyDBInstanceConnectionModeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectionMode: 'ConnectionMode',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            connectionMode: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBInstanceConnectionModeRequest = ModifyDBInstanceConnectionModeRequest;
class ModifyDBInstanceConnectionModeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceConnectionModeResponseBody = ModifyDBInstanceConnectionModeResponseBody;
class ModifyDBInstanceConnectionModeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceConnectionModeResponseBody,
        };
    }
}
exports.ModifyDBInstanceConnectionModeResponse = ModifyDBInstanceConnectionModeResponse;
class ModifyDBInstanceConnectionStringRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            babelfishPort: 'BabelfishPort',
            connectionStringPrefix: 'ConnectionStringPrefix',
            currentConnectionString: 'CurrentConnectionString',
            DBInstanceId: 'DBInstanceId',
            generalGroupName: 'GeneralGroupName',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            PGBouncerPort: 'PGBouncerPort',
            port: 'Port',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            babelfishPort: 'string',
            connectionStringPrefix: 'string',
            currentConnectionString: 'string',
            DBInstanceId: 'string',
            generalGroupName: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            PGBouncerPort: 'string',
            port: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBInstanceConnectionStringRequest = ModifyDBInstanceConnectionStringRequest;
class ModifyDBInstanceConnectionStringResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceConnectionStringResponseBody = ModifyDBInstanceConnectionStringResponseBody;
class ModifyDBInstanceConnectionStringResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceConnectionStringResponseBody,
        };
    }
}
exports.ModifyDBInstanceConnectionStringResponse = ModifyDBInstanceConnectionStringResponse;
class ModifyDBInstanceDelayedReplicationTimeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            readSQLReplicationTime: 'ReadSQLReplicationTime',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            readSQLReplicationTime: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBInstanceDelayedReplicationTimeRequest = ModifyDBInstanceDelayedReplicationTimeRequest;
class ModifyDBInstanceDelayedReplicationTimeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            readSQLReplicationTime: 'ReadSQLReplicationTime',
            requestId: 'RequestId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            readSQLReplicationTime: 'string',
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.ModifyDBInstanceDelayedReplicationTimeResponseBody = ModifyDBInstanceDelayedReplicationTimeResponseBody;
class ModifyDBInstanceDelayedReplicationTimeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceDelayedReplicationTimeResponseBody,
        };
    }
}
exports.ModifyDBInstanceDelayedReplicationTimeResponse = ModifyDBInstanceDelayedReplicationTimeResponse;
class ModifyDBInstanceDeletionProtectionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            deletionProtection: 'DeletionProtection',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            deletionProtection: 'boolean',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBInstanceDeletionProtectionRequest = ModifyDBInstanceDeletionProtectionRequest;
class ModifyDBInstanceDeletionProtectionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceDeletionProtectionResponseBody = ModifyDBInstanceDeletionProtectionResponseBody;
class ModifyDBInstanceDeletionProtectionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceDeletionProtectionResponseBody,
        };
    }
}
exports.ModifyDBInstanceDeletionProtectionResponse = ModifyDBInstanceDeletionProtectionResponse;
class ModifyDBInstanceDescriptionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceDescription: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBInstanceDescriptionRequest = ModifyDBInstanceDescriptionRequest;
class ModifyDBInstanceDescriptionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceDescriptionResponseBody = ModifyDBInstanceDescriptionResponseBody;
class ModifyDBInstanceDescriptionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceDescriptionResponseBody,
        };
    }
}
exports.ModifyDBInstanceDescriptionResponse = ModifyDBInstanceDescriptionResponse;
class ModifyDBInstanceEndpointRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceEndpointDescription: 'DBInstanceEndpointDescription',
            DBInstanceEndpointId: 'DBInstanceEndpointId',
            DBInstanceId: 'DBInstanceId',
            nodeItems: 'NodeItems',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceEndpointDescription: 'string',
            DBInstanceEndpointId: 'string',
            DBInstanceId: 'string',
            nodeItems: { 'type': 'array', 'itemType': ModifyDBInstanceEndpointRequestNodeItems },
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBInstanceEndpointRequest = ModifyDBInstanceEndpointRequest;
class ModifyDBInstanceEndpointShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceEndpointDescription: 'DBInstanceEndpointDescription',
            DBInstanceEndpointId: 'DBInstanceEndpointId',
            DBInstanceId: 'DBInstanceId',
            nodeItemsShrink: 'NodeItems',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceEndpointDescription: 'string',
            DBInstanceEndpointId: 'string',
            DBInstanceId: 'string',
            nodeItemsShrink: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBInstanceEndpointShrinkRequest = ModifyDBInstanceEndpointShrinkRequest;
class ModifyDBInstanceEndpointResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: ModifyDBInstanceEndpointResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceEndpointResponseBody = ModifyDBInstanceEndpointResponseBody;
class ModifyDBInstanceEndpointResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceEndpointResponseBody,
        };
    }
}
exports.ModifyDBInstanceEndpointResponse = ModifyDBInstanceEndpointResponse;
class ModifyDBInstanceEndpointAddressRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            connectionString: 'ConnectionString',
            connectionStringPrefix: 'ConnectionStringPrefix',
            DBInstanceEndpointId: 'DBInstanceEndpointId',
            DBInstanceId: 'DBInstanceId',
            port: 'Port',
            privateIpAddress: 'PrivateIpAddress',
            resourceOwnerId: 'ResourceOwnerId',
            vSwitchId: 'VSwitchId',
            vpcId: 'VpcId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            connectionString: 'string',
            connectionStringPrefix: 'string',
            DBInstanceEndpointId: 'string',
            DBInstanceId: 'string',
            port: 'string',
            privateIpAddress: 'string',
            resourceOwnerId: 'number',
            vSwitchId: 'string',
            vpcId: 'string',
        };
    }
}
exports.ModifyDBInstanceEndpointAddressRequest = ModifyDBInstanceEndpointAddressRequest;
class ModifyDBInstanceEndpointAddressResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: ModifyDBInstanceEndpointAddressResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceEndpointAddressResponseBody = ModifyDBInstanceEndpointAddressResponseBody;
class ModifyDBInstanceEndpointAddressResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceEndpointAddressResponseBody,
        };
    }
}
exports.ModifyDBInstanceEndpointAddressResponse = ModifyDBInstanceEndpointAddressResponse;
class ModifyDBInstanceHAConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dbInstanceId: 'DbInstanceId',
            HAMode: 'HAMode',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            syncMode: 'SyncMode',
        };
    }
    static types() {
        return {
            dbInstanceId: 'string',
            HAMode: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            syncMode: 'string',
        };
    }
}
exports.ModifyDBInstanceHAConfigRequest = ModifyDBInstanceHAConfigRequest;
class ModifyDBInstanceHAConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceHAConfigResponseBody = ModifyDBInstanceHAConfigResponseBody;
class ModifyDBInstanceHAConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceHAConfigResponseBody,
        };
    }
}
exports.ModifyDBInstanceHAConfigResponse = ModifyDBInstanceHAConfigResponse;
class ModifyDBInstanceMaintainTimeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            maintainTime: 'MaintainTime',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            maintainTime: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBInstanceMaintainTimeRequest = ModifyDBInstanceMaintainTimeRequest;
class ModifyDBInstanceMaintainTimeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceMaintainTimeResponseBody = ModifyDBInstanceMaintainTimeResponseBody;
class ModifyDBInstanceMaintainTimeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceMaintainTimeResponseBody,
        };
    }
}
exports.ModifyDBInstanceMaintainTimeResponse = ModifyDBInstanceMaintainTimeResponse;
class ModifyDBInstanceMetricsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            metricsConfig: 'MetricsConfig',
            resourceOwnerId: 'ResourceOwnerId',
            scope: 'Scope',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            metricsConfig: 'string',
            resourceOwnerId: 'number',
            scope: 'string',
        };
    }
}
exports.ModifyDBInstanceMetricsRequest = ModifyDBInstanceMetricsRequest;
class ModifyDBInstanceMetricsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            requestId: 'RequestId',
            scope: 'Scope',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            requestId: 'string',
            scope: 'string',
        };
    }
}
exports.ModifyDBInstanceMetricsResponseBody = ModifyDBInstanceMetricsResponseBody;
class ModifyDBInstanceMetricsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceMetricsResponseBody,
        };
    }
}
exports.ModifyDBInstanceMetricsResponse = ModifyDBInstanceMetricsResponse;
class ModifyDBInstanceMonitorRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            period: 'Period',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            period: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBInstanceMonitorRequest = ModifyDBInstanceMonitorRequest;
class ModifyDBInstanceMonitorResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceMonitorResponseBody = ModifyDBInstanceMonitorResponseBody;
class ModifyDBInstanceMonitorResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceMonitorResponseBody,
        };
    }
}
exports.ModifyDBInstanceMonitorResponse = ModifyDBInstanceMonitorResponse;
class ModifyDBInstanceNetworkExpireTimeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            classicExpiredDays: 'ClassicExpiredDays',
            connectionString: 'ConnectionString',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            classicExpiredDays: 'number',
            connectionString: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBInstanceNetworkExpireTimeRequest = ModifyDBInstanceNetworkExpireTimeRequest;
class ModifyDBInstanceNetworkExpireTimeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceNetworkExpireTimeResponseBody = ModifyDBInstanceNetworkExpireTimeResponseBody;
class ModifyDBInstanceNetworkExpireTimeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceNetworkExpireTimeResponseBody,
        };
    }
}
exports.ModifyDBInstanceNetworkExpireTimeResponse = ModifyDBInstanceNetworkExpireTimeResponse;
class ModifyDBInstanceNetworkTypeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            classicExpiredDays: 'ClassicExpiredDays',
            DBInstanceId: 'DBInstanceId',
            instanceNetworkType: 'InstanceNetworkType',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            privateIpAddress: 'PrivateIpAddress',
            readWriteSplittingClassicExpiredDays: 'ReadWriteSplittingClassicExpiredDays',
            readWriteSplittingPrivateIpAddress: 'ReadWriteSplittingPrivateIpAddress',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            retainClassic: 'RetainClassic',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
        };
    }
    static types() {
        return {
            classicExpiredDays: 'string',
            DBInstanceId: 'string',
            instanceNetworkType: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            privateIpAddress: 'string',
            readWriteSplittingClassicExpiredDays: 'number',
            readWriteSplittingPrivateIpAddress: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            retainClassic: 'string',
            VPCId: 'string',
            vSwitchId: 'string',
        };
    }
}
exports.ModifyDBInstanceNetworkTypeRequest = ModifyDBInstanceNetworkTypeRequest;
class ModifyDBInstanceNetworkTypeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectionString: 'ConnectionString',
            requestId: 'RequestId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            connectionString: 'string',
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.ModifyDBInstanceNetworkTypeResponseBody = ModifyDBInstanceNetworkTypeResponseBody;
class ModifyDBInstanceNetworkTypeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceNetworkTypeResponseBody,
        };
    }
}
exports.ModifyDBInstanceNetworkTypeResponse = ModifyDBInstanceNetworkTypeResponse;
class ModifyDBInstancePayTypeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            payType: 'PayType',
            period: 'Period',
            resourceOwnerId: 'ResourceOwnerId',
            usedTime: 'UsedTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            payType: 'string',
            period: 'string',
            resourceOwnerId: 'number',
            usedTime: 'number',
        };
    }
}
exports.ModifyDBInstancePayTypeRequest = ModifyDBInstancePayTypeRequest;
class ModifyDBInstancePayTypeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            orderId: 'OrderId',
        };
    }
    static types() {
        return {
            orderId: 'number',
        };
    }
}
exports.ModifyDBInstancePayTypeResponseBody = ModifyDBInstancePayTypeResponseBody;
class ModifyDBInstancePayTypeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstancePayTypeResponseBody,
        };
    }
}
exports.ModifyDBInstancePayTypeResponse = ModifyDBInstancePayTypeResponse;
class ModifyDBInstanceProxyConfigurationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            proxyConfigurationKey: 'ProxyConfigurationKey',
            proxyConfigurationValue: 'ProxyConfigurationValue',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            proxyConfigurationKey: 'string',
            proxyConfigurationValue: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBInstanceProxyConfigurationRequest = ModifyDBInstanceProxyConfigurationRequest;
class ModifyDBInstanceProxyConfigurationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceProxyConfigurationResponseBody = ModifyDBInstanceProxyConfigurationResponseBody;
class ModifyDBInstanceProxyConfigurationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceProxyConfigurationResponseBody,
        };
    }
}
exports.ModifyDBInstanceProxyConfigurationResponse = ModifyDBInstanceProxyConfigurationResponse;
class ModifyDBInstanceSSLRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ACL: 'ACL',
            CAType: 'CAType',
            clientCACert: 'ClientCACert',
            clientCAEnabled: 'ClientCAEnabled',
            clientCertRevocationList: 'ClientCertRevocationList',
            clientCrlEnabled: 'ClientCrlEnabled',
            connectionString: 'ConnectionString',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            replicationACL: 'ReplicationACL',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            SSLEnabled: 'SSLEnabled',
            serverCert: 'ServerCert',
            serverKey: 'ServerKey',
        };
    }
    static types() {
        return {
            ACL: 'string',
            CAType: 'string',
            clientCACert: 'string',
            clientCAEnabled: 'number',
            clientCertRevocationList: 'string',
            clientCrlEnabled: 'number',
            connectionString: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            replicationACL: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            SSLEnabled: 'number',
            serverCert: 'string',
            serverKey: 'string',
        };
    }
}
exports.ModifyDBInstanceSSLRequest = ModifyDBInstanceSSLRequest;
class ModifyDBInstanceSSLResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceSSLResponseBody = ModifyDBInstanceSSLResponseBody;
class ModifyDBInstanceSSLResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceSSLResponseBody,
        };
    }
}
exports.ModifyDBInstanceSSLResponse = ModifyDBInstanceSSLResponse;
class ModifyDBInstanceSpecRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoUseCoupon: 'AutoUseCoupon',
            burstingEnabled: 'BurstingEnabled',
            category: 'Category',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            direction: 'Direction',
            effectiveTime: 'EffectiveTime',
            engineVersion: 'EngineVersion',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            payType: 'PayType',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            serverlessConfiguration: 'ServerlessConfiguration',
            sourceBiz: 'SourceBiz',
            switchTime: 'SwitchTime',
            targetMinorVersion: 'TargetMinorVersion',
            usedTime: 'UsedTime',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            autoUseCoupon: 'boolean',
            burstingEnabled: 'boolean',
            category: 'string',
            DBInstanceClass: 'string',
            DBInstanceId: 'string',
            DBInstanceStorage: 'number',
            DBInstanceStorageType: 'string',
            dedicatedHostGroupId: 'string',
            direction: 'string',
            effectiveTime: 'string',
            engineVersion: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            payType: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            serverlessConfiguration: ModifyDBInstanceSpecRequestServerlessConfiguration,
            sourceBiz: 'string',
            switchTime: 'string',
            targetMinorVersion: 'string',
            usedTime: 'number',
            zoneId: 'string',
        };
    }
}
exports.ModifyDBInstanceSpecRequest = ModifyDBInstanceSpecRequest;
class ModifyDBInstanceSpecShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoUseCoupon: 'AutoUseCoupon',
            burstingEnabled: 'BurstingEnabled',
            category: 'Category',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            direction: 'Direction',
            effectiveTime: 'EffectiveTime',
            engineVersion: 'EngineVersion',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            payType: 'PayType',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            serverlessConfigurationShrink: 'ServerlessConfiguration',
            sourceBiz: 'SourceBiz',
            switchTime: 'SwitchTime',
            targetMinorVersion: 'TargetMinorVersion',
            usedTime: 'UsedTime',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            autoUseCoupon: 'boolean',
            burstingEnabled: 'boolean',
            category: 'string',
            DBInstanceClass: 'string',
            DBInstanceId: 'string',
            DBInstanceStorage: 'number',
            DBInstanceStorageType: 'string',
            dedicatedHostGroupId: 'string',
            direction: 'string',
            effectiveTime: 'string',
            engineVersion: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            payType: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            serverlessConfigurationShrink: 'string',
            sourceBiz: 'string',
            switchTime: 'string',
            targetMinorVersion: 'string',
            usedTime: 'number',
            zoneId: 'string',
        };
    }
}
exports.ModifyDBInstanceSpecShrinkRequest = ModifyDBInstanceSpecShrinkRequest;
class ModifyDBInstanceSpecResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            orderId: 'OrderId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            orderId: 'number',
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceSpecResponseBody = ModifyDBInstanceSpecResponseBody;
class ModifyDBInstanceSpecResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceSpecResponseBody,
        };
    }
}
exports.ModifyDBInstanceSpecResponse = ModifyDBInstanceSpecResponse;
class ModifyDBInstanceTDERequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            certificate: 'Certificate',
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            encryptionKey: 'EncryptionKey',
            isRotate: 'IsRotate',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            passWord: 'PassWord',
            privateKey: 'PrivateKey',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            roleArn: 'RoleArn',
            TDEStatus: 'TDEStatus',
        };
    }
    static types() {
        return {
            certificate: 'string',
            DBInstanceId: 'string',
            DBName: 'string',
            encryptionKey: 'string',
            isRotate: 'boolean',
            ownerAccount: 'string',
            ownerId: 'number',
            passWord: 'string',
            privateKey: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            roleArn: 'string',
            TDEStatus: 'string',
        };
    }
}
exports.ModifyDBInstanceTDERequest = ModifyDBInstanceTDERequest;
class ModifyDBInstanceTDEResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBInstanceTDEResponseBody = ModifyDBInstanceTDEResponseBody;
class ModifyDBInstanceTDEResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBInstanceTDEResponseBody,
        };
    }
}
exports.ModifyDBInstanceTDEResponse = ModifyDBInstanceTDEResponse;
class ModifyDBNodeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPay: 'AutoPay',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            DBNode: 'DBNode',
            dryRun: 'DryRun',
            effectiveTime: 'EffectiveTime',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            produceAsync: 'ProduceAsync',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            autoPay: 'boolean',
            clientToken: 'string',
            DBInstanceId: 'string',
            DBInstanceStorage: 'string',
            DBInstanceStorageType: 'string',
            DBNode: { 'type': 'array', 'itemType': ModifyDBNodeRequestDBNode },
            dryRun: 'boolean',
            effectiveTime: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            produceAsync: 'boolean',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBNodeRequest = ModifyDBNodeRequest;
class ModifyDBNodeShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPay: 'AutoPay',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            DBNodeShrink: 'DBNode',
            dryRun: 'DryRun',
            effectiveTime: 'EffectiveTime',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            produceAsync: 'ProduceAsync',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            autoPay: 'boolean',
            clientToken: 'string',
            DBInstanceId: 'string',
            DBInstanceStorage: 'string',
            DBInstanceStorageType: 'string',
            DBNodeShrink: 'string',
            dryRun: 'boolean',
            effectiveTime: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            produceAsync: 'boolean',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBNodeShrinkRequest = ModifyDBNodeShrinkRequest;
class ModifyDBNodeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            orderId: 'OrderId',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            orderId: 'number',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ModifyDBNodeResponseBody = ModifyDBNodeResponseBody;
class ModifyDBNodeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBNodeResponseBody,
        };
    }
}
exports.ModifyDBNodeResponse = ModifyDBNodeResponse;
class ModifyDBProxyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configDBProxyService: 'ConfigDBProxyService',
            DBInstanceId: 'DBInstanceId',
            DBProxyEngineType: 'DBProxyEngineType',
            DBProxyInstanceNum: 'DBProxyInstanceNum',
            DBProxyInstanceType: 'DBProxyInstanceType',
            instanceNetworkType: 'InstanceNetworkType',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
        };
    }
    static types() {
        return {
            configDBProxyService: 'string',
            DBInstanceId: 'string',
            DBProxyEngineType: 'string',
            DBProxyInstanceNum: 'string',
            DBProxyInstanceType: 'string',
            instanceNetworkType: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            VPCId: 'string',
            vSwitchId: 'string',
        };
    }
}
exports.ModifyDBProxyRequest = ModifyDBProxyRequest;
class ModifyDBProxyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBProxyResponseBody = ModifyDBProxyResponseBody;
class ModifyDBProxyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBProxyResponseBody,
        };
    }
}
exports.ModifyDBProxyResponse = ModifyDBProxyResponse;
class ModifyDBProxyEndpointRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configDBProxyFeatures: 'ConfigDBProxyFeatures',
            DBInstanceId: 'DBInstanceId',
            DBProxyEndpointId: 'DBProxyEndpointId',
            DBProxyEngineType: 'DBProxyEngineType',
            dbEndpointAliases: 'DbEndpointAliases',
            dbEndpointOperator: 'DbEndpointOperator',
            dbEndpointReadWriteMode: 'DbEndpointReadWriteMode',
            dbEndpointType: 'DbEndpointType',
            ownerId: 'OwnerId',
            readOnlyInstanceDistributionType: 'ReadOnlyInstanceDistributionType',
            readOnlyInstanceMaxDelayTime: 'ReadOnlyInstanceMaxDelayTime',
            readOnlyInstanceWeight: 'ReadOnlyInstanceWeight',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            configDBProxyFeatures: 'string',
            DBInstanceId: 'string',
            DBProxyEndpointId: 'string',
            DBProxyEngineType: 'string',
            dbEndpointAliases: 'string',
            dbEndpointOperator: 'string',
            dbEndpointReadWriteMode: 'string',
            dbEndpointType: 'string',
            ownerId: 'number',
            readOnlyInstanceDistributionType: 'string',
            readOnlyInstanceMaxDelayTime: 'string',
            readOnlyInstanceWeight: 'string',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBProxyEndpointRequest = ModifyDBProxyEndpointRequest;
class ModifyDBProxyEndpointResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBProxyEndpointResponseBody = ModifyDBProxyEndpointResponseBody;
class ModifyDBProxyEndpointResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBProxyEndpointResponseBody,
        };
    }
}
exports.ModifyDBProxyEndpointResponse = ModifyDBProxyEndpointResponse;
class ModifyDBProxyEndpointAddressRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DBProxyConnectStringNetType: 'DBProxyConnectStringNetType',
            DBProxyEndpointId: 'DBProxyEndpointId',
            DBProxyEngineType: 'DBProxyEngineType',
            DBProxyNewConnectString: 'DBProxyNewConnectString',
            DBProxyNewConnectStringPort: 'DBProxyNewConnectStringPort',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DBProxyConnectStringNetType: 'string',
            DBProxyEndpointId: 'string',
            DBProxyEngineType: 'string',
            DBProxyNewConnectString: 'string',
            DBProxyNewConnectStringPort: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBProxyEndpointAddressRequest = ModifyDBProxyEndpointAddressRequest;
class ModifyDBProxyEndpointAddressResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBProxyEndpointAddressResponseBody = ModifyDBProxyEndpointAddressResponseBody;
class ModifyDBProxyEndpointAddressResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBProxyEndpointAddressResponseBody,
        };
    }
}
exports.ModifyDBProxyEndpointAddressResponse = ModifyDBProxyEndpointAddressResponse;
class ModifyDBProxyInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DBProxyEngineType: 'DBProxyEngineType',
            DBProxyInstanceNum: 'DBProxyInstanceNum',
            DBProxyInstanceType: 'DBProxyInstanceType',
            effectiveSpecificTime: 'EffectiveSpecificTime',
            effectiveTime: 'EffectiveTime',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DBProxyEngineType: 'string',
            DBProxyInstanceNum: 'string',
            DBProxyInstanceType: 'string',
            effectiveSpecificTime: 'string',
            effectiveTime: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDBProxyInstanceRequest = ModifyDBProxyInstanceRequest;
class ModifyDBProxyInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDBProxyInstanceResponseBody = ModifyDBProxyInstanceResponseBody;
class ModifyDBProxyInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDBProxyInstanceResponseBody,
        };
    }
}
exports.ModifyDBProxyInstanceResponse = ModifyDBProxyInstanceResponse;
class ModifyDTCSecurityIpHostsForSQLServerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityIpHosts: 'SecurityIpHosts',
            securityToken: 'SecurityToken',
            whiteListGroupName: 'WhiteListGroupName',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            securityIpHosts: 'string',
            securityToken: 'string',
            whiteListGroupName: 'string',
        };
    }
}
exports.ModifyDTCSecurityIpHostsForSQLServerRequest = ModifyDTCSecurityIpHostsForSQLServerRequest;
class ModifyDTCSecurityIpHostsForSQLServerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DTCSetResult: 'DTCSetResult',
            requestId: 'RequestId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DTCSetResult: 'string',
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.ModifyDTCSecurityIpHostsForSQLServerResponseBody = ModifyDTCSecurityIpHostsForSQLServerResponseBody;
class ModifyDTCSecurityIpHostsForSQLServerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDTCSecurityIpHostsForSQLServerResponseBody,
        };
    }
}
exports.ModifyDTCSecurityIpHostsForSQLServerResponse = ModifyDTCSecurityIpHostsForSQLServerResponse;
class ModifyDasInstanceConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            storageAutoScale: 'StorageAutoScale',
            storageThreshold: 'StorageThreshold',
            storageUpperBound: 'StorageUpperBound',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            storageAutoScale: 'string',
            storageThreshold: 'number',
            storageUpperBound: 'number',
        };
    }
}
exports.ModifyDasInstanceConfigRequest = ModifyDasInstanceConfigRequest;
class ModifyDasInstanceConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDasInstanceConfigResponseBody = ModifyDasInstanceConfigResponseBody;
class ModifyDasInstanceConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDasInstanceConfigResponseBody,
        };
    }
}
exports.ModifyDasInstanceConfigResponse = ModifyDasInstanceConfigResponse;
class ModifyDatabaseConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            databasePropertyName: 'DatabasePropertyName',
            databasePropertyValue: 'DatabasePropertyValue',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DBName: 'string',
            databasePropertyName: 'string',
            databasePropertyValue: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyDatabaseConfigRequest = ModifyDatabaseConfigRequest;
class ModifyDatabaseConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
        };
    }
}
exports.ModifyDatabaseConfigResponseBody = ModifyDatabaseConfigResponseBody;
class ModifyDatabaseConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDatabaseConfigResponseBody,
        };
    }
}
exports.ModifyDatabaseConfigResponse = ModifyDatabaseConfigResponse;
class ModifyDbProxyInstanceSslRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBProxyEngineType: 'DBProxyEngineType',
            dbInstanceId: 'DbInstanceId',
            dbProxyConnectString: 'DbProxyConnectString',
            dbProxyEndpointId: 'DbProxyEndpointId',
            dbProxySslEnabled: 'DbProxySslEnabled',
            regionId: 'RegionId',
        };
    }
    static types() {
        return {
            DBProxyEngineType: 'string',
            dbInstanceId: 'string',
            dbProxyConnectString: 'string',
            dbProxyEndpointId: 'string',
            dbProxySslEnabled: 'string',
            regionId: 'string',
        };
    }
}
exports.ModifyDbProxyInstanceSslRequest = ModifyDbProxyInstanceSslRequest;
class ModifyDbProxyInstanceSslResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyDbProxyInstanceSslResponseBody = ModifyDbProxyInstanceSslResponseBody;
class ModifyDbProxyInstanceSslResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyDbProxyInstanceSslResponseBody,
        };
    }
}
exports.ModifyDbProxyInstanceSslResponse = ModifyDbProxyInstanceSslResponse;
class ModifyEventInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionParams: 'ActionParams',
            eventAction: 'EventAction',
            eventId: 'EventId',
            regionId: 'RegionId',
            securityToken: 'SecurityToken',
        };
    }
    static types() {
        return {
            actionParams: 'string',
            eventAction: 'string',
            eventId: 'string',
            regionId: 'string',
            securityToken: 'string',
        };
    }
}
exports.ModifyEventInfoRequest = ModifyEventInfoRequest;
class ModifyEventInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorCode: 'ErrorCode',
            errorEventId: 'ErrorEventId',
            requestId: 'RequestId',
            successCount: 'SuccessCount',
            successEventId: 'SuccessEventId',
        };
    }
    static types() {
        return {
            errorCode: 'string',
            errorEventId: 'string',
            requestId: 'string',
            successCount: 'number',
            successEventId: 'string',
        };
    }
}
exports.ModifyEventInfoResponseBody = ModifyEventInfoResponseBody;
class ModifyEventInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyEventInfoResponseBody,
        };
    }
}
exports.ModifyEventInfoResponse = ModifyEventInfoResponse;
class ModifyHADiagnoseConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            tcpConnectionType: 'TcpConnectionType',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            tcpConnectionType: 'string',
        };
    }
}
exports.ModifyHADiagnoseConfigRequest = ModifyHADiagnoseConfigRequest;
class ModifyHADiagnoseConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyHADiagnoseConfigResponseBody = ModifyHADiagnoseConfigResponseBody;
class ModifyHADiagnoseConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyHADiagnoseConfigResponseBody,
        };
    }
}
exports.ModifyHADiagnoseConfigResponse = ModifyHADiagnoseConfigResponse;
class ModifyHASwitchConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            HAConfig: 'HAConfig',
            manualHATime: 'ManualHATime',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            HAConfig: 'string',
            manualHATime: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyHASwitchConfigRequest = ModifyHASwitchConfigRequest;
class ModifyHASwitchConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyHASwitchConfigResponseBody = ModifyHASwitchConfigResponseBody;
class ModifyHASwitchConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyHASwitchConfigResponseBody,
        };
    }
}
exports.ModifyHASwitchConfigResponse = ModifyHASwitchConfigResponse;
class ModifyInstanceAutoRenewalAttributeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoRenew: 'AutoRenew',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            duration: 'Duration',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            autoRenew: 'string',
            clientToken: 'string',
            DBInstanceId: 'string',
            duration: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyInstanceAutoRenewalAttributeRequest = ModifyInstanceAutoRenewalAttributeRequest;
class ModifyInstanceAutoRenewalAttributeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyInstanceAutoRenewalAttributeResponseBody = ModifyInstanceAutoRenewalAttributeResponseBody;
class ModifyInstanceAutoRenewalAttributeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyInstanceAutoRenewalAttributeResponseBody,
        };
    }
}
exports.ModifyInstanceAutoRenewalAttributeResponse = ModifyInstanceAutoRenewalAttributeResponse;
class ModifyInstanceCrossBackupPolicyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupEnabled: 'BackupEnabled',
            crossBackupRegion: 'CrossBackupRegion',
            crossBackupType: 'CrossBackupType',
            DBInstanceId: 'DBInstanceId',
            logBackupEnabled: 'LogBackupEnabled',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            retentType: 'RetentType',
            retention: 'Retention',
        };
    }
    static types() {
        return {
            backupEnabled: 'string',
            crossBackupRegion: 'string',
            crossBackupType: 'string',
            DBInstanceId: 'string',
            logBackupEnabled: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            retentType: 'number',
            retention: 'number',
        };
    }
}
exports.ModifyInstanceCrossBackupPolicyRequest = ModifyInstanceCrossBackupPolicyRequest;
class ModifyInstanceCrossBackupPolicyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupEnabled: 'BackupEnabled',
            crossBackupRegion: 'CrossBackupRegion',
            crossBackupType: 'CrossBackupType',
            DBInstanceId: 'DBInstanceId',
            logBackupEnabled: 'LogBackupEnabled',
            regionId: 'RegionId',
            requestId: 'RequestId',
            retentType: 'RetentType',
            retention: 'Retention',
        };
    }
    static types() {
        return {
            backupEnabled: 'string',
            crossBackupRegion: 'string',
            crossBackupType: 'string',
            DBInstanceId: 'string',
            logBackupEnabled: 'string',
            regionId: 'string',
            requestId: 'string',
            retentType: 'number',
            retention: 'number',
        };
    }
}
exports.ModifyInstanceCrossBackupPolicyResponseBody = ModifyInstanceCrossBackupPolicyResponseBody;
class ModifyInstanceCrossBackupPolicyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyInstanceCrossBackupPolicyResponseBody,
        };
    }
}
exports.ModifyInstanceCrossBackupPolicyResponse = ModifyInstanceCrossBackupPolicyResponse;
class ModifyPGHbaConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            hbaItem: 'HbaItem',
            opsType: 'OpsType',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            hbaItem: { 'type': 'array', 'itemType': ModifyPGHbaConfigRequestHbaItem },
            opsType: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyPGHbaConfigRequest = ModifyPGHbaConfigRequest;
class ModifyPGHbaConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyPGHbaConfigResponseBody = ModifyPGHbaConfigResponseBody;
class ModifyPGHbaConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyPGHbaConfigResponseBody,
        };
    }
}
exports.ModifyPGHbaConfigResponse = ModifyPGHbaConfigResponse;
class ModifyParameterRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            forcerestart: 'Forcerestart',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            parameterGroupId: 'ParameterGroupId',
            parameters: 'Parameters',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            switchTime: 'SwitchTime',
            switchTimeMode: 'SwitchTimeMode',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            forcerestart: 'boolean',
            ownerAccount: 'string',
            ownerId: 'number',
            parameterGroupId: 'string',
            parameters: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            switchTime: 'string',
            switchTimeMode: 'string',
        };
    }
}
exports.ModifyParameterRequest = ModifyParameterRequest;
class ModifyParameterResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyParameterResponseBody = ModifyParameterResponseBody;
class ModifyParameterResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyParameterResponseBody,
        };
    }
}
exports.ModifyParameterResponse = ModifyParameterResponse;
class ModifyParameterGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            modifyMode: 'ModifyMode',
            ownerId: 'OwnerId',
            parameterGroupDesc: 'ParameterGroupDesc',
            parameterGroupId: 'ParameterGroupId',
            parameterGroupName: 'ParameterGroupName',
            parameters: 'Parameters',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            modifyMode: 'string',
            ownerId: 'number',
            parameterGroupDesc: 'string',
            parameterGroupId: 'string',
            parameterGroupName: 'string',
            parameters: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyParameterGroupRequest = ModifyParameterGroupRequest;
class ModifyParameterGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            parameterGroupId: 'ParameterGroupId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            parameterGroupId: 'string',
            requestId: 'string',
        };
    }
}
exports.ModifyParameterGroupResponseBody = ModifyParameterGroupResponseBody;
class ModifyParameterGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyParameterGroupResponseBody,
        };
    }
}
exports.ModifyParameterGroupResponse = ModifyParameterGroupResponse;
class ModifyReadWriteSplittingConnectionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectionStringPrefix: 'ConnectionStringPrefix',
            DBInstanceId: 'DBInstanceId',
            distributionType: 'DistributionType',
            maxDelayTime: 'MaxDelayTime',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            port: 'Port',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            weight: 'Weight',
        };
    }
    static types() {
        return {
            connectionStringPrefix: 'string',
            DBInstanceId: 'string',
            distributionType: 'string',
            maxDelayTime: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            port: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            weight: 'string',
        };
    }
}
exports.ModifyReadWriteSplittingConnectionRequest = ModifyReadWriteSplittingConnectionRequest;
class ModifyReadWriteSplittingConnectionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyReadWriteSplittingConnectionResponseBody = ModifyReadWriteSplittingConnectionResponseBody;
class ModifyReadWriteSplittingConnectionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyReadWriteSplittingConnectionResponseBody,
        };
    }
}
exports.ModifyReadWriteSplittingConnectionResponse = ModifyReadWriteSplittingConnectionResponse;
class ModifyReadonlyInstanceDelayReplicationTimeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            readSQLReplicationTime: 'ReadSQLReplicationTime',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            readSQLReplicationTime: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyReadonlyInstanceDelayReplicationTimeRequest = ModifyReadonlyInstanceDelayReplicationTimeRequest;
class ModifyReadonlyInstanceDelayReplicationTimeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            readSQLReplicationTime: 'ReadSQLReplicationTime',
            requestId: 'RequestId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            readSQLReplicationTime: 'string',
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.ModifyReadonlyInstanceDelayReplicationTimeResponseBody = ModifyReadonlyInstanceDelayReplicationTimeResponseBody;
class ModifyReadonlyInstanceDelayReplicationTimeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyReadonlyInstanceDelayReplicationTimeResponseBody,
        };
    }
}
exports.ModifyReadonlyInstanceDelayReplicationTimeResponse = ModifyReadonlyInstanceDelayReplicationTimeResponse;
class ModifyResourceGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ModifyResourceGroupRequest = ModifyResourceGroupRequest;
class ModifyResourceGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifyResourceGroupResponseBody = ModifyResourceGroupResponseBody;
class ModifyResourceGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyResourceGroupResponseBody,
        };
    }
}
exports.ModifyResourceGroupResponse = ModifyResourceGroupResponse;
class ModifySQLCollectorPolicyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            SQLCollectorStatus: 'SQLCollectorStatus',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            SQLCollectorStatus: 'string',
        };
    }
}
exports.ModifySQLCollectorPolicyRequest = ModifySQLCollectorPolicyRequest;
class ModifySQLCollectorPolicyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifySQLCollectorPolicyResponseBody = ModifySQLCollectorPolicyResponseBody;
class ModifySQLCollectorPolicyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifySQLCollectorPolicyResponseBody,
        };
    }
}
exports.ModifySQLCollectorPolicyResponse = ModifySQLCollectorPolicyResponse;
class ModifySQLCollectorRetentionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configValue: 'ConfigValue',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityToken: 'SecurityToken',
        };
    }
    static types() {
        return {
            configValue: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            securityToken: 'string',
        };
    }
}
exports.ModifySQLCollectorRetentionRequest = ModifySQLCollectorRetentionRequest;
class ModifySQLCollectorRetentionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ModifySQLCollectorRetentionResponseBody = ModifySQLCollectorRetentionResponseBody;
class ModifySQLCollectorRetentionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifySQLCollectorRetentionResponseBody,
        };
    }
}
exports.ModifySQLCollectorRetentionResponse = ModifySQLCollectorRetentionResponse;
class ModifySecurityGroupConfigurationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityGroupId: 'SecurityGroupId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            securityGroupId: 'string',
        };
    }
}
exports.ModifySecurityGroupConfigurationRequest = ModifySecurityGroupConfigurationRequest;
class ModifySecurityGroupConfigurationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            items: 'Items',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            items: ModifySecurityGroupConfigurationResponseBodyItems,
            requestId: 'string',
        };
    }
}
exports.ModifySecurityGroupConfigurationResponseBody = ModifySecurityGroupConfigurationResponseBody;
class ModifySecurityGroupConfigurationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifySecurityGroupConfigurationResponseBody,
        };
    }
}
exports.ModifySecurityGroupConfigurationResponse = ModifySecurityGroupConfigurationResponse;
class ModifySecurityIpsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceIPArrayAttribute: 'DBInstanceIPArrayAttribute',
            DBInstanceIPArrayName: 'DBInstanceIPArrayName',
            DBInstanceId: 'DBInstanceId',
            freshWhiteListReadins: 'FreshWhiteListReadins',
            modifyMode: 'ModifyMode',
            resourceOwnerId: 'ResourceOwnerId',
            securityIPType: 'SecurityIPType',
            securityIps: 'SecurityIps',
            whitelistNetworkType: 'WhitelistNetworkType',
        };
    }
    static types() {
        return {
            DBInstanceIPArrayAttribute: 'string',
            DBInstanceIPArrayName: 'string',
            DBInstanceId: 'string',
            freshWhiteListReadins: 'string',
            modifyMode: 'string',
            resourceOwnerId: 'number',
            securityIPType: 'string',
            securityIps: 'string',
            whitelistNetworkType: 'string',
        };
    }
}
exports.ModifySecurityIpsRequest = ModifySecurityIpsRequest;
class ModifySecurityIpsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.ModifySecurityIpsResponseBody = ModifySecurityIpsResponseBody;
class ModifySecurityIpsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifySecurityIpsResponseBody,
        };
    }
}
exports.ModifySecurityIpsResponse = ModifySecurityIpsResponse;
class ModifyTaskInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionParams: 'ActionParams',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            securityToken: 'SecurityToken',
            stepName: 'StepName',
            taskAction: 'TaskAction',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            actionParams: 'string',
            regionId: 'string',
            resourceOwnerAccount: 'number',
            resourceOwnerId: 'number',
            securityToken: 'string',
            stepName: 'string',
            taskAction: 'string',
            taskId: 'string',
        };
    }
}
exports.ModifyTaskInfoRequest = ModifyTaskInfoRequest;
class ModifyTaskInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorCode: 'ErrorCode',
            errorTaskId: 'ErrorTaskId',
            requestId: 'RequestId',
            successCount: 'SuccessCount',
        };
    }
    static types() {
        return {
            errorCode: 'string',
            errorTaskId: 'string',
            requestId: 'string',
            successCount: 'string',
        };
    }
}
exports.ModifyTaskInfoResponseBody = ModifyTaskInfoResponseBody;
class ModifyTaskInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyTaskInfoResponseBody,
        };
    }
}
exports.ModifyTaskInfoResponse = ModifyTaskInfoResponse;
class ModifyWhitelistTemplateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ipWhitelist: 'IpWhitelist',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            templateId: 'TemplateId',
            templateName: 'TemplateName',
        };
    }
    static types() {
        return {
            ipWhitelist: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            templateId: 'number',
            templateName: 'string',
        };
    }
}
exports.ModifyWhitelistTemplateRequest = ModifyWhitelistTemplateRequest;
class ModifyWhitelistTemplateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            httpStatusCode: 'HttpStatusCode',
            message: 'Message',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ModifyWhitelistTemplateResponseBodyData,
            httpStatusCode: 'number',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.ModifyWhitelistTemplateResponseBody = ModifyWhitelistTemplateResponseBody;
class ModifyWhitelistTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyWhitelistTemplateResponseBody,
        };
    }
}
exports.ModifyWhitelistTemplateResponse = ModifyWhitelistTemplateResponse;
class PreCheckCreateOrderForCreateDBNodesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPay: 'AutoPay',
            businessInfo: 'BusinessInfo',
            clientToken: 'ClientToken',
            commodityCode: 'CommodityCode',
            DBInstanceId: 'DBInstanceId',
            DBNode: 'DBNode',
            engineVersion: 'EngineVersion',
            nodeType: 'NodeType',
            ownerId: 'OwnerId',
            promotionCode: 'PromotionCode',
            regionId: 'RegionId',
            resource: 'Resource',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            autoPay: 'boolean',
            businessInfo: 'string',
            clientToken: 'string',
            commodityCode: 'string',
            DBInstanceId: 'string',
            DBNode: { 'type': 'array', 'itemType': PreCheckCreateOrderForCreateDBNodesRequestDBNode },
            engineVersion: 'string',
            nodeType: 'string',
            ownerId: 'number',
            promotionCode: 'string',
            regionId: 'string',
            resource: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            zoneId: 'string',
        };
    }
}
exports.PreCheckCreateOrderForCreateDBNodesRequest = PreCheckCreateOrderForCreateDBNodesRequest;
class PreCheckCreateOrderForCreateDBNodesShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPay: 'AutoPay',
            businessInfo: 'BusinessInfo',
            clientToken: 'ClientToken',
            commodityCode: 'CommodityCode',
            DBInstanceId: 'DBInstanceId',
            DBNodeShrink: 'DBNode',
            engineVersion: 'EngineVersion',
            nodeType: 'NodeType',
            ownerId: 'OwnerId',
            promotionCode: 'PromotionCode',
            regionId: 'RegionId',
            resource: 'Resource',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            autoPay: 'boolean',
            businessInfo: 'string',
            clientToken: 'string',
            commodityCode: 'string',
            DBInstanceId: 'string',
            DBNodeShrink: 'string',
            engineVersion: 'string',
            nodeType: 'string',
            ownerId: 'number',
            promotionCode: 'string',
            regionId: 'string',
            resource: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            zoneId: 'string',
        };
    }
}
exports.PreCheckCreateOrderForCreateDBNodesShrinkRequest = PreCheckCreateOrderForCreateDBNodesShrinkRequest;
class PreCheckCreateOrderForCreateDBNodesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failures: 'Failures',
            preCheckResult: 'PreCheckResult',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            failures: PreCheckCreateOrderForCreateDBNodesResponseBodyFailures,
            preCheckResult: 'boolean',
            requestId: 'string',
        };
    }
}
exports.PreCheckCreateOrderForCreateDBNodesResponseBody = PreCheckCreateOrderForCreateDBNodesResponseBody;
class PreCheckCreateOrderForCreateDBNodesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PreCheckCreateOrderForCreateDBNodesResponseBody,
        };
    }
}
exports.PreCheckCreateOrderForCreateDBNodesResponse = PreCheckCreateOrderForCreateDBNodesResponse;
class PreCheckCreateOrderForDeleteDBNodesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPay: 'AutoPay',
            businessInfo: 'BusinessInfo',
            clientToken: 'ClientToken',
            commodityCode: 'CommodityCode',
            DBInstanceId: 'DBInstanceId',
            DBNodeId: 'DBNodeId',
            engineVersion: 'EngineVersion',
            nodeType: 'NodeType',
            ownerId: 'OwnerId',
            promotionCode: 'PromotionCode',
            regionId: 'RegionId',
            resource: 'Resource',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            autoPay: 'boolean',
            businessInfo: 'string',
            clientToken: 'string',
            commodityCode: 'string',
            DBInstanceId: 'string',
            DBNodeId: { 'type': 'array', 'itemType': 'string' },
            engineVersion: 'string',
            nodeType: 'string',
            ownerId: 'number',
            promotionCode: 'string',
            regionId: 'string',
            resource: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            zoneId: 'string',
        };
    }
}
exports.PreCheckCreateOrderForDeleteDBNodesRequest = PreCheckCreateOrderForDeleteDBNodesRequest;
class PreCheckCreateOrderForDeleteDBNodesShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPay: 'AutoPay',
            businessInfo: 'BusinessInfo',
            clientToken: 'ClientToken',
            commodityCode: 'CommodityCode',
            DBInstanceId: 'DBInstanceId',
            DBNodeIdShrink: 'DBNodeId',
            engineVersion: 'EngineVersion',
            nodeType: 'NodeType',
            ownerId: 'OwnerId',
            promotionCode: 'PromotionCode',
            regionId: 'RegionId',
            resource: 'Resource',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            autoPay: 'boolean',
            businessInfo: 'string',
            clientToken: 'string',
            commodityCode: 'string',
            DBInstanceId: 'string',
            DBNodeIdShrink: 'string',
            engineVersion: 'string',
            nodeType: 'string',
            ownerId: 'number',
            promotionCode: 'string',
            regionId: 'string',
            resource: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            zoneId: 'string',
        };
    }
}
exports.PreCheckCreateOrderForDeleteDBNodesShrinkRequest = PreCheckCreateOrderForDeleteDBNodesShrinkRequest;
class PreCheckCreateOrderForDeleteDBNodesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failures: 'Failures',
            preCheckResult: 'PreCheckResult',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            failures: PreCheckCreateOrderForDeleteDBNodesResponseBodyFailures,
            preCheckResult: 'boolean',
            requestId: 'string',
        };
    }
}
exports.PreCheckCreateOrderForDeleteDBNodesResponseBody = PreCheckCreateOrderForDeleteDBNodesResponseBody;
class PreCheckCreateOrderForDeleteDBNodesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PreCheckCreateOrderForDeleteDBNodesResponseBody,
        };
    }
}
exports.PreCheckCreateOrderForDeleteDBNodesResponse = PreCheckCreateOrderForDeleteDBNodesResponse;
class PurgeDBInstanceLogRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.PurgeDBInstanceLogRequest = PurgeDBInstanceLogRequest;
class PurgeDBInstanceLogResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PurgeDBInstanceLogResponseBody = PurgeDBInstanceLogResponseBody;
class PurgeDBInstanceLogResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PurgeDBInstanceLogResponseBody,
        };
    }
}
exports.PurgeDBInstanceLogResponse = PurgeDBInstanceLogResponse;
class QueryNotifyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            from: 'From',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            to: 'To',
            withConfirmed: 'WithConfirmed',
        };
    }
    static types() {
        return {
            from: 'string',
            pageNumber: 'number',
            pageSize: 'number',
            to: 'string',
            withConfirmed: 'boolean',
        };
    }
}
exports.QueryNotifyRequest = QueryNotifyRequest;
class QueryNotifyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            data: QueryNotifyResponseBodyData,
            requestId: 'string',
        };
    }
}
exports.QueryNotifyResponseBody = QueryNotifyResponseBody;
class QueryNotifyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryNotifyResponseBody,
        };
    }
}
exports.QueryNotifyResponse = QueryNotifyResponse;
class QueryRecommendByCodeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            code: 'string',
            ownerId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'string',
        };
    }
}
exports.QueryRecommendByCodeRequest = QueryRecommendByCodeRequest;
class QueryRecommendByCodeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            requestId: 'RequestId',
            success: 'Success',
        };
    }
    static types() {
        return {
            data: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.QueryRecommendByCodeResponseBody = QueryRecommendByCodeResponseBody;
class QueryRecommendByCodeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryRecommendByCodeResponseBody,
        };
    }
}
exports.QueryRecommendByCodeResponse = QueryRecommendByCodeResponse;
class RebuildDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            dedicatedHostId: 'DedicatedHostId',
            ownerId: 'OwnerId',
            rebuildNodeType: 'RebuildNodeType',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            dedicatedHostGroupId: 'string',
            dedicatedHostId: 'string',
            ownerId: 'number',
            rebuildNodeType: 'string',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.RebuildDBInstanceRequest = RebuildDBInstanceRequest;
class RebuildDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            migrationId: 'MigrationId',
            requestId: 'RequestId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            migrationId: 'number',
            requestId: 'string',
            taskId: 'number',
        };
    }
}
exports.RebuildDBInstanceResponseBody = RebuildDBInstanceResponseBody;
class RebuildDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RebuildDBInstanceResponseBody,
        };
    }
}
exports.RebuildDBInstanceResponse = RebuildDBInstanceResponse;
class ReceiveDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            guardDBInstanceId: 'GuardDBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            guardDBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ReceiveDBInstanceRequest = ReceiveDBInstanceRequest;
class ReceiveDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            guardDBInstanceId: 'GuardDBInstanceId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            guardDBInstanceId: 'string',
            requestId: 'string',
        };
    }
}
exports.ReceiveDBInstanceResponseBody = ReceiveDBInstanceResponseBody;
class ReceiveDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReceiveDBInstanceResponseBody,
        };
    }
}
exports.ReceiveDBInstanceResponse = ReceiveDBInstanceResponse;
class RecoveryDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            dbNames: 'DbNames',
            instanceNetworkType: 'InstanceNetworkType',
            payType: 'PayType',
            period: 'Period',
            privateIpAddress: 'PrivateIpAddress',
            resourceOwnerId: 'ResourceOwnerId',
            restoreTime: 'RestoreTime',
            targetDBInstanceId: 'TargetDBInstanceId',
            usedTime: 'UsedTime',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
        };
    }
    static types() {
        return {
            backupId: 'string',
            DBInstanceClass: 'string',
            DBInstanceId: 'string',
            DBInstanceStorage: 'number',
            DBInstanceStorageType: 'string',
            dbNames: 'string',
            instanceNetworkType: 'string',
            payType: 'string',
            period: 'string',
            privateIpAddress: 'string',
            resourceOwnerId: 'number',
            restoreTime: 'string',
            targetDBInstanceId: 'string',
            usedTime: 'string',
            VPCId: 'string',
            vSwitchId: 'string',
        };
    }
}
exports.RecoveryDBInstanceRequest = RecoveryDBInstanceRequest;
class RecoveryDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            orderId: 'OrderId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            orderId: 'string',
            requestId: 'string',
        };
    }
}
exports.RecoveryDBInstanceResponseBody = RecoveryDBInstanceResponseBody;
class RecoveryDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecoveryDBInstanceResponseBody,
        };
    }
}
exports.RecoveryDBInstanceResponse = RecoveryDBInstanceResponse;
class ReleaseInstanceConnectionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentConnectionString: 'CurrentConnectionString',
            DBInstanceId: 'DBInstanceId',
            instanceNetworkType: 'InstanceNetworkType',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            currentConnectionString: 'string',
            DBInstanceId: 'string',
            instanceNetworkType: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ReleaseInstanceConnectionRequest = ReleaseInstanceConnectionRequest;
class ReleaseInstanceConnectionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ReleaseInstanceConnectionResponseBody = ReleaseInstanceConnectionResponseBody;
class ReleaseInstanceConnectionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReleaseInstanceConnectionResponseBody,
        };
    }
}
exports.ReleaseInstanceConnectionResponse = ReleaseInstanceConnectionResponse;
class ReleaseInstancePublicConnectionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentConnectionString: 'CurrentConnectionString',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            currentConnectionString: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ReleaseInstancePublicConnectionRequest = ReleaseInstancePublicConnectionRequest;
class ReleaseInstancePublicConnectionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ReleaseInstancePublicConnectionResponseBody = ReleaseInstancePublicConnectionResponseBody;
class ReleaseInstancePublicConnectionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReleaseInstancePublicConnectionResponseBody,
        };
    }
}
exports.ReleaseInstancePublicConnectionResponse = ReleaseInstancePublicConnectionResponse;
class ReleaseReadWriteSplittingConnectionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ReleaseReadWriteSplittingConnectionRequest = ReleaseReadWriteSplittingConnectionRequest;
class ReleaseReadWriteSplittingConnectionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ReleaseReadWriteSplittingConnectionResponseBody = ReleaseReadWriteSplittingConnectionResponseBody;
class ReleaseReadWriteSplittingConnectionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReleaseReadWriteSplittingConnectionResponseBody,
        };
    }
}
exports.ReleaseReadWriteSplittingConnectionResponse = ReleaseReadWriteSplittingConnectionResponse;
class RemoveTagsFromResourceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tag: 'Tag',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            tags: 'Tags',
            proxyId: 'proxyId',
        };
    }
    static types() {
        return {
            tag: { 'type': 'array', 'itemType': RemoveTagsFromResourceRequestTag },
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            tags: 'string',
            proxyId: 'string',
        };
    }
}
exports.RemoveTagsFromResourceRequest = RemoveTagsFromResourceRequest;
class RemoveTagsFromResourceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.RemoveTagsFromResourceResponseBody = RemoveTagsFromResourceResponseBody;
class RemoveTagsFromResourceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RemoveTagsFromResourceResponseBody,
        };
    }
}
exports.RemoveTagsFromResourceResponse = RemoveTagsFromResourceResponse;
class RenewInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPay: 'AutoPay',
            autoRenew: 'AutoRenew',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            period: 'Period',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            autoPay: 'string',
            autoRenew: 'string',
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerId: 'number',
            period: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.RenewInstanceRequest = RenewInstanceRequest;
class RenewInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            orderId: 'OrderId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            orderId: 'number',
            requestId: 'string',
        };
    }
}
exports.RenewInstanceResponseBody = RenewInstanceResponseBody;
class RenewInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RenewInstanceResponseBody,
        };
    }
}
exports.RenewInstanceResponse = RenewInstanceResponse;
class ResetAccountRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountName: 'AccountName',
            accountPassword: 'AccountPassword',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            accountName: 'string',
            accountPassword: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ResetAccountRequest = ResetAccountRequest;
class ResetAccountResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ResetAccountResponseBody = ResetAccountResponseBody;
class ResetAccountResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ResetAccountResponseBody,
        };
    }
}
exports.ResetAccountResponse = ResetAccountResponse;
class ResetAccountPasswordRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountName: 'AccountName',
            accountPassword: 'AccountPassword',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            accountName: 'string',
            accountPassword: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.ResetAccountPasswordRequest = ResetAccountPasswordRequest;
class ResetAccountPasswordResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.ResetAccountPasswordResponseBody = ResetAccountPasswordResponseBody;
class ResetAccountPasswordResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ResetAccountPasswordResponseBody,
        };
    }
}
exports.ResetAccountPasswordResponse = ResetAccountPasswordResponse;
class RestartDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            nodeId: 'NodeId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            nodeId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.RestartDBInstanceRequest = RestartDBInstanceRequest;
class RestartDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.RestartDBInstanceResponseBody = RestartDBInstanceResponseBody;
class RestartDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RestartDBInstanceResponseBody,
        };
    }
}
exports.RestartDBInstanceResponse = RestartDBInstanceResponse;
class RestoreDdrTableRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            restoreTime: 'RestoreTime',
            restoreType: 'RestoreType',
            sourceDBInstanceName: 'SourceDBInstanceName',
            sourceRegion: 'SourceRegion',
            tableMeta: 'TableMeta',
        };
    }
    static types() {
        return {
            backupId: 'string',
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            restoreTime: 'string',
            restoreType: 'string',
            sourceDBInstanceName: 'string',
            sourceRegion: 'string',
            tableMeta: 'string',
        };
    }
}
exports.RestoreDdrTableRequest = RestoreDdrTableRequest;
class RestoreDdrTableResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            requestId: 'string',
        };
    }
}
exports.RestoreDdrTableResponseBody = RestoreDdrTableResponseBody;
class RestoreDdrTableResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RestoreDdrTableResponseBody,
        };
    }
}
exports.RestoreDdrTableResponse = RestoreDdrTableResponse;
class RestoreTableRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            instantRecovery: 'InstantRecovery',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            restoreTime: 'RestoreTime',
            tableMeta: 'TableMeta',
        };
    }
    static types() {
        return {
            backupId: 'string',
            clientToken: 'string',
            DBInstanceId: 'string',
            instantRecovery: 'boolean',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            restoreTime: 'string',
            tableMeta: 'string',
        };
    }
}
exports.RestoreTableRequest = RestoreTableRequest;
class RestoreTableResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.RestoreTableResponseBody = RestoreTableResponseBody;
class RestoreTableResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RestoreTableResponseBody,
        };
    }
}
exports.RestoreTableResponse = RestoreTableResponse;
class RevokeAccountPrivilegeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountName: 'AccountName',
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            accountName: 'string',
            DBInstanceId: 'string',
            DBName: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.RevokeAccountPrivilegeRequest = RevokeAccountPrivilegeRequest;
class RevokeAccountPrivilegeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.RevokeAccountPrivilegeResponseBody = RevokeAccountPrivilegeResponseBody;
class RevokeAccountPrivilegeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RevokeAccountPrivilegeResponseBody,
        };
    }
}
exports.RevokeAccountPrivilegeResponse = RevokeAccountPrivilegeResponse;
class RevokeOperatorPermissionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.RevokeOperatorPermissionRequest = RevokeOperatorPermissionRequest;
class RevokeOperatorPermissionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.RevokeOperatorPermissionResponseBody = RevokeOperatorPermissionResponseBody;
class RevokeOperatorPermissionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RevokeOperatorPermissionResponseBody,
        };
    }
}
exports.RevokeOperatorPermissionResponse = RevokeOperatorPermissionResponse;
class StartDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DBInstanceTransType: 'DBInstanceTransType',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            effectiveTime: 'EffectiveTime',
            engineVersion: 'EngineVersion',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            specifiedTime: 'SpecifiedTime',
            storage: 'Storage',
            targetDBInstanceClass: 'TargetDBInstanceClass',
            targetDedicatedHostIdForLog: 'TargetDedicatedHostIdForLog',
            targetDedicatedHostIdForMaster: 'TargetDedicatedHostIdForMaster',
            targetDedicatedHostIdForSlave: 'TargetDedicatedHostIdForSlave',
            vSwitchId: 'VSwitchId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DBInstanceTransType: 'number',
            dedicatedHostGroupId: 'string',
            effectiveTime: 'string',
            engineVersion: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            specifiedTime: 'string',
            storage: 'number',
            targetDBInstanceClass: 'string',
            targetDedicatedHostIdForLog: 'string',
            targetDedicatedHostIdForMaster: 'string',
            targetDedicatedHostIdForSlave: 'string',
            vSwitchId: 'string',
            zoneId: 'string',
        };
    }
}
exports.StartDBInstanceRequest = StartDBInstanceRequest;
class StartDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            migrationId: 'MigrationId',
            requestId: 'RequestId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            migrationId: 'number',
            requestId: 'string',
            taskId: 'number',
        };
    }
}
exports.StartDBInstanceResponseBody = StartDBInstanceResponseBody;
class StartDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StartDBInstanceResponseBody,
        };
    }
}
exports.StartDBInstanceResponse = StartDBInstanceResponse;
class StopDBInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.StopDBInstanceRequest = StopDBInstanceRequest;
class StopDBInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.StopDBInstanceResponseBody = StopDBInstanceResponseBody;
class StopDBInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StopDBInstanceResponseBody,
        };
    }
}
exports.StopDBInstanceResponse = StopDBInstanceResponse;
class SwitchDBInstanceHARequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            effectiveTime: 'EffectiveTime',
            force: 'Force',
            nodeId: 'NodeId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            effectiveTime: 'string',
            force: 'string',
            nodeId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.SwitchDBInstanceHARequest = SwitchDBInstanceHARequest;
class SwitchDBInstanceHAResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.SwitchDBInstanceHAResponseBody = SwitchDBInstanceHAResponseBody;
class SwitchDBInstanceHAResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SwitchDBInstanceHAResponseBody,
        };
    }
}
exports.SwitchDBInstanceHAResponse = SwitchDBInstanceHAResponse;
class SwitchDBInstanceNetTypeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            connectionStringPrefix: 'ConnectionStringPrefix',
            connectionStringType: 'ConnectionStringType',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            port: 'Port',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            connectionStringPrefix: 'string',
            connectionStringType: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            port: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.SwitchDBInstanceNetTypeRequest = SwitchDBInstanceNetTypeRequest;
class SwitchDBInstanceNetTypeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            newConnectionString: 'NewConnectionString',
            oldConnectionString: 'OldConnectionString',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            newConnectionString: 'string',
            oldConnectionString: 'string',
            requestId: 'string',
        };
    }
}
exports.SwitchDBInstanceNetTypeResponseBody = SwitchDBInstanceNetTypeResponseBody;
class SwitchDBInstanceNetTypeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SwitchDBInstanceNetTypeResponseBody,
        };
    }
}
exports.SwitchDBInstanceNetTypeResponse = SwitchDBInstanceNetTypeResponse;
class SwitchDBInstanceVpcRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            privateIpAddress: 'PrivateIpAddress',
            resourceOwnerId: 'ResourceOwnerId',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            privateIpAddress: 'string',
            resourceOwnerId: 'number',
            VPCId: 'string',
            vSwitchId: 'string',
        };
    }
}
exports.SwitchDBInstanceVpcRequest = SwitchDBInstanceVpcRequest;
class SwitchDBInstanceVpcResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.SwitchDBInstanceVpcResponseBody = SwitchDBInstanceVpcResponseBody;
class SwitchDBInstanceVpcResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SwitchDBInstanceVpcResponseBody,
        };
    }
}
exports.SwitchDBInstanceVpcResponse = SwitchDBInstanceVpcResponse;
class SwitchGuardToMasterInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.SwitchGuardToMasterInstanceRequest = SwitchGuardToMasterInstanceRequest;
class SwitchGuardToMasterInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            requestId: 'string',
        };
    }
}
exports.SwitchGuardToMasterInstanceResponseBody = SwitchGuardToMasterInstanceResponseBody;
class SwitchGuardToMasterInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SwitchGuardToMasterInstanceResponseBody,
        };
    }
}
exports.SwitchGuardToMasterInstanceResponse = SwitchGuardToMasterInstanceResponse;
class TagResourcesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceId: 'ResourceId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            resourceType: 'ResourceType',
            tag: 'Tag',
        };
    }
    static types() {
        return {
            ownerId: 'number',
            regionId: 'string',
            resourceId: { 'type': 'array', 'itemType': 'string' },
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            resourceType: 'string',
            tag: { 'type': 'array', 'itemType': TagResourcesRequestTag },
        };
    }
}
exports.TagResourcesRequest = TagResourcesRequest;
class TagResourcesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.TagResourcesResponseBody = TagResourcesResponseBody;
class TagResourcesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TagResourcesResponseBody,
        };
    }
}
exports.TagResourcesResponse = TagResourcesResponse;
class TerminateMigrateTaskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            migrateTaskId: 'MigrateTaskId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            migrateTaskId: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.TerminateMigrateTaskRequest = TerminateMigrateTaskRequest;
class TerminateMigrateTaskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.TerminateMigrateTaskResponseBody = TerminateMigrateTaskResponseBody;
class TerminateMigrateTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TerminateMigrateTaskResponseBody,
        };
    }
}
exports.TerminateMigrateTaskResponse = TerminateMigrateTaskResponse;
class TransformDBInstancePayTypeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoRenew: 'AutoRenew',
            businessInfo: 'BusinessInfo',
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            payType: 'PayType',
            period: 'Period',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            usedTime: 'UsedTime',
        };
    }
    static types() {
        return {
            autoRenew: 'string',
            businessInfo: 'string',
            clientToken: 'string',
            DBInstanceId: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            payType: 'string',
            period: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            usedTime: 'number',
        };
    }
}
exports.TransformDBInstancePayTypeRequest = TransformDBInstancePayTypeRequest;
class TransformDBInstancePayTypeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            chargeType: 'ChargeType',
            DBInstanceId: 'DBInstanceId',
            expiredTime: 'ExpiredTime',
            orderId: 'OrderId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            chargeType: 'string',
            DBInstanceId: 'string',
            expiredTime: 'string',
            orderId: 'number',
            requestId: 'string',
        };
    }
}
exports.TransformDBInstancePayTypeResponseBody = TransformDBInstancePayTypeResponseBody;
class TransformDBInstancePayTypeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TransformDBInstancePayTypeResponseBody,
        };
    }
}
exports.TransformDBInstancePayTypeResponse = TransformDBInstancePayTypeResponse;
class UnlockAccountRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountName: 'AccountName',
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            accountName: 'string',
            DBInstanceId: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.UnlockAccountRequest = UnlockAccountRequest;
class UnlockAccountResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.UnlockAccountResponseBody = UnlockAccountResponseBody;
class UnlockAccountResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UnlockAccountResponseBody,
        };
    }
}
exports.UnlockAccountResponse = UnlockAccountResponse;
class UntagResourcesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            all: 'All',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceId: 'ResourceId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            resourceType: 'ResourceType',
            tagKey: 'TagKey',
        };
    }
    static types() {
        return {
            all: 'boolean',
            ownerId: 'number',
            regionId: 'string',
            resourceId: { 'type': 'array', 'itemType': 'string' },
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            resourceType: 'string',
            tagKey: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.UntagResourcesRequest = UntagResourcesRequest;
class UntagResourcesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.UntagResourcesResponseBody = UntagResourcesResponseBody;
class UntagResourcesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UntagResourcesResponseBody,
        };
    }
}
exports.UntagResourcesResponse = UntagResourcesResponse;
class UpdatePostgresExtensionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            DBNames: 'DBNames',
            extensions: 'Extensions',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            DBNames: 'string',
            extensions: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.UpdatePostgresExtensionsRequest = UpdatePostgresExtensionsRequest;
class UpdatePostgresExtensionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.UpdatePostgresExtensionsResponseBody = UpdatePostgresExtensionsResponseBody;
class UpdatePostgresExtensionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdatePostgresExtensionsResponseBody,
        };
    }
}
exports.UpdatePostgresExtensionsResponse = UpdatePostgresExtensionsResponse;
class UpdateUserBackupFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            comment: 'Comment',
            ownerId: 'OwnerId',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            retention: 'Retention',
        };
    }
    static types() {
        return {
            backupId: 'string',
            comment: 'string',
            ownerId: 'number',
            regionId: 'string',
            resourceGroupId: 'string',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            retention: 'number',
        };
    }
}
exports.UpdateUserBackupFileRequest = UpdateUserBackupFileRequest;
class UpdateUserBackupFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            backupId: 'string',
            requestId: 'string',
        };
    }
}
exports.UpdateUserBackupFileResponseBody = UpdateUserBackupFileResponseBody;
class UpdateUserBackupFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateUserBackupFileResponseBody,
        };
    }
}
exports.UpdateUserBackupFileResponse = UpdateUserBackupFileResponse;
class UpgradeDBInstanceEngineVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientToken: 'ClientToken',
            DBInstanceId: 'DBInstanceId',
            effectiveTime: 'EffectiveTime',
            engineVersion: 'EngineVersion',
            ownerAccount: 'OwnerAccount',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
        };
    }
    static types() {
        return {
            clientToken: 'string',
            DBInstanceId: 'string',
            effectiveTime: 'string',
            engineVersion: 'string',
            ownerAccount: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
        };
    }
}
exports.UpgradeDBInstanceEngineVersionRequest = UpgradeDBInstanceEngineVersionRequest;
class UpgradeDBInstanceEngineVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.UpgradeDBInstanceEngineVersionResponseBody = UpgradeDBInstanceEngineVersionResponseBody;
class UpgradeDBInstanceEngineVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpgradeDBInstanceEngineVersionResponseBody,
        };
    }
}
exports.UpgradeDBInstanceEngineVersionResponse = UpgradeDBInstanceEngineVersionResponse;
class UpgradeDBInstanceKernelVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            switchTime: 'SwitchTime',
            targetMinorVersion: 'TargetMinorVersion',
            upgradeTime: 'UpgradeTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            switchTime: 'string',
            targetMinorVersion: 'string',
            upgradeTime: 'string',
        };
    }
}
exports.UpgradeDBInstanceKernelVersionRequest = UpgradeDBInstanceKernelVersionRequest;
class UpgradeDBInstanceKernelVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            requestId: 'RequestId',
            targetMinorVersion: 'TargetMinorVersion',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            requestId: 'string',
            targetMinorVersion: 'string',
            taskId: 'string',
        };
    }
}
exports.UpgradeDBInstanceKernelVersionResponseBody = UpgradeDBInstanceKernelVersionResponseBody;
class UpgradeDBInstanceKernelVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpgradeDBInstanceKernelVersionResponseBody,
        };
    }
}
exports.UpgradeDBInstanceKernelVersionResponse = UpgradeDBInstanceKernelVersionResponse;
class UpgradeDBInstanceMajorVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            collectStatMode: 'CollectStatMode',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            instanceNetworkType: 'InstanceNetworkType',
            payType: 'PayType',
            period: 'Period',
            privateIpAddress: 'PrivateIpAddress',
            resourceOwnerId: 'ResourceOwnerId',
            switchOver: 'SwitchOver',
            switchTime: 'SwitchTime',
            switchTimeMode: 'SwitchTimeMode',
            targetMajorVersion: 'TargetMajorVersion',
            usedTime: 'UsedTime',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
            zoneId: 'ZoneId',
            zoneIdSlave1: 'ZoneIdSlave1',
            zoneIdSlave2: 'ZoneIdSlave2',
        };
    }
    static types() {
        return {
            collectStatMode: 'string',
            DBInstanceClass: 'string',
            DBInstanceId: 'string',
            DBInstanceStorage: 'number',
            DBInstanceStorageType: 'string',
            instanceNetworkType: 'string',
            payType: 'string',
            period: 'string',
            privateIpAddress: 'string',
            resourceOwnerId: 'number',
            switchOver: 'string',
            switchTime: 'string',
            switchTimeMode: 'string',
            targetMajorVersion: 'string',
            usedTime: 'string',
            VPCId: 'string',
            vSwitchId: 'string',
            zoneId: 'string',
            zoneIdSlave1: 'string',
            zoneIdSlave2: 'string',
        };
    }
}
exports.UpgradeDBInstanceMajorVersionRequest = UpgradeDBInstanceMajorVersionRequest;
class UpgradeDBInstanceMajorVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            orderId: 'OrderId',
            requestId: 'RequestId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            orderId: 'string',
            requestId: 'string',
            taskId: 'number',
        };
    }
}
exports.UpgradeDBInstanceMajorVersionResponseBody = UpgradeDBInstanceMajorVersionResponseBody;
class UpgradeDBInstanceMajorVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpgradeDBInstanceMajorVersionResponseBody,
        };
    }
}
exports.UpgradeDBInstanceMajorVersionResponse = UpgradeDBInstanceMajorVersionResponse;
class UpgradeDBInstanceMajorVersionPrecheckRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            resourceOwnerId: 'ResourceOwnerId',
            targetMajorVersion: 'TargetMajorVersion',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            resourceOwnerId: 'number',
            targetMajorVersion: 'string',
        };
    }
}
exports.UpgradeDBInstanceMajorVersionPrecheckRequest = UpgradeDBInstanceMajorVersionPrecheckRequest;
class UpgradeDBInstanceMajorVersionPrecheckResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            requestId: 'RequestId',
            targetMajorVersion: 'TargetMajorVersion',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            requestId: 'string',
            targetMajorVersion: 'string',
            taskId: 'string',
        };
    }
}
exports.UpgradeDBInstanceMajorVersionPrecheckResponseBody = UpgradeDBInstanceMajorVersionPrecheckResponseBody;
class UpgradeDBInstanceMajorVersionPrecheckResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpgradeDBInstanceMajorVersionPrecheckResponseBody,
        };
    }
}
exports.UpgradeDBInstanceMajorVersionPrecheckResponse = UpgradeDBInstanceMajorVersionPrecheckResponse;
class UpgradeDBProxyInstanceKernelVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DBProxyEngineType: 'DBProxyEngineType',
            ownerId: 'OwnerId',
            resourceOwnerAccount: 'ResourceOwnerAccount',
            resourceOwnerId: 'ResourceOwnerId',
            switchTime: 'SwitchTime',
            upgradeTime: 'UpgradeTime',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DBProxyEngineType: 'string',
            ownerId: 'number',
            resourceOwnerAccount: 'string',
            resourceOwnerId: 'number',
            switchTime: 'string',
            upgradeTime: 'string',
        };
    }
}
exports.UpgradeDBProxyInstanceKernelVersionRequest = UpgradeDBProxyInstanceKernelVersionRequest;
class UpgradeDBProxyInstanceKernelVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            requestId: 'RequestId',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.UpgradeDBProxyInstanceKernelVersionResponseBody = UpgradeDBProxyInstanceKernelVersionResponseBody;
class UpgradeDBProxyInstanceKernelVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpgradeDBProxyInstanceKernelVersionResponseBody,
        };
    }
}
exports.UpgradeDBProxyInstanceKernelVersionResponse = UpgradeDBProxyInstanceKernelVersionResponse;
class AddTagsToResourceRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.AddTagsToResourceRequestTag = AddTagsToResourceRequestTag;
class AttachWhitelistTemplateToInstanceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            status: 'Status',
        };
    }
    static types() {
        return {
            status: 'string',
        };
    }
}
exports.AttachWhitelistTemplateToInstanceResponseBodyData = AttachWhitelistTemplateToInstanceResponseBodyData;
class CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            DBInstanceType: 'DBInstanceType',
            readonlyInstanceSQLDelayedTime: 'ReadonlyInstanceSQLDelayedTime',
            weight: 'Weight',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            DBInstanceType: 'string',
            readonlyInstanceSQLDelayedTime: 'string',
            weight: 'string',
        };
    }
}
exports.CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight = CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight;
class CalculateDBInstanceWeightResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceWeight: 'DBInstanceWeight',
        };
    }
    static types() {
        return {
            DBInstanceWeight: { 'type': 'array', 'itemType': CalculateDBInstanceWeightResponseBodyItemsDBInstanceWeight },
        };
    }
}
exports.CalculateDBInstanceWeightResponseBodyItems = CalculateDBInstanceWeightResponseBodyItems;
class CloneDBInstanceRequestServerlessConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPause: 'AutoPause',
            maxCapacity: 'MaxCapacity',
            minCapacity: 'MinCapacity',
            switchForce: 'SwitchForce',
        };
    }
    static types() {
        return {
            autoPause: 'boolean',
            maxCapacity: 'number',
            minCapacity: 'number',
            switchForce: 'boolean',
        };
    }
}
exports.CloneDBInstanceRequestServerlessConfig = CloneDBInstanceRequestServerlessConfig;
class CreateDBInstanceRequestServerlessConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPause: 'AutoPause',
            maxCapacity: 'MaxCapacity',
            minCapacity: 'MinCapacity',
            switchForce: 'SwitchForce',
        };
    }
    static types() {
        return {
            autoPause: 'boolean',
            maxCapacity: 'number',
            minCapacity: 'number',
            switchForce: 'boolean',
        };
    }
}
exports.CreateDBInstanceRequestServerlessConfig = CreateDBInstanceRequestServerlessConfig;
class CreateDBInstanceRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.CreateDBInstanceRequestTag = CreateDBInstanceRequestTag;
class CreateDBInstanceShrinkRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.CreateDBInstanceShrinkRequestTag = CreateDBInstanceShrinkRequestTag;
class CreateDBInstanceEndpointRequestNodeItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            nodeId: 'NodeId',
            weight: 'Weight',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            nodeId: 'string',
            weight: 'number',
        };
    }
}
exports.CreateDBInstanceEndpointRequestNodeItems = CreateDBInstanceEndpointRequestNodeItems;
class CreateDBInstanceEndpointResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectionString: 'ConnectionString',
            DBInstanceEndpointId: 'DBInstanceEndpointId',
            DBInstanceName: 'DBInstanceName',
        };
    }
    static types() {
        return {
            connectionString: 'string',
            DBInstanceEndpointId: 'string',
            DBInstanceName: 'string',
        };
    }
}
exports.CreateDBInstanceEndpointResponseBodyData = CreateDBInstanceEndpointResponseBodyData;
class CreateDBInstanceEndpointAddressResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectionString: 'ConnectionString',
            DBInstanceEndpointId: 'DBInstanceEndpointId',
            DBInstanceName: 'DBInstanceName',
        };
    }
    static types() {
        return {
            connectionString: 'string',
            DBInstanceEndpointId: 'string',
            DBInstanceName: 'string',
        };
    }
}
exports.CreateDBInstanceEndpointAddressResponseBodyData = CreateDBInstanceEndpointAddressResponseBodyData;
class CreateDBNodesRequestDBNode extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            classCode: 'classCode',
            zoneId: 'zoneId',
        };
    }
    static types() {
        return {
            classCode: 'string',
            zoneId: 'string',
        };
    }
}
exports.CreateDBNodesRequestDBNode = CreateDBNodesRequestDBNode;
class CreateGADInstanceRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.CreateGADInstanceRequestTag = CreateGADInstanceRequestTag;
class CreateGADInstanceRequestUnitNode extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            dbInstanceClass: 'DbInstanceClass',
            dtsConflict: 'DtsConflict',
            dtsInstanceClass: 'DtsInstanceClass',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            payType: 'PayType',
            regionID: 'RegionID',
            securityIPList: 'SecurityIPList',
            vSwitchID: 'VSwitchID',
            vpcID: 'VpcID',
            zoneID: 'ZoneID',
            zoneIDSlave1: 'ZoneIDSlave1',
            zoneIDSlave2: 'ZoneIDSlave2',
        };
    }
    static types() {
        return {
            DBInstanceDescription: 'string',
            DBInstanceStorage: 'number',
            DBInstanceStorageType: 'string',
            dbInstanceClass: 'string',
            dtsConflict: 'string',
            dtsInstanceClass: 'string',
            engine: 'string',
            engineVersion: 'string',
            payType: 'string',
            regionID: 'string',
            securityIPList: 'string',
            vSwitchID: 'string',
            vpcID: 'string',
            zoneID: 'string',
            zoneIDSlave1: 'string',
            zoneIDSlave2: 'string',
        };
    }
}
exports.CreateGADInstanceRequestUnitNode = CreateGADInstanceRequestUnitNode;
class CreateGADInstanceResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createMemberCount: 'CreateMemberCount',
            gadInstanceName: 'GadInstanceName',
            taskID: 'TaskID',
        };
    }
    static types() {
        return {
            createMemberCount: 'string',
            gadInstanceName: 'string',
            taskID: 'string',
        };
    }
}
exports.CreateGADInstanceResponseBodyResult = CreateGADInstanceResponseBodyResult;
class CreateGadInstanceMemberRequestUnitNode extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            dbInstanceClass: 'DbInstanceClass',
            dtsConflict: 'DtsConflict',
            dtsInstanceClass: 'DtsInstanceClass',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            regionID: 'RegionID',
            securityIPList: 'SecurityIPList',
            vSwitchID: 'VSwitchID',
            vpcID: 'VpcID',
            zoneID: 'ZoneID',
            zoneIDSlave1: 'ZoneIDSlave1',
            zoneIDSlave2: 'ZoneIDSlave2',
        };
    }
    static types() {
        return {
            DBInstanceDescription: 'string',
            DBInstanceStorage: 'number',
            DBInstanceStorageType: 'string',
            dbInstanceClass: 'string',
            dtsConflict: 'string',
            dtsInstanceClass: 'string',
            engine: 'string',
            engineVersion: 'string',
            regionID: 'string',
            securityIPList: 'string',
            vSwitchID: 'string',
            vpcID: 'string',
            zoneID: 'string',
            zoneIDSlave1: 'string',
            zoneIDSlave2: 'string',
        };
    }
}
exports.CreateGadInstanceMemberRequestUnitNode = CreateGadInstanceMemberRequestUnitNode;
class CreateGadInstanceMemberResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createCount: 'CreateCount',
            gadInstanceName: 'GadInstanceName',
        };
    }
    static types() {
        return {
            createCount: 'string',
            gadInstanceName: 'string',
        };
    }
}
exports.CreateGadInstanceMemberResponseBodyResult = CreateGadInstanceMemberResponseBodyResult;
class CreateOrderForCreateDBNodesRequestDBNode extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            classCode: 'classCode',
            zoneId: 'zoneId',
        };
    }
    static types() {
        return {
            classCode: 'string',
            zoneId: 'string',
        };
    }
}
exports.CreateOrderForCreateDBNodesRequestDBNode = CreateOrderForCreateDBNodesRequestDBNode;
class DeleteBackupFileResponseBodyDeletedBaksetIds extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deletedBaksetIds: 'DeletedBaksetIds',
        };
    }
    static types() {
        return {
            deletedBaksetIds: { 'type': 'array', 'itemType': 'number' },
        };
    }
}
exports.DeleteBackupFileResponseBodyDeletedBaksetIds = DeleteBackupFileResponseBodyDeletedBaksetIds;
class DeleteDBInstanceEndpointResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceEndpointId: 'DBInstanceEndpointId',
            DBInstanceName: 'DBInstanceName',
        };
    }
    static types() {
        return {
            DBInstanceEndpointId: 'string',
            DBInstanceName: 'string',
        };
    }
}
exports.DeleteDBInstanceEndpointResponseBodyData = DeleteDBInstanceEndpointResponseBodyData;
class DeleteDBInstanceEndpointAddressResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceEndpointId: 'DBInstanceEndpointId',
            DBInstanceName: 'DBInstanceName',
        };
    }
    static types() {
        return {
            DBInstanceEndpointId: 'string',
            DBInstanceName: 'string',
        };
    }
}
exports.DeleteDBInstanceEndpointAddressResponseBodyData = DeleteDBInstanceEndpointAddressResponseBodyData;
class DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            importDataStatus: 'ImportDataStatus',
            importDataStatusDescription: 'ImportDataStatusDescription',
            importDataType: 'ImportDataType',
            importId: 'ImportId',
            incrementalImportingTime: 'IncrementalImportingTime',
        };
    }
    static types() {
        return {
            importDataStatus: 'string',
            importDataStatusDescription: 'string',
            importDataType: 'string',
            importId: 'number',
            incrementalImportingTime: 'string',
        };
    }
}
exports.DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB = DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB;
class DescibeImportsFromDatabaseResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            importResultFromDB: 'ImportResultFromDB',
        };
    }
    static types() {
        return {
            importResultFromDB: { 'type': 'array', 'itemType': DescibeImportsFromDatabaseResponseBodyItemsImportResultFromDB },
        };
    }
}
exports.DescibeImportsFromDatabaseResponseBodyItems = DescibeImportsFromDatabaseResponseBodyItems;
class DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountPrivilege: 'AccountPrivilege',
            accountPrivilegeDetail: 'AccountPrivilegeDetail',
            DBName: 'DBName',
        };
    }
    static types() {
        return {
            accountPrivilege: 'string',
            accountPrivilegeDetail: 'string',
            DBName: 'string',
        };
    }
}
exports.DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege = DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege;
class DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            databasePrivilege: 'DatabasePrivilege',
        };
    }
    static types() {
        return {
            databasePrivilege: { 'type': 'array', 'itemType': DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivilegesDatabasePrivilege },
        };
    }
}
exports.DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges = DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges;
class DescribeAccountsResponseBodyAccountsDBInstanceAccount extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountDescription: 'AccountDescription',
            accountName: 'AccountName',
            accountStatus: 'AccountStatus',
            accountType: 'AccountType',
            bypassRLS: 'BypassRLS',
            createDB: 'CreateDB',
            createRole: 'CreateRole',
            DBInstanceId: 'DBInstanceId',
            databasePrivileges: 'DatabasePrivileges',
            privExceeded: 'PrivExceeded',
            replication: 'Replication',
            validUntil: 'ValidUntil',
        };
    }
    static types() {
        return {
            accountDescription: 'string',
            accountName: 'string',
            accountStatus: 'string',
            accountType: 'string',
            bypassRLS: 'string',
            createDB: 'string',
            createRole: 'string',
            DBInstanceId: 'string',
            databasePrivileges: DescribeAccountsResponseBodyAccountsDBInstanceAccountDatabasePrivileges,
            privExceeded: 'string',
            replication: 'string',
            validUntil: 'string',
        };
    }
}
exports.DescribeAccountsResponseBodyAccountsDBInstanceAccount = DescribeAccountsResponseBodyAccountsDBInstanceAccount;
class DescribeAccountsResponseBodyAccounts extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceAccount: 'DBInstanceAccount',
        };
    }
    static types() {
        return {
            DBInstanceAccount: { 'type': 'array', 'itemType': DescribeAccountsResponseBodyAccountsDBInstanceAccount },
        };
    }
}
exports.DescribeAccountsResponseBodyAccounts = DescribeAccountsResponseBodyAccounts;
class DescribeActiveOperationTasksResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            allowCancel: 'AllowCancel',
            allowChange: 'AllowChange',
            changeLevel: 'ChangeLevel',
            changeLevelEn: 'ChangeLevelEn',
            changeLevelZh: 'ChangeLevelZh',
            createdTime: 'CreatedTime',
            currentAVZ: 'CurrentAVZ',
            dbType: 'DbType',
            dbVersion: 'DbVersion',
            deadline: 'Deadline',
            id: 'Id',
            impact: 'Impact',
            impactEn: 'ImpactEn',
            impactZh: 'ImpactZh',
            insComment: 'InsComment',
            insName: 'InsName',
            modifiedTime: 'ModifiedTime',
            prepareInterval: 'PrepareInterval',
            region: 'Region',
            resultInfo: 'ResultInfo',
            startTime: 'StartTime',
            status: 'Status',
            subInsNames: 'SubInsNames',
            switchTime: 'SwitchTime',
            taskParams: 'TaskParams',
            taskType: 'TaskType',
            taskTypeEn: 'TaskTypeEn',
            taskTypeZh: 'TaskTypeZh',
        };
    }
    static types() {
        return {
            allowCancel: 'string',
            allowChange: 'string',
            changeLevel: 'string',
            changeLevelEn: 'string',
            changeLevelZh: 'string',
            createdTime: 'string',
            currentAVZ: 'string',
            dbType: 'string',
            dbVersion: 'string',
            deadline: 'string',
            id: 'number',
            impact: 'string',
            impactEn: 'string',
            impactZh: 'string',
            insComment: 'string',
            insName: 'string',
            modifiedTime: 'string',
            prepareInterval: 'string',
            region: 'string',
            resultInfo: 'string',
            startTime: 'string',
            status: 'number',
            subInsNames: { 'type': 'array', 'itemType': 'string' },
            switchTime: 'string',
            taskParams: 'string',
            taskType: 'string',
            taskTypeEn: 'string',
            taskTypeZh: 'string',
        };
    }
}
exports.DescribeActiveOperationTasksResponseBodyItems = DescribeActiveOperationTasksResponseBodyItems;
class DescribeAllWhitelistTemplateResponseBodyDataTemplates extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'Id',
            ips: 'Ips',
            templateId: 'TemplateId',
            templateName: 'TemplateName',
            userId: 'UserId',
        };
    }
    static types() {
        return {
            id: 'number',
            ips: 'string',
            templateId: 'number',
            templateName: 'string',
            userId: 'number',
        };
    }
}
exports.DescribeAllWhitelistTemplateResponseBodyDataTemplates = DescribeAllWhitelistTemplateResponseBodyDataTemplates;
class DescribeAllWhitelistTemplateResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currPageNumbers: 'CurrPageNumbers',
            hasNext: 'HasNext',
            hasPrev: 'HasPrev',
            maxRecordsPerPage: 'MaxRecordsPerPage',
            templates: 'Templates',
            totalPageNumbers: 'TotalPageNumbers',
            totalRecords: 'TotalRecords',
        };
    }
    static types() {
        return {
            currPageNumbers: 'number',
            hasNext: 'boolean',
            hasPrev: 'boolean',
            maxRecordsPerPage: 'number',
            templates: { 'type': 'array', 'itemType': DescribeAllWhitelistTemplateResponseBodyDataTemplates },
            totalPageNumbers: 'number',
            totalRecords: 'number',
        };
    }
}
exports.DescribeAllWhitelistTemplateResponseBodyData = DescribeAllWhitelistTemplateResponseBodyData;
class DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxValue: 'MaxValue',
            minValue: 'MinValue',
            step: 'Step',
        };
    }
    static types() {
        return {
            maxValue: 'number',
            minValue: 'number',
            step: 'number',
        };
    }
}
exports.DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange = DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange;
class DescribeAvailableClassesResponseBodyDBInstanceClasses extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceStorageRange: 'DBInstanceStorageRange',
        };
    }
    static types() {
        return {
            DBInstanceClass: 'string',
            DBInstanceStorageRange: DescribeAvailableClassesResponseBodyDBInstanceClassesDBInstanceStorageRange,
        };
    }
}
exports.DescribeAvailableClassesResponseBodyDBInstanceClasses = DescribeAvailableClassesResponseBodyDBInstanceClasses;
class DescribeAvailableCrossRegionResponseBodyRegions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            region: 'Region',
        };
    }
    static types() {
        return {
            region: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeAvailableCrossRegionResponseBodyRegions = DescribeAvailableCrossRegionResponseBodyRegions;
class DescribeAvailableMetricsResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            dimension: 'Dimension',
            groupKey: 'GroupKey',
            groupKeyType: 'GroupKeyType',
            method: 'Method',
            metricsKey: 'MetricsKey',
            metricsKeyAlias: 'MetricsKeyAlias',
            sortRule: 'SortRule',
            unit: 'Unit',
        };
    }
    static types() {
        return {
            description: 'string',
            dimension: 'string',
            groupKey: 'string',
            groupKeyType: 'string',
            method: 'string',
            metricsKey: 'string',
            metricsKeyAlias: 'string',
            sortRule: 'number',
            unit: 'string',
        };
    }
}
exports.DescribeAvailableMetricsResponseBodyItems = DescribeAvailableMetricsResponseBodyItems;
class DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            storageType: 'StorageType',
        };
    }
    static types() {
        return {
            storageType: 'string',
        };
    }
}
exports.DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes = DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes;
class DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'Category',
            supportedStorageTypes: 'SupportedStorageTypes',
        };
    }
    static types() {
        return {
            category: 'string',
            supportedStorageTypes: { 'type': 'array', 'itemType': DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorysSupportedStorageTypes },
        };
    }
}
exports.DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys = DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys;
class DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            supportedCategorys: 'SupportedCategorys',
            version: 'Version',
        };
    }
    static types() {
        return {
            supportedCategorys: { 'type': 'array', 'itemType': DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersionsSupportedCategorys },
            version: 'string',
        };
    }
}
exports.DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions = DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions;
class DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            engine: 'Engine',
            supportedEngineVersions: 'SupportedEngineVersions',
        };
    }
    static types() {
        return {
            engine: 'string',
            supportedEngineVersions: { 'type': 'array', 'itemType': DescribeAvailableZonesResponseBodyAvailableZonesSupportedEnginesSupportedEngineVersions },
        };
    }
}
exports.DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines = DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines;
class DescribeAvailableZonesResponseBodyAvailableZones extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            regionId: 'RegionId',
            supportedEngines: 'SupportedEngines',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            regionId: 'string',
            supportedEngines: { 'type': 'array', 'itemType': DescribeAvailableZonesResponseBodyAvailableZonesSupportedEngines },
            zoneId: 'string',
        };
    }
}
exports.DescribeAvailableZonesResponseBodyAvailableZones = DescribeAvailableZonesResponseBodyAvailableZones;
class DescribeBackupTasksResponseBodyItemsBackupJob extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            backupJobId: 'BackupJobId',
            backupProgressStatus: 'BackupProgressStatus',
            backupStatus: 'BackupStatus',
            jobMode: 'JobMode',
            process: 'Process',
            taskAction: 'TaskAction',
        };
    }
    static types() {
        return {
            backupId: 'string',
            backupJobId: 'string',
            backupProgressStatus: 'string',
            backupStatus: 'string',
            jobMode: 'string',
            process: 'string',
            taskAction: 'string',
        };
    }
}
exports.DescribeBackupTasksResponseBodyItemsBackupJob = DescribeBackupTasksResponseBodyItemsBackupJob;
class DescribeBackupTasksResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupJob: 'BackupJob',
        };
    }
    static types() {
        return {
            backupJob: { 'type': 'array', 'itemType': DescribeBackupTasksResponseBodyItemsBackupJob },
        };
    }
}
exports.DescribeBackupTasksResponseBodyItems = DescribeBackupTasksResponseBodyItems;
class DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataBase: 'DataBase',
            downloadLink: 'DownloadLink',
            intranetDownloadLink: 'IntranetDownloadLink',
        };
    }
    static types() {
        return {
            dataBase: 'string',
            downloadLink: 'string',
            intranetDownloadLink: 'string',
        };
    }
}
exports.DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB = DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB;
class DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupDownloadLinkByDB: 'BackupDownloadLinkByDB',
        };
    }
    static types() {
        return {
            backupDownloadLinkByDB: { 'type': 'array', 'itemType': DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDBBackupDownloadLinkByDB },
        };
    }
}
exports.DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB = DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB;
class DescribeBackupsResponseBodyItemsBackup extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupDownloadLinkByDB: 'BackupDownloadLinkByDB',
            backupDownloadURL: 'BackupDownloadURL',
            backupEndTime: 'BackupEndTime',
            backupId: 'BackupId',
            backupInitiator: 'BackupInitiator',
            backupIntranetDownloadURL: 'BackupIntranetDownloadURL',
            backupMethod: 'BackupMethod',
            backupMode: 'BackupMode',
            backupSize: 'BackupSize',
            backupStartTime: 'BackupStartTime',
            backupStatus: 'BackupStatus',
            backupType: 'BackupType',
            checksum: 'Checksum',
            consistentTime: 'ConsistentTime',
            copyOnlyBackup: 'CopyOnlyBackup',
            DBInstanceId: 'DBInstanceId',
            encryption: 'Encryption',
            hostInstanceID: 'HostInstanceID',
            isAvail: 'IsAvail',
            metaStatus: 'MetaStatus',
            resourceGroupId: 'ResourceGroupId',
            storageClass: 'StorageClass',
            storeStatus: 'StoreStatus',
        };
    }
    static types() {
        return {
            backupDownloadLinkByDB: DescribeBackupsResponseBodyItemsBackupBackupDownloadLinkByDB,
            backupDownloadURL: 'string',
            backupEndTime: 'string',
            backupId: 'string',
            backupInitiator: 'string',
            backupIntranetDownloadURL: 'string',
            backupMethod: 'string',
            backupMode: 'string',
            backupSize: 'number',
            backupStartTime: 'string',
            backupStatus: 'string',
            backupType: 'string',
            checksum: 'string',
            consistentTime: 'number',
            copyOnlyBackup: 'string',
            DBInstanceId: 'string',
            encryption: 'string',
            hostInstanceID: 'string',
            isAvail: 'number',
            metaStatus: 'string',
            resourceGroupId: 'string',
            storageClass: 'string',
            storeStatus: 'string',
        };
    }
}
exports.DescribeBackupsResponseBodyItemsBackup = DescribeBackupsResponseBodyItemsBackup;
class DescribeBackupsResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backup: 'Backup',
        };
    }
    static types() {
        return {
            backup: { 'type': 'array', 'itemType': DescribeBackupsResponseBodyItemsBackup },
        };
    }
}
exports.DescribeBackupsResponseBodyItems = DescribeBackupsResponseBodyItems;
class DescribeBinlogFilesResponseBodyItemsBinLogFile extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checksum: 'Checksum',
            downloadLink: 'DownloadLink',
            fileSize: 'FileSize',
            hostInstanceID: 'HostInstanceID',
            intranetDownloadLink: 'IntranetDownloadLink',
            linkExpiredTime: 'LinkExpiredTime',
            logBeginTime: 'LogBeginTime',
            logEndTime: 'LogEndTime',
            logFileName: 'LogFileName',
            remoteStatus: 'RemoteStatus',
        };
    }
    static types() {
        return {
            checksum: 'string',
            downloadLink: 'string',
            fileSize: 'number',
            hostInstanceID: 'string',
            intranetDownloadLink: 'string',
            linkExpiredTime: 'string',
            logBeginTime: 'string',
            logEndTime: 'string',
            logFileName: 'string',
            remoteStatus: 'string',
        };
    }
}
exports.DescribeBinlogFilesResponseBodyItemsBinLogFile = DescribeBinlogFilesResponseBodyItemsBinLogFile;
class DescribeBinlogFilesResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            binLogFile: 'BinLogFile',
        };
    }
    static types() {
        return {
            binLogFile: { 'type': 'array', 'itemType': DescribeBinlogFilesResponseBodyItemsBinLogFile },
        };
    }
}
exports.DescribeBinlogFilesResponseBodyItems = DescribeBinlogFilesResponseBodyItems;
class DescribeCharacterSetNameResponseBodyCharacterSetNameItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            characterSetName: 'CharacterSetName',
        };
    }
    static types() {
        return {
            characterSetName: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeCharacterSetNameResponseBodyCharacterSetNameItems = DescribeCharacterSetNameResponseBodyCharacterSetNameItems;
class DescribeCloudMigrationPrecheckResultResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            detail: 'Detail',
            gmtCreated: 'GmtCreated',
            gmtModified: 'GmtModified',
            sourceAccount: 'SourceAccount',
            sourceCategory: 'SourceCategory',
            sourceIpAddress: 'SourceIpAddress',
            sourcePassword: 'SourcePassword',
            sourcePort: 'SourcePort',
            targetEip: 'TargetEip',
            targetInstanceName: 'TargetInstanceName',
            taskId: 'TaskId',
            taskName: 'TaskName',
        };
    }
    static types() {
        return {
            detail: 'string',
            gmtCreated: 'string',
            gmtModified: 'string',
            sourceAccount: 'string',
            sourceCategory: 'string',
            sourceIpAddress: 'string',
            sourcePassword: 'string',
            sourcePort: 'number',
            targetEip: 'string',
            targetInstanceName: 'string',
            taskId: 'number',
            taskName: 'string',
        };
    }
}
exports.DescribeCloudMigrationPrecheckResultResponseBodyItems = DescribeCloudMigrationPrecheckResultResponseBodyItems;
class DescribeCloudMigrationResultResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            detail: 'Detail',
            gmtCreated: 'GmtCreated',
            gmtModified: 'GmtModified',
            migrateStage: 'MigrateStage',
            replicationInfo: 'ReplicationInfo',
            replicationState: 'ReplicationState',
            sourceAccount: 'SourceAccount',
            sourceCategory: 'SourceCategory',
            sourceIpAddress: 'SourceIpAddress',
            sourcePassword: 'SourcePassword',
            sourcePort: 'SourcePort',
            switchTime: 'SwitchTime',
            targetEip: 'TargetEip',
            targetInstanceName: 'TargetInstanceName',
            taskId: 'TaskId',
            taskName: 'TaskName',
        };
    }
    static types() {
        return {
            detail: 'string',
            gmtCreated: 'string',
            gmtModified: 'string',
            migrateStage: 'string',
            replicationInfo: 'string',
            replicationState: 'string',
            sourceAccount: 'string',
            sourceCategory: 'string',
            sourceIpAddress: 'string',
            sourcePassword: 'string',
            sourcePort: 'number',
            switchTime: 'string',
            targetEip: 'string',
            targetInstanceName: 'string',
            taskId: 'number',
            taskName: 'string',
        };
    }
}
exports.DescribeCloudMigrationResultResponseBodyItems = DescribeCloudMigrationResultResponseBodyItems;
class DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            standardTimeOffset: 'StandardTimeOffset',
            timeZone: 'TimeZone',
        };
    }
    static types() {
        return {
            description: 'string',
            standardTimeOffset: 'string',
            timeZone: 'string',
        };
    }
}
exports.DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone = DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone;
class DescribeCollationTimeZonesResponseBodyCollationTimeZones extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            collationTimeZone: 'CollationTimeZone',
        };
    }
    static types() {
        return {
            collationTimeZone: { 'type': 'array', 'itemType': DescribeCollationTimeZonesResponseBodyCollationTimeZonesCollationTimeZone },
        };
    }
}
exports.DescribeCollationTimeZonesResponseBodyCollationTimeZones = DescribeCollationTimeZonesResponseBodyCollationTimeZones;
class DescribeCrossBackupMetaListResponseBodyItemsMeta extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            database: 'Database',
            size: 'Size',
            tables: 'Tables',
        };
    }
    static types() {
        return {
            database: 'string',
            size: 'string',
            tables: 'string',
        };
    }
}
exports.DescribeCrossBackupMetaListResponseBodyItemsMeta = DescribeCrossBackupMetaListResponseBodyItemsMeta;
class DescribeCrossBackupMetaListResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            meta: 'Meta',
        };
    }
    static types() {
        return {
            meta: { 'type': 'array', 'itemType': DescribeCrossBackupMetaListResponseBodyItemsMeta },
        };
    }
}
exports.DescribeCrossBackupMetaListResponseBodyItems = DescribeCrossBackupMetaListResponseBodyItems;
class DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupEnabled: 'BackupEnabled',
            backupEnabledTime: 'BackupEnabledTime',
            crossBackupRegion: 'CrossBackupRegion',
            crossBackupType: 'CrossBackupType',
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStatus: 'DBInstanceStatus',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            lockMode: 'LockMode',
            logBackupEnabled: 'LogBackupEnabled',
            logBackupEnabledTime: 'LogBackupEnabledTime',
            retentType: 'RetentType',
            retention: 'Retention',
        };
    }
    static types() {
        return {
            backupEnabled: 'string',
            backupEnabledTime: 'string',
            crossBackupRegion: 'string',
            crossBackupType: 'string',
            DBInstanceDescription: 'string',
            DBInstanceId: 'string',
            DBInstanceStatus: 'string',
            engine: 'string',
            engineVersion: 'string',
            lockMode: 'string',
            logBackupEnabled: 'string',
            logBackupEnabledTime: 'string',
            retentType: 'number',
            retention: 'number',
        };
    }
}
exports.DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem = DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem;
class DescribeCrossRegionBackupDBInstanceResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'Item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': DescribeCrossRegionBackupDBInstanceResponseBodyItemsItem },
        };
    }
}
exports.DescribeCrossRegionBackupDBInstanceResponseBodyItems = DescribeCrossRegionBackupDBInstanceResponseBodyItems;
class DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            restoreRegion: 'RestoreRegion',
        };
    }
    static types() {
        return {
            restoreRegion: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions = DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions;
class DescribeCrossRegionBackupsResponseBodyItemsItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupEndTime: 'BackupEndTime',
            backupMethod: 'BackupMethod',
            backupSetScale: 'BackupSetScale',
            backupSetStatus: 'BackupSetStatus',
            backupStartTime: 'BackupStartTime',
            backupType: 'BackupType',
            category: 'Category',
            consistentTime: 'ConsistentTime',
            crossBackupDownloadLink: 'CrossBackupDownloadLink',
            crossBackupId: 'CrossBackupId',
            crossBackupRegion: 'CrossBackupRegion',
            crossBackupSetFile: 'CrossBackupSetFile',
            crossBackupSetLocation: 'CrossBackupSetLocation',
            crossBackupSetSize: 'CrossBackupSetSize',
            DBInstanceStorageType: 'DBInstanceStorageType',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            instanceId: 'InstanceId',
            restoreRegions: 'RestoreRegions',
        };
    }
    static types() {
        return {
            backupEndTime: 'string',
            backupMethod: 'string',
            backupSetScale: 'number',
            backupSetStatus: 'number',
            backupStartTime: 'string',
            backupType: 'string',
            category: 'string',
            consistentTime: 'string',
            crossBackupDownloadLink: 'string',
            crossBackupId: 'number',
            crossBackupRegion: 'string',
            crossBackupSetFile: 'string',
            crossBackupSetLocation: 'string',
            crossBackupSetSize: 'number',
            DBInstanceStorageType: 'string',
            engine: 'string',
            engineVersion: 'string',
            instanceId: 'number',
            restoreRegions: DescribeCrossRegionBackupsResponseBodyItemsItemRestoreRegions,
        };
    }
}
exports.DescribeCrossRegionBackupsResponseBodyItemsItem = DescribeCrossRegionBackupsResponseBodyItemsItem;
class DescribeCrossRegionBackupsResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'Item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': DescribeCrossRegionBackupsResponseBodyItemsItem },
        };
    }
}
exports.DescribeCrossRegionBackupsResponseBodyItems = DescribeCrossRegionBackupsResponseBodyItems;
class DescribeCrossRegionLogBackupFilesResponseBodyItemsItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            crossBackupRegion: 'CrossBackupRegion',
            crossDownloadLink: 'CrossDownloadLink',
            crossIntranetDownloadLink: 'CrossIntranetDownloadLink',
            crossLogBackupId: 'CrossLogBackupId',
            crossLogBackupSize: 'CrossLogBackupSize',
            instanceId: 'InstanceId',
            linkExpiredTime: 'LinkExpiredTime',
            logBeginTime: 'LogBeginTime',
            logEndTime: 'LogEndTime',
            logFileName: 'LogFileName',
        };
    }
    static types() {
        return {
            crossBackupRegion: 'string',
            crossDownloadLink: 'string',
            crossIntranetDownloadLink: 'string',
            crossLogBackupId: 'number',
            crossLogBackupSize: 'number',
            instanceId: 'number',
            linkExpiredTime: 'string',
            logBeginTime: 'string',
            logEndTime: 'string',
            logFileName: 'string',
        };
    }
}
exports.DescribeCrossRegionLogBackupFilesResponseBodyItemsItem = DescribeCrossRegionLogBackupFilesResponseBodyItemsItem;
class DescribeCrossRegionLogBackupFilesResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'Item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': DescribeCrossRegionLogBackupFilesResponseBodyItemsItem },
        };
    }
}
exports.DescribeCrossRegionLogBackupFilesResponseBodyItems = DescribeCrossRegionLogBackupFilesResponseBodyItems;
class DescribeCurrentModifyOrderResponseBodyModifyOrder extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            classGroup: 'ClassGroup',
            cpu: 'Cpu',
            dbInstanceId: 'DbInstanceId',
            effectiveTime: 'EffectiveTime',
            mark: 'Mark',
            memoryClass: 'MemoryClass',
            status: 'Status',
            storage: 'Storage',
            targetDBInstanceClass: 'TargetDBInstanceClass',
        };
    }
    static types() {
        return {
            classGroup: 'string',
            cpu: 'string',
            dbInstanceId: 'string',
            effectiveTime: 'string',
            mark: 'string',
            memoryClass: 'string',
            status: 'string',
            storage: 'string',
            targetDBInstanceClass: 'string',
        };
    }
}
exports.DescribeCurrentModifyOrderResponseBodyModifyOrder = DescribeCurrentModifyOrderResponseBodyModifyOrder;
class DescribeCustinsResourceInfoResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cpuAdjustDeadline: 'CpuAdjustDeadline',
            cpuAdjustableMaxRatio: 'CpuAdjustableMaxRatio',
            cpuAdjustableMaxValue: 'CpuAdjustableMaxValue',
            cpuIncreaseRatio: 'CpuIncreaseRatio',
            cpuIncreaseRatioValue: 'CpuIncreaseRatioValue',
            DBInstanceId: 'DBInstanceId',
            iopsAdjustableMaxValue: 'IopsAdjustableMaxValue',
            maxConnAdjustDeadline: 'MaxConnAdjustDeadline',
            maxConnAdjustableMaxValue: 'MaxConnAdjustableMaxValue',
            maxConnIncreaseRatio: 'MaxConnIncreaseRatio',
            maxConnIncreaseRatioValue: 'MaxConnIncreaseRatioValue',
            maxIopsAdjustDeadline: 'MaxIopsAdjustDeadline',
            maxIopsIncreaseRatio: 'MaxIopsIncreaseRatio',
            maxIopsIncreaseRatioValue: 'MaxIopsIncreaseRatioValue',
            memAdjustableMaxRatio: 'MemAdjustableMaxRatio',
            memAdjustableMaxValue: 'MemAdjustableMaxValue',
            memoryAdjustDeadline: 'MemoryAdjustDeadline',
            memoryIncreaseRatio: 'MemoryIncreaseRatio',
            memoryIncreaseRatioValue: 'MemoryIncreaseRatioValue',
            originCpu: 'OriginCpu',
            originMaxConn: 'OriginMaxConn',
            originMaxIops: 'OriginMaxIops',
            originMemory: 'OriginMemory',
        };
    }
    static types() {
        return {
            cpuAdjustDeadline: 'string',
            cpuAdjustableMaxRatio: 'string',
            cpuAdjustableMaxValue: 'string',
            cpuIncreaseRatio: 'string',
            cpuIncreaseRatioValue: 'string',
            DBInstanceId: 'string',
            iopsAdjustableMaxValue: 'string',
            maxConnAdjustDeadline: 'string',
            maxConnAdjustableMaxValue: 'string',
            maxConnIncreaseRatio: 'string',
            maxConnIncreaseRatioValue: 'string',
            maxIopsAdjustDeadline: 'string',
            maxIopsIncreaseRatio: 'string',
            maxIopsIncreaseRatioValue: 'string',
            memAdjustableMaxRatio: 'string',
            memAdjustableMaxValue: 'string',
            memoryAdjustDeadline: 'string',
            memoryIncreaseRatio: 'string',
            memoryIncreaseRatioValue: 'string',
            originCpu: 'string',
            originMaxConn: 'string',
            originMaxIops: 'string',
            originMemory: 'string',
        };
    }
}
exports.DescribeCustinsResourceInfoResponseBodyData = DescribeCustinsResourceInfoResponseBodyData;
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeBabelfishConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            babelfishEnabled: 'BabelfishEnabled',
            migrationMode: 'MigrationMode',
        };
    }
    static types() {
        return {
            babelfishEnabled: 'string',
            migrationMode: 'string',
        };
    }
}
exports.DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeBabelfishConfig = DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeBabelfishConfig;
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            classCode: 'ClassCode',
            classType: 'ClassType',
            cpu: 'Cpu',
            memory: 'Memory',
            nodeId: 'NodeId',
            nodeRegionId: 'NodeRegionId',
            nodeRole: 'NodeRole',
            nodeZoneId: 'NodeZoneId',
            status: 'Status',
        };
    }
    static types() {
        return {
            classCode: 'string',
            classType: 'string',
            cpu: 'string',
            memory: 'string',
            nodeId: 'string',
            nodeRegionId: 'string',
            nodeRole: 'string',
            nodeZoneId: 'string',
            status: 'string',
        };
    }
}
exports.DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode = DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode;
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodes extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBClusterNode: 'DBClusterNode',
        };
    }
    static types() {
        return {
            DBClusterNode: { 'type': 'array', 'itemType': DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodesDBClusterNode },
        };
    }
}
exports.DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodes = DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodes;
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
        };
    }
    static types() {
        return {
            DBInstanceId: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds = DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds;
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceIds: 'DBInstanceIds',
        };
    }
    static types() {
        return {
            DBInstanceIds: DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtraDBInstanceIds,
        };
    }
}
exports.DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra = DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra;
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
        };
    }
}
exports.DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId = DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId;
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnlyDBInstanceId: 'ReadOnlyDBInstanceId',
        };
    }
    static types() {
        return {
            readOnlyDBInstanceId: { 'type': 'array', 'itemType': DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIdsReadOnlyDBInstanceId },
        };
    }
}
exports.DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds = DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds;
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPause: 'AutoPause',
            scaleMax: 'ScaleMax',
            scaleMin: 'ScaleMin',
            switchForce: 'SwitchForce',
        };
    }
    static types() {
        return {
            autoPause: 'boolean',
            scaleMax: 'number',
            scaleMin: 'number',
            switchForce: 'boolean',
        };
    }
}
exports.DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig = DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig;
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            zoneId: 'string',
        };
    }
}
exports.DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone = DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone;
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            slaveZone: 'SlaveZone',
        };
    }
    static types() {
        return {
            slaveZone: { 'type': 'array', 'itemType': DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZonesSlaveZone },
        };
    }
}
exports.DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones = DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones;
class DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountMaxQuantity: 'AccountMaxQuantity',
            advancedFeatures: 'AdvancedFeatures',
            autoUpgradeMinorVersion: 'AutoUpgradeMinorVersion',
            availabilityValue: 'AvailabilityValue',
            babelfishConfig: 'BabelfishConfig',
            bpeEnabled: 'BpeEnabled',
            burstingEnabled: 'BurstingEnabled',
            category: 'Category',
            collation: 'Collation',
            connectionMode: 'ConnectionMode',
            connectionString: 'ConnectionString',
            consoleVersion: 'ConsoleVersion',
            creationTime: 'CreationTime',
            currentKernelVersion: 'CurrentKernelVersion',
            DBClusterNodes: 'DBClusterNodes',
            DBInstanceCPU: 'DBInstanceCPU',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceClassType: 'DBInstanceClassType',
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceDiskUsed: 'DBInstanceDiskUsed',
            DBInstanceId: 'DBInstanceId',
            DBInstanceMemory: 'DBInstanceMemory',
            DBInstanceNetType: 'DBInstanceNetType',
            DBInstanceStatus: 'DBInstanceStatus',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceStorageType: 'DBInstanceStorageType',
            DBInstanceType: 'DBInstanceType',
            DBMaxQuantity: 'DBMaxQuantity',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            deletionProtection: 'DeletionProtection',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            expireTime: 'ExpireTime',
            extra: 'Extra',
            generalGroupName: 'GeneralGroupName',
            guardDBInstanceId: 'GuardDBInstanceId',
            IPType: 'IPType',
            incrementSourceDBInstanceId: 'IncrementSourceDBInstanceId',
            instanceNetworkType: 'InstanceNetworkType',
            instructionSetArch: 'InstructionSetArch',
            latestKernelVersion: 'LatestKernelVersion',
            lockMode: 'LockMode',
            lockReason: 'LockReason',
            maintainTime: 'MaintainTime',
            masterInstanceId: 'MasterInstanceId',
            masterZone: 'MasterZone',
            maxConnections: 'MaxConnections',
            maxIOMBPS: 'MaxIOMBPS',
            maxIOPS: 'MaxIOPS',
            PGBouncerEnabled: 'PGBouncerEnabled',
            payType: 'PayType',
            port: 'Port',
            proxyType: 'ProxyType',
            readOnlyDBInstanceIds: 'ReadOnlyDBInstanceIds',
            readonlyInstanceSQLDelayedTime: 'ReadonlyInstanceSQLDelayedTime',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            securityIPList: 'SecurityIPList',
            securityIPMode: 'SecurityIPMode',
            serverlessConfig: 'ServerlessConfig',
            slaveZones: 'SlaveZones',
            superPermissionMode: 'SuperPermissionMode',
            tempDBInstanceId: 'TempDBInstanceId',
            timeZone: 'TimeZone',
            tips: 'Tips',
            tipsLevel: 'TipsLevel',
            vSwitchId: 'VSwitchId',
            vpcCloudInstanceId: 'VpcCloudInstanceId',
            vpcId: 'VpcId',
            zoneId: 'ZoneId',
            kindCode: 'kindCode',
        };
    }
    static types() {
        return {
            accountMaxQuantity: 'number',
            advancedFeatures: 'string',
            autoUpgradeMinorVersion: 'string',
            availabilityValue: 'string',
            babelfishConfig: DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeBabelfishConfig,
            bpeEnabled: 'string',
            burstingEnabled: 'boolean',
            category: 'string',
            collation: 'string',
            connectionMode: 'string',
            connectionString: 'string',
            consoleVersion: 'string',
            creationTime: 'string',
            currentKernelVersion: 'string',
            DBClusterNodes: DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeDBClusterNodes,
            DBInstanceCPU: 'string',
            DBInstanceClass: 'string',
            DBInstanceClassType: 'string',
            DBInstanceDescription: 'string',
            DBInstanceDiskUsed: 'string',
            DBInstanceId: 'string',
            DBInstanceMemory: 'number',
            DBInstanceNetType: 'string',
            DBInstanceStatus: 'string',
            DBInstanceStorage: 'number',
            DBInstanceStorageType: 'string',
            DBInstanceType: 'string',
            DBMaxQuantity: 'number',
            dedicatedHostGroupId: 'string',
            deletionProtection: 'boolean',
            engine: 'string',
            engineVersion: 'string',
            expireTime: 'string',
            extra: DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeExtra,
            generalGroupName: 'string',
            guardDBInstanceId: 'string',
            IPType: 'string',
            incrementSourceDBInstanceId: 'string',
            instanceNetworkType: 'string',
            instructionSetArch: 'string',
            latestKernelVersion: 'string',
            lockMode: 'string',
            lockReason: 'string',
            maintainTime: 'string',
            masterInstanceId: 'string',
            masterZone: 'string',
            maxConnections: 'number',
            maxIOMBPS: 'number',
            maxIOPS: 'number',
            PGBouncerEnabled: 'string',
            payType: 'string',
            port: 'string',
            proxyType: 'number',
            readOnlyDBInstanceIds: DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeReadOnlyDBInstanceIds,
            readonlyInstanceSQLDelayedTime: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            securityIPList: 'string',
            securityIPMode: 'string',
            serverlessConfig: DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeServerlessConfig,
            slaveZones: DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttributeSlaveZones,
            superPermissionMode: 'string',
            tempDBInstanceId: 'string',
            timeZone: 'string',
            tips: 'string',
            tipsLevel: 'number',
            vSwitchId: 'string',
            vpcCloudInstanceId: 'string',
            vpcId: 'string',
            zoneId: 'string',
            kindCode: 'string',
        };
    }
}
exports.DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute = DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute;
class DescribeDBInstanceAttributeResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceAttribute: 'DBInstanceAttribute',
        };
    }
    static types() {
        return {
            DBInstanceAttribute: { 'type': 'array', 'itemType': DescribeDBInstanceAttributeResponseBodyItemsDBInstanceAttribute },
        };
    }
}
exports.DescribeDBInstanceAttributeResponseBodyItems = DescribeDBInstanceAttributeResponseBodyItems;
class DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTagsTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagKey: 'TagKey',
            tagValue: 'TagValue',
        };
    }
    static types() {
        return {
            tagKey: 'string',
            tagValue: 'string',
        };
    }
}
exports.DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTagsTag = DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTagsTag;
class DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTags extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tag: 'Tag',
        };
    }
    static types() {
        return {
            tag: { 'type': 'array', 'itemType': DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTagsTag },
        };
    }
}
exports.DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTags = DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTags;
class DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            tags: 'Tags',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            tags: DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTagTags,
        };
    }
}
exports.DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTag = DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTag;
class DescribeDBInstanceByTagsResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceTag: 'DBInstanceTag',
        };
    }
    static types() {
        return {
            DBInstanceTag: { 'type': 'array', 'itemType': DescribeDBInstanceByTagsResponseBodyItemsDBInstanceTag },
        };
    }
}
exports.DescribeDBInstanceByTagsResponseBodyItems = DescribeDBInstanceByTagsResponseBodyItems;
class DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliasName: 'AliasName',
            creator: 'Creator',
            deleteDate: 'DeleteDate',
            description: 'Description',
            encryptionKey: 'EncryptionKey',
            encryptionKeyStatus: 'EncryptionKeyStatus',
            keyType: 'KeyType',
            keyUsage: 'KeyUsage',
            materialExpireTime: 'MaterialExpireTime',
            origin: 'Origin',
            usedBy: 'UsedBy',
        };
    }
    static types() {
        return {
            aliasName: 'string',
            creator: 'string',
            deleteDate: 'string',
            description: 'string',
            encryptionKey: 'string',
            encryptionKeyStatus: 'string',
            keyType: 'string',
            keyUsage: 'string',
            materialExpireTime: 'string',
            origin: 'string',
            usedBy: 'string',
        };
    }
}
exports.DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList = DescribeDBInstanceEncryptionKeyResponseBodyEncryptionKeyList;
class DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectionString: 'ConnectionString',
            ipAddress: 'IpAddress',
            ipType: 'IpType',
            port: 'Port',
            vSwitchId: 'VSwitchId',
            vpcId: 'VpcId',
        };
    }
    static types() {
        return {
            connectionString: 'string',
            ipAddress: 'string',
            ipType: 'string',
            port: 'string',
            vSwitchId: 'string',
            vpcId: 'string',
        };
    }
}
exports.DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem = DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem;
class DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            addressItem: 'AddressItem',
        };
    }
    static types() {
        return {
            addressItem: { 'type': 'array', 'itemType': DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItemsAddressItem },
        };
    }
}
exports.DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItems = DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItems;
class DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItemsNodeItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            nodeId: 'NodeId',
            weight: 'Weight',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            nodeId: 'string',
            weight: 'number',
        };
    }
}
exports.DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItemsNodeItem = DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItemsNodeItem;
class DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nodeItem: 'NodeItem',
        };
    }
    static types() {
        return {
            nodeItem: { 'type': 'array', 'itemType': DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItemsNodeItem },
        };
    }
}
exports.DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItems = DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItems;
class DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            addressItems: 'AddressItems',
            endpointDescription: 'EndpointDescription',
            endpointId: 'EndpointId',
            endpointType: 'EndpointType',
            nodeItems: 'NodeItems',
        };
    }
    static types() {
        return {
            addressItems: DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointAddressItems,
            endpointDescription: 'string',
            endpointId: 'string',
            endpointType: 'string',
            nodeItems: DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpointNodeItems,
        };
    }
}
exports.DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint = DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint;
class DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpoints extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceEndpoint: 'DBInstanceEndpoint',
        };
    }
    static types() {
        return {
            DBInstanceEndpoint: { 'type': 'array', 'itemType': DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpointsDBInstanceEndpoint },
        };
    }
}
exports.DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpoints = DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpoints;
class DescribeDBInstanceEndpointsResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceEndpoints: 'DBInstanceEndpoints',
            DBInstanceName: 'DBInstanceName',
            ipVersion: 'IpVersion',
        };
    }
    static types() {
        return {
            DBInstanceEndpoints: DescribeDBInstanceEndpointsResponseBodyDataDBInstanceEndpoints,
            DBInstanceName: 'string',
            ipVersion: 'string',
        };
    }
}
exports.DescribeDBInstanceEndpointsResponseBodyData = DescribeDBInstanceEndpointsResponseBodyData;
class DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataSyncTime: 'DataSyncTime',
            logSyncTime: 'LogSyncTime',
            nodeId: 'NodeId',
            nodeType: 'NodeType',
            regionId: 'RegionId',
            syncStatus: 'SyncStatus',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            dataSyncTime: 'string',
            logSyncTime: 'string',
            nodeId: 'string',
            nodeType: 'string',
            regionId: 'string',
            syncStatus: 'string',
            zoneId: 'string',
        };
    }
}
exports.DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo = DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo;
class DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nodeInfo: 'NodeInfo',
        };
    }
    static types() {
        return {
            nodeInfo: { 'type': 'array', 'itemType': DescribeDBInstanceHAConfigResponseBodyHostInstanceInfosNodeInfo },
        };
    }
}
exports.DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos = DescribeDBInstanceHAConfigResponseBodyHostInstanceInfos;
class DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceIPArrayAttribute: 'DBInstanceIPArrayAttribute',
            DBInstanceIPArrayName: 'DBInstanceIPArrayName',
            securityIPList: 'SecurityIPList',
            securityIPType: 'SecurityIPType',
        };
    }
    static types() {
        return {
            DBInstanceIPArrayAttribute: 'string',
            DBInstanceIPArrayName: 'string',
            securityIPList: 'string',
            securityIPType: 'string',
        };
    }
}
exports.DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray = DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray;
class DescribeDBInstanceIPArrayListResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceIPArray: 'DBInstanceIPArray',
        };
    }
    static types() {
        return {
            DBInstanceIPArray: { 'type': 'array', 'itemType': DescribeDBInstanceIPArrayListResponseBodyItemsDBInstanceIPArray },
        };
    }
}
exports.DescribeDBInstanceIPArrayListResponseBodyItems = DescribeDBInstanceIPArrayListResponseBodyItems;
class DescribeDBInstanceMetricsResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            dimension: 'Dimension',
            groupKey: 'GroupKey',
            groupKeyType: 'GroupKeyType',
            method: 'Method',
            metricsKey: 'MetricsKey',
            metricsKeyAlias: 'MetricsKeyAlias',
            sortRule: 'SortRule',
            unit: 'Unit',
        };
    }
    static types() {
        return {
            description: 'string',
            dimension: 'string',
            groupKey: 'string',
            groupKeyType: 'string',
            method: 'string',
            metricsKey: 'string',
            metricsKeyAlias: 'string',
            sortRule: 'number',
            unit: 'string',
        };
    }
}
exports.DescribeDBInstanceMetricsResponseBodyItems = DescribeDBInstanceMetricsResponseBodyItems;
class DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availability: 'Availability',
            DBInstanceId: 'DBInstanceId',
            DBInstanceType: 'DBInstanceType',
            role: 'Role',
            weight: 'Weight',
        };
    }
    static types() {
        return {
            availability: 'string',
            DBInstanceId: 'string',
            DBInstanceType: 'string',
            role: 'string',
            weight: 'string',
        };
    }
}
exports.DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight = DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight;
class DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceWeight: 'DBInstanceWeight',
        };
    }
    static types() {
        return {
            DBInstanceWeight: { 'type': 'array', 'itemType': DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight },
        };
    }
}
exports.DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights = DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights;
class DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            securityIPGroupName: 'SecurityIPGroupName',
            securityIPs: 'SecurityIPs',
        };
    }
    static types() {
        return {
            securityIPGroupName: 'string',
            securityIPs: 'string',
        };
    }
}
exports.DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup = DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup;
class DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            securityIPGroup: 'securityIPGroup',
        };
    }
    static types() {
        return {
            securityIPGroup: { 'type': 'array', 'itemType': DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup },
        };
    }
}
exports.DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups = DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups;
class DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            babelfishPort: 'BabelfishPort',
            connectionString: 'ConnectionString',
            connectionStringType: 'ConnectionStringType',
            DBInstanceWeights: 'DBInstanceWeights',
            distributionType: 'DistributionType',
            expiredTime: 'ExpiredTime',
            IPAddress: 'IPAddress',
            IPType: 'IPType',
            maxDelayTime: 'MaxDelayTime',
            PGBouncerPort: 'PGBouncerPort',
            port: 'Port',
            securityIPGroups: 'SecurityIPGroups',
            upgradeable: 'Upgradeable',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
        };
    }
    static types() {
        return {
            babelfishPort: 'string',
            connectionString: 'string',
            connectionStringType: 'string',
            DBInstanceWeights: DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights,
            distributionType: 'string',
            expiredTime: 'string',
            IPAddress: 'string',
            IPType: 'string',
            maxDelayTime: 'string',
            PGBouncerPort: 'string',
            port: 'string',
            securityIPGroups: DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups,
            upgradeable: 'string',
            VPCId: 'string',
            vSwitchId: 'string',
        };
    }
}
exports.DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo = DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo;
class DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceNetInfo: 'DBInstanceNetInfo',
        };
    }
    static types() {
        return {
            DBInstanceNetInfo: { 'type': 'array', 'itemType': DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfosDBInstanceNetInfo },
        };
    }
}
exports.DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos = DescribeDBInstanceNetInfoResponseBodyDBInstanceNetInfos;
class DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availability: 'Availability',
            DBInstanceId: 'DBInstanceId',
            DBInstanceType: 'DBInstanceType',
            weight: 'Weight',
        };
    }
    static types() {
        return {
            availability: 'string',
            DBInstanceId: 'string',
            DBInstanceType: 'string',
            weight: 'string',
        };
    }
}
exports.DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight = DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight;
class DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceWeight: 'DBInstanceWeight',
        };
    }
    static types() {
        return {
            DBInstanceWeight: { 'type': 'array', 'itemType': DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeightsDBInstanceWeight },
        };
    }
}
exports.DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights = DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights;
class DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            securityIPGroupName: 'SecurityIPGroupName',
            securityIPs: 'SecurityIPs',
        };
    }
    static types() {
        return {
            securityIPGroupName: 'string',
            securityIPs: 'string',
        };
    }
}
exports.DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup = DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup;
class DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            securityIPGroup: 'securityIPGroup',
        };
    }
    static types() {
        return {
            securityIPGroup: { 'type': 'array', 'itemType': DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroupsSecurityIPGroup },
        };
    }
}
exports.DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups = DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups;
class DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availability: 'Availability',
            connectionString: 'ConnectionString',
            connectionStringType: 'ConnectionStringType',
            DBInstanceWeights: 'DBInstanceWeights',
            distributionType: 'DistributionType',
            IPAddress: 'IPAddress',
            IPType: 'IPType',
            maxDelayTime: 'MaxDelayTime',
            port: 'Port',
            securityIPGroups: 'SecurityIPGroups',
            upgradeable: 'Upgradeable',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
            expiredTime: 'expiredTime',
        };
    }
    static types() {
        return {
            availability: 'string',
            connectionString: 'string',
            connectionStringType: 'string',
            DBInstanceWeights: DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoDBInstanceWeights,
            distributionType: 'string',
            IPAddress: 'string',
            IPType: 'string',
            maxDelayTime: 'string',
            port: 'string',
            securityIPGroups: DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfoSecurityIPGroups,
            upgradeable: 'string',
            VPCId: 'string',
            vSwitchId: 'string',
            expiredTime: 'string',
        };
    }
}
exports.DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo = DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo;
class DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfos extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceNetInfo: 'DBInstanceNetInfo',
        };
    }
    static types() {
        return {
            DBInstanceNetInfo: { 'type': 'array', 'itemType': DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfosDBInstanceNetInfo },
        };
    }
}
exports.DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfos = DescribeDBInstanceNetInfoForChannelResponseBodyDBInstanceNetInfos;
class DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'Date',
            value: 'Value',
        };
    }
    static types() {
        return {
            date: 'string',
            value: 'string',
        };
    }
}
exports.DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue = DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue;
class DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            performanceValue: 'PerformanceValue',
        };
    }
    static types() {
        return {
            performanceValue: { 'type': 'array', 'itemType': DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue },
        };
    }
}
exports.DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues = DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues;
class DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            unit: 'Unit',
            valueFormat: 'ValueFormat',
            values: 'Values',
        };
    }
    static types() {
        return {
            key: 'string',
            unit: 'string',
            valueFormat: 'string',
            values: DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKeyValues,
        };
    }
}
exports.DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey = DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey;
class DescribeDBInstancePerformanceResponseBodyPerformanceKeys extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            performanceKey: 'PerformanceKey',
        };
    }
    static types() {
        return {
            performanceKey: { 'type': 'array', 'itemType': DescribeDBInstancePerformanceResponseBodyPerformanceKeysPerformanceKey },
        };
    }
}
exports.DescribeDBInstancePerformanceResponseBodyPerformanceKeys = DescribeDBInstancePerformanceResponseBodyPerformanceKeys;
class DescribeDBInstanceTDEResponseBodyDatabasesDatabase extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBName: 'DBName',
            TDEStatus: 'TDEStatus',
        };
    }
    static types() {
        return {
            DBName: 'string',
            TDEStatus: 'string',
        };
    }
}
exports.DescribeDBInstanceTDEResponseBodyDatabasesDatabase = DescribeDBInstanceTDEResponseBodyDatabasesDatabase;
class DescribeDBInstanceTDEResponseBodyDatabases extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            database: 'Database',
        };
    }
    static types() {
        return {
            database: { 'type': 'array', 'itemType': DescribeDBInstanceTDEResponseBodyDatabasesDatabase },
        };
    }
}
exports.DescribeDBInstanceTDEResponseBodyDatabases = DescribeDBInstanceTDEResponseBodyDatabases;
class DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
        };
    }
}
exports.DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId = DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId;
class DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnlyDBInstanceId: 'ReadOnlyDBInstanceId',
        };
    }
    static types() {
        return {
            readOnlyDBInstanceId: { 'type': 'array', 'itemType': DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId },
        };
    }
}
exports.DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds = DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds;
class DescribeDBInstancesResponseBodyItemsDBInstance extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bpeEnabled: 'BpeEnabled',
            burstingEnabled: 'BurstingEnabled',
            category: 'Category',
            connectionMode: 'ConnectionMode',
            connectionString: 'ConnectionString',
            createTime: 'CreateTime',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceId: 'DBInstanceId',
            DBInstanceNetType: 'DBInstanceNetType',
            DBInstanceStatus: 'DBInstanceStatus',
            DBInstanceStorageType: 'DBInstanceStorageType',
            DBInstanceType: 'DBInstanceType',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            dedicatedHostGroupName: 'DedicatedHostGroupName',
            dedicatedHostIdForLog: 'DedicatedHostIdForLog',
            dedicatedHostIdForMaster: 'DedicatedHostIdForMaster',
            dedicatedHostIdForSlave: 'DedicatedHostIdForSlave',
            dedicatedHostNameForLog: 'DedicatedHostNameForLog',
            dedicatedHostNameForMaster: 'DedicatedHostNameForMaster',
            dedicatedHostNameForSlave: 'DedicatedHostNameForSlave',
            dedicatedHostZoneIdForLog: 'DedicatedHostZoneIdForLog',
            dedicatedHostZoneIdForMaster: 'DedicatedHostZoneIdForMaster',
            dedicatedHostZoneIdForSlave: 'DedicatedHostZoneIdForSlave',
            deletionProtection: 'DeletionProtection',
            destroyTime: 'DestroyTime',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            expireTime: 'ExpireTime',
            generalGroupName: 'GeneralGroupName',
            guardDBInstanceId: 'GuardDBInstanceId',
            instanceNetworkType: 'InstanceNetworkType',
            lockMode: 'LockMode',
            lockReason: 'LockReason',
            masterInstanceId: 'MasterInstanceId',
            mutriORsignle: 'MutriORsignle',
            payType: 'PayType',
            readOnlyDBInstanceIds: 'ReadOnlyDBInstanceIds',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            switchWeight: 'SwitchWeight',
            tempDBInstanceId: 'TempDBInstanceId',
            tips: 'Tips',
            tipsLevel: 'TipsLevel',
            vSwitchId: 'VSwitchId',
            vpcCloudInstanceId: 'VpcCloudInstanceId',
            vpcId: 'VpcId',
            vpcName: 'VpcName',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            bpeEnabled: 'string',
            burstingEnabled: 'boolean',
            category: 'string',
            connectionMode: 'string',
            connectionString: 'string',
            createTime: 'string',
            DBInstanceClass: 'string',
            DBInstanceDescription: 'string',
            DBInstanceId: 'string',
            DBInstanceNetType: 'string',
            DBInstanceStatus: 'string',
            DBInstanceStorageType: 'string',
            DBInstanceType: 'string',
            dedicatedHostGroupId: 'string',
            dedicatedHostGroupName: 'string',
            dedicatedHostIdForLog: 'string',
            dedicatedHostIdForMaster: 'string',
            dedicatedHostIdForSlave: 'string',
            dedicatedHostNameForLog: 'string',
            dedicatedHostNameForMaster: 'string',
            dedicatedHostNameForSlave: 'string',
            dedicatedHostZoneIdForLog: 'string',
            dedicatedHostZoneIdForMaster: 'string',
            dedicatedHostZoneIdForSlave: 'string',
            deletionProtection: 'boolean',
            destroyTime: 'string',
            engine: 'string',
            engineVersion: 'string',
            expireTime: 'string',
            generalGroupName: 'string',
            guardDBInstanceId: 'string',
            instanceNetworkType: 'string',
            lockMode: 'string',
            lockReason: 'string',
            masterInstanceId: 'string',
            mutriORsignle: 'boolean',
            payType: 'string',
            readOnlyDBInstanceIds: DescribeDBInstancesResponseBodyItemsDBInstanceReadOnlyDBInstanceIds,
            regionId: 'string',
            resourceGroupId: 'string',
            switchWeight: 'number',
            tempDBInstanceId: 'string',
            tips: 'string',
            tipsLevel: 'number',
            vSwitchId: 'string',
            vpcCloudInstanceId: 'string',
            vpcId: 'string',
            vpcName: 'string',
            zoneId: 'string',
        };
    }
}
exports.DescribeDBInstancesResponseBodyItemsDBInstance = DescribeDBInstancesResponseBodyItemsDBInstance;
class DescribeDBInstancesResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstance: 'DBInstance',
        };
    }
    static types() {
        return {
            DBInstance: { 'type': 'array', 'itemType': DescribeDBInstancesResponseBodyItemsDBInstance },
        };
    }
}
exports.DescribeDBInstancesResponseBodyItems = DescribeDBInstancesResponseBodyItems;
class DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttributeSlaveZones extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            slaveRegion: 'slaveRegion',
        };
    }
    static types() {
        return {
            slaveRegion: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttributeSlaveZones = DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttributeSlaveZones;
class DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountMaxQuantity: 'AccountMaxQuantity',
            accountType: 'AccountType',
            availabilityValue: 'AvailabilityValue',
            category: 'Category',
            connectionMode: 'ConnectionMode',
            connectionString: 'ConnectionString',
            creationTime: 'CreationTime',
            DBInstanceCPU: 'DBInstanceCPU',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceClassType: 'DBInstanceClassType',
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceId: 'DBInstanceId',
            DBInstanceMemory: 'DBInstanceMemory',
            DBInstanceNetType: 'DBInstanceNetType',
            DBInstanceStatus: 'DBInstanceStatus',
            DBInstanceStorage: 'DBInstanceStorage',
            DBInstanceType: 'DBInstanceType',
            DBMaxQuantity: 'DBMaxQuantity',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            expireTime: 'ExpireTime',
            exportKey: 'ExportKey',
            guardDBInstanceId: 'GuardDBInstanceId',
            incrementSourceDBInstanceId: 'IncrementSourceDBInstanceId',
            instanceNetworkType: 'InstanceNetworkType',
            lockMode: 'LockMode',
            lockReason: 'LockReason',
            maintainTime: 'MaintainTime',
            masterInstanceId: 'MasterInstanceId',
            maxConnections: 'MaxConnections',
            maxIOPS: 'MaxIOPS',
            payType: 'PayType',
            port: 'Port',
            readDelayTime: 'ReadDelayTime',
            regionId: 'RegionId',
            securityIPList: 'SecurityIPList',
            slaveZones: 'SlaveZones',
            supportUpgradeAccountType: 'SupportUpgradeAccountType',
            tags: 'Tags',
            tempDBInstanceId: 'TempDBInstanceId',
            vSwitchId: 'VSwitchId',
            vpcId: 'VpcId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            accountMaxQuantity: 'number',
            accountType: 'string',
            availabilityValue: 'string',
            category: 'string',
            connectionMode: 'string',
            connectionString: 'string',
            creationTime: 'string',
            DBInstanceCPU: 'string',
            DBInstanceClass: 'string',
            DBInstanceClassType: 'string',
            DBInstanceDescription: 'string',
            DBInstanceId: 'string',
            DBInstanceMemory: 'number',
            DBInstanceNetType: 'string',
            DBInstanceStatus: 'string',
            DBInstanceStorage: 'number',
            DBInstanceType: 'string',
            DBMaxQuantity: 'number',
            engine: 'string',
            engineVersion: 'string',
            expireTime: 'string',
            exportKey: 'string',
            guardDBInstanceId: 'string',
            incrementSourceDBInstanceId: 'string',
            instanceNetworkType: 'string',
            lockMode: 'string',
            lockReason: 'string',
            maintainTime: 'string',
            masterInstanceId: 'string',
            maxConnections: 'number',
            maxIOPS: 'number',
            payType: 'string',
            port: 'string',
            readDelayTime: 'string',
            regionId: 'string',
            securityIPList: 'string',
            slaveZones: DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttributeSlaveZones,
            supportUpgradeAccountType: 'string',
            tags: 'string',
            tempDBInstanceId: 'string',
            vSwitchId: 'string',
            vpcId: 'string',
            zoneId: 'string',
        };
    }
}
exports.DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute = DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute;
class DescribeDBInstancesAsCsvResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceAttribute: 'DBInstanceAttribute',
        };
    }
    static types() {
        return {
            DBInstanceAttribute: { 'type': 'array', 'itemType': DescribeDBInstancesAsCsvResponseBodyItemsDBInstanceAttribute },
        };
    }
}
exports.DescribeDBInstancesAsCsvResponseBodyItems = DescribeDBInstancesAsCsvResponseBodyItems;
class DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceId: 'DBInstanceId',
            DBInstanceStatus: 'DBInstanceStatus',
            expireTime: 'ExpireTime',
            lockMode: 'LockMode',
            payType: 'PayType',
        };
    }
    static types() {
        return {
            DBInstanceDescription: 'string',
            DBInstanceId: 'string',
            DBInstanceStatus: 'string',
            expireTime: 'string',
            lockMode: 'string',
            payType: 'string',
        };
    }
}
exports.DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime = DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime;
class DescribeDBInstancesByExpireTimeResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceExpireTime: 'DBInstanceExpireTime',
        };
    }
    static types() {
        return {
            DBInstanceExpireTime: { 'type': 'array', 'itemType': DescribeDBInstancesByExpireTimeResponseBodyItemsDBInstanceExpireTime },
        };
    }
}
exports.DescribeDBInstancesByExpireTimeResponseBodyItems = DescribeDBInstancesByExpireTimeResponseBodyItems;
class DescribeDBInstancesByPerformanceRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.DescribeDBInstancesByPerformanceRequestTag = DescribeDBInstancesByPerformanceRequestTag;
class DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            CPUUsage: 'CPUUsage',
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceId: 'DBInstanceId',
            diskUsage: 'DiskUsage',
            IOPSUsage: 'IOPSUsage',
            sessionUsage: 'SessionUsage',
        };
    }
    static types() {
        return {
            CPUUsage: 'string',
            DBInstanceDescription: 'string',
            DBInstanceId: 'string',
            diskUsage: 'string',
            IOPSUsage: 'string',
            sessionUsage: 'string',
        };
    }
}
exports.DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance = DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance;
class DescribeDBInstancesByPerformanceResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstancePerformance: 'DBInstancePerformance',
        };
    }
    static types() {
        return {
            DBInstancePerformance: { 'type': 'array', 'itemType': DescribeDBInstancesByPerformanceResponseBodyItemsDBInstancePerformance },
        };
    }
}
exports.DescribeDBInstancesByPerformanceResponseBodyItems = DescribeDBInstancesByPerformanceResponseBodyItems;
class DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
        };
    }
}
exports.DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId = DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId;
class DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnlyDBInstanceId: 'ReadOnlyDBInstanceId',
        };
    }
    static types() {
        return {
            readOnlyDBInstanceId: { 'type': 'array', 'itemType': DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIdsReadOnlyDBInstanceId },
        };
    }
}
exports.DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds = DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds;
class DescribeDBInstancesForCloneResponseBodyItemsDBInstance extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'Category',
            connectionMode: 'ConnectionMode',
            createTime: 'CreateTime',
            DBInstanceClass: 'DBInstanceClass',
            DBInstanceDescription: 'DBInstanceDescription',
            DBInstanceId: 'DBInstanceId',
            DBInstanceNetType: 'DBInstanceNetType',
            DBInstanceStatus: 'DBInstanceStatus',
            DBInstanceStorageType: 'DBInstanceStorageType',
            DBInstanceType: 'DBInstanceType',
            destroyTime: 'DestroyTime',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            expireTime: 'ExpireTime',
            guardDBInstanceId: 'GuardDBInstanceId',
            insId: 'InsId',
            instanceNetworkType: 'InstanceNetworkType',
            lockMode: 'LockMode',
            lockReason: 'LockReason',
            masterInstanceId: 'MasterInstanceId',
            mutriORsignle: 'MutriORsignle',
            payType: 'PayType',
            readOnlyDBInstanceIds: 'ReadOnlyDBInstanceIds',
            regionId: 'RegionId',
            replicateId: 'ReplicateId',
            resourceGroupId: 'ResourceGroupId',
            tempDBInstanceId: 'TempDBInstanceId',
            vSwitchId: 'VSwitchId',
            vpcCloudInstanceId: 'VpcCloudInstanceId',
            vpcId: 'VpcId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            category: 'string',
            connectionMode: 'string',
            createTime: 'string',
            DBInstanceClass: 'string',
            DBInstanceDescription: 'string',
            DBInstanceId: 'string',
            DBInstanceNetType: 'string',
            DBInstanceStatus: 'string',
            DBInstanceStorageType: 'string',
            DBInstanceType: 'string',
            destroyTime: 'string',
            engine: 'string',
            engineVersion: 'string',
            expireTime: 'string',
            guardDBInstanceId: 'string',
            insId: 'number',
            instanceNetworkType: 'string',
            lockMode: 'string',
            lockReason: 'string',
            masterInstanceId: 'string',
            mutriORsignle: 'boolean',
            payType: 'string',
            readOnlyDBInstanceIds: DescribeDBInstancesForCloneResponseBodyItemsDBInstanceReadOnlyDBInstanceIds,
            regionId: 'string',
            replicateId: 'string',
            resourceGroupId: 'string',
            tempDBInstanceId: 'string',
            vSwitchId: 'string',
            vpcCloudInstanceId: 'string',
            vpcId: 'string',
            zoneId: 'string',
        };
    }
}
exports.DescribeDBInstancesForCloneResponseBodyItemsDBInstance = DescribeDBInstancesForCloneResponseBodyItemsDBInstance;
class DescribeDBInstancesForCloneResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstance: 'DBInstance',
        };
    }
    static types() {
        return {
            DBInstance: { 'type': 'array', 'itemType': DescribeDBInstancesForCloneResponseBodyItemsDBInstance },
        };
    }
}
exports.DescribeDBInstancesForCloneResponseBodyItems = DescribeDBInstancesForCloneResponseBodyItems;
class DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            communityMinorVersion: 'CommunityMinorVersion',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            expireStatus: 'ExpireStatus',
            isHotfixVersion: 'IsHotfixVersion',
            minorVersion: 'MinorVersion',
            nodeType: 'NodeType',
            releaseNote: 'ReleaseNote',
            releaseType: 'ReleaseType',
            statusDesc: 'StatusDesc',
            tag: 'Tag',
        };
    }
    static types() {
        return {
            communityMinorVersion: 'string',
            engine: 'string',
            engineVersion: 'string',
            expireStatus: 'string',
            isHotfixVersion: 'boolean',
            minorVersion: 'string',
            nodeType: 'string',
            releaseNote: 'string',
            releaseType: 'string',
            statusDesc: 'string',
            tag: 'string',
        };
    }
}
exports.DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems = DescribeDBMiniEngineVersionsResponseBodyMinorVersionItems;
class DescribeDBProxyResponseBodyDBProxyAVZones extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBProxyAVZones: 'DBProxyAVZones',
        };
    }
    static types() {
        return {
            DBProxyAVZones: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeDBProxyResponseBodyDBProxyAVZones = DescribeDBProxyResponseBodyDBProxyAVZones;
class DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBProxyConnectString: 'DBProxyConnectString',
            DBProxyConnectStringNetType: 'DBProxyConnectStringNetType',
            DBProxyConnectStringNetWorkType: 'DBProxyConnectStringNetWorkType',
            DBProxyConnectStringPort: 'DBProxyConnectStringPort',
            DBProxyEndpointId: 'DBProxyEndpointId',
            DBProxyEndpointName: 'DBProxyEndpointName',
            DBProxyVpcId: 'DBProxyVpcId',
            DBProxyVpcInstanceId: 'DBProxyVpcInstanceId',
            DBProxyVswitchId: 'DBProxyVswitchId',
        };
    }
    static types() {
        return {
            DBProxyConnectString: 'string',
            DBProxyConnectStringNetType: 'string',
            DBProxyConnectStringNetWorkType: 'string',
            DBProxyConnectStringPort: 'string',
            DBProxyEndpointId: 'string',
            DBProxyEndpointName: 'string',
            DBProxyVpcId: 'string',
            DBProxyVpcInstanceId: 'string',
            DBProxyVswitchId: 'string',
        };
    }
}
exports.DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems = DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems;
class DescribeDBProxyResponseBodyDBProxyConnectStringItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBProxyConnectStringItems: 'DBProxyConnectStringItems',
        };
    }
    static types() {
        return {
            DBProxyConnectStringItems: { 'type': 'array', 'itemType': DescribeDBProxyResponseBodyDBProxyConnectStringItemsDBProxyConnectStringItems },
        };
    }
}
exports.DescribeDBProxyResponseBodyDBProxyConnectStringItems = DescribeDBProxyResponseBodyDBProxyConnectStringItems;
class DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dbProxyEndpointAliases: 'DbProxyEndpointAliases',
            dbProxyEndpointName: 'DbProxyEndpointName',
            dbProxyEndpointType: 'DbProxyEndpointType',
            dbProxyReadWriteMode: 'DbProxyReadWriteMode',
        };
    }
    static types() {
        return {
            dbProxyEndpointAliases: 'string',
            dbProxyEndpointName: 'string',
            dbProxyEndpointType: 'string',
            dbProxyReadWriteMode: 'string',
        };
    }
}
exports.DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems = DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems;
class DescribeDBProxyResponseBodyDbProxyEndpointItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dbProxyEndpointItems: 'DbProxyEndpointItems',
        };
    }
    static types() {
        return {
            dbProxyEndpointItems: { 'type': 'array', 'itemType': DescribeDBProxyResponseBodyDbProxyEndpointItemsDbProxyEndpointItems },
        };
    }
}
exports.DescribeDBProxyResponseBodyDbProxyEndpointItems = DescribeDBProxyResponseBodyDbProxyEndpointItems;
class DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dbProxyEndpointConnectString: 'DbProxyEndpointConnectString',
            dbProxyEndpointNetType: 'DbProxyEndpointNetType',
            dbProxyEndpointPort: 'DbProxyEndpointPort',
        };
    }
    static types() {
        return {
            dbProxyEndpointConnectString: 'string',
            dbProxyEndpointNetType: 'string',
            dbProxyEndpointPort: 'string',
        };
    }
}
exports.DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems = DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems;
class DescribeDBProxyEndpointResponseBodyEndpointConnectItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endpointConnectItems: 'EndpointConnectItems',
        };
    }
    static types() {
        return {
            endpointConnectItems: { 'type': 'array', 'itemType': DescribeDBProxyEndpointResponseBodyEndpointConnectItemsEndpointConnectItems },
        };
    }
}
exports.DescribeDBProxyEndpointResponseBodyEndpointConnectItems = DescribeDBProxyEndpointResponseBodyEndpointConnectItems;
class DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'Date',
            value: 'Value',
        };
    }
    static types() {
        return {
            date: 'string',
            value: 'string',
        };
    }
}
exports.DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue = DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue;
class DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            performanceValue: 'PerformanceValue',
        };
    }
    static types() {
        return {
            performanceValue: { 'type': 'array', 'itemType': DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValuesPerformanceValue },
        };
    }
}
exports.DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues = DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues;
class DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            valueFormat: 'ValueFormat',
            values: 'Values',
        };
    }
    static types() {
        return {
            key: 'string',
            valueFormat: 'string',
            values: DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKeyValues,
        };
    }
}
exports.DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey = DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey;
class DescribeDBProxyPerformanceResponseBodyPerformanceKeys extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            performanceKey: 'PerformanceKey',
        };
    }
    static types() {
        return {
            performanceKey: { 'type': 'array', 'itemType': DescribeDBProxyPerformanceResponseBodyPerformanceKeysPerformanceKey },
        };
    }
}
exports.DescribeDBProxyPerformanceResponseBodyPerformanceKeys = DescribeDBProxyPerformanceResponseBodyPerformanceKeys;
class DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            securityIpHosts: 'SecurityIpHosts',
            whitelistGroupName: 'WhitelistGroupName',
        };
    }
    static types() {
        return {
            securityIpHosts: 'string',
            whitelistGroupName: 'string',
        };
    }
}
exports.DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups = DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups;
class DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            whiteListGroups: 'WhiteListGroups',
        };
    }
    static types() {
        return {
            whiteListGroups: { 'type': 'array', 'itemType': DescribeDTCSecurityIpHostsForSQLServerResponseBodyItemsWhiteListGroups },
        };
    }
}
exports.DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems = DescribeDTCSecurityIpHostsForSQLServerResponseBodyItems;
class DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            account: 'Account',
            accountPrivilege: 'AccountPrivilege',
            accountPrivilegeDetail: 'AccountPrivilegeDetail',
        };
    }
    static types() {
        return {
            account: 'string',
            accountPrivilege: 'string',
            accountPrivilegeDetail: 'string',
        };
    }
}
exports.DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo = DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo;
class DescribeDatabasesResponseBodyDatabasesDatabaseAccounts extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountPrivilegeInfo: 'AccountPrivilegeInfo',
        };
    }
    static types() {
        return {
            accountPrivilegeInfo: { 'type': 'array', 'itemType': DescribeDatabasesResponseBodyDatabasesDatabaseAccountsAccountPrivilegeInfo },
        };
    }
}
exports.DescribeDatabasesResponseBodyDatabasesDatabaseAccounts = DescribeDatabasesResponseBodyDatabasesDatabaseAccounts;
class DescribeDatabasesResponseBodyDatabasesDatabaseAdvancedInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            advancedDbProperty: 'AdvancedDbProperty',
        };
    }
    static types() {
        return {
            advancedDbProperty: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
        };
    }
}
exports.DescribeDatabasesResponseBodyDatabasesDatabaseAdvancedInfo = DescribeDatabasesResponseBodyDatabasesDatabaseAdvancedInfo;
class DescribeDatabasesResponseBodyDatabasesDatabaseBasicInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            basicDbProperty: 'BasicDbProperty',
        };
    }
    static types() {
        return {
            basicDbProperty: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
        };
    }
}
exports.DescribeDatabasesResponseBodyDatabasesDatabaseBasicInfo = DescribeDatabasesResponseBodyDatabasesDatabaseBasicInfo;
class DescribeDatabasesResponseBodyDatabasesDatabaseRuntimeInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            runtimeDbProperty: 'RuntimeDbProperty',
        };
    }
    static types() {
        return {
            runtimeDbProperty: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
        };
    }
}
exports.DescribeDatabasesResponseBodyDatabasesDatabaseRuntimeInfo = DescribeDatabasesResponseBodyDatabasesDatabaseRuntimeInfo;
class DescribeDatabasesResponseBodyDatabasesDatabase extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accounts: 'Accounts',
            advancedInfo: 'AdvancedInfo',
            basicInfo: 'BasicInfo',
            characterSetName: 'CharacterSetName',
            collate: 'Collate',
            connLimit: 'ConnLimit',
            ctype: 'Ctype',
            DBDescription: 'DBDescription',
            DBInstanceId: 'DBInstanceId',
            DBName: 'DBName',
            DBStatus: 'DBStatus',
            engine: 'Engine',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            resourceGroupId: 'ResourceGroupId',
            runtimeInfo: 'RuntimeInfo',
            tablespace: 'Tablespace',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            accounts: DescribeDatabasesResponseBodyDatabasesDatabaseAccounts,
            advancedInfo: DescribeDatabasesResponseBodyDatabasesDatabaseAdvancedInfo,
            basicInfo: DescribeDatabasesResponseBodyDatabasesDatabaseBasicInfo,
            characterSetName: 'string',
            collate: 'string',
            connLimit: 'string',
            ctype: 'string',
            DBDescription: 'string',
            DBInstanceId: 'string',
            DBName: 'string',
            DBStatus: 'string',
            engine: 'string',
            pageNumber: 'number',
            pageSize: 'number',
            resourceGroupId: 'string',
            runtimeInfo: DescribeDatabasesResponseBodyDatabasesDatabaseRuntimeInfo,
            tablespace: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeDatabasesResponseBodyDatabasesDatabase = DescribeDatabasesResponseBodyDatabasesDatabase;
class DescribeDatabasesResponseBodyDatabases extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            database: 'Database',
        };
    }
    static types() {
        return {
            database: { 'type': 'array', 'itemType': DescribeDatabasesResponseBodyDatabasesDatabase },
        };
    }
}
exports.DescribeDatabasesResponseBodyDatabases = DescribeDatabasesResponseBodyDatabases;
class DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            zoneIDList: 'ZoneIDList',
        };
    }
    static types() {
        return {
            zoneIDList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList = DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList;
class DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            allocationPolicy: 'AllocationPolicy',
            bastionInstanceId: 'BastionInstanceId',
            cpuAllocateRation: 'CpuAllocateRation',
            cpuAllocatedAmount: 'CpuAllocatedAmount',
            cpuAllocationRatio: 'CpuAllocationRatio',
            createTime: 'CreateTime',
            dedicatedHostCountGroupByHostType: 'DedicatedHostCountGroupByHostType',
            dedicatedHostGroupDesc: 'DedicatedHostGroupDesc',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            diskAllocateRation: 'DiskAllocateRation',
            diskAllocatedAmount: 'DiskAllocatedAmount',
            diskAllocationRatio: 'DiskAllocationRatio',
            diskUsedAmount: 'DiskUsedAmount',
            diskUtility: 'DiskUtility',
            engine: 'Engine',
            hostNumber: 'HostNumber',
            hostReplacePolicy: 'HostReplacePolicy',
            instanceNumber: 'InstanceNumber',
            memAllocateRation: 'MemAllocateRation',
            memAllocatedAmount: 'MemAllocatedAmount',
            memAllocationRatio: 'MemAllocationRatio',
            memUsedAmount: 'MemUsedAmount',
            memUtility: 'MemUtility',
            openPermission: 'OpenPermission',
            text: 'Text',
            VPCId: 'VPCId',
            zoneIDList: 'ZoneIDList',
        };
    }
    static types() {
        return {
            allocationPolicy: 'string',
            bastionInstanceId: 'string',
            cpuAllocateRation: 'number',
            cpuAllocatedAmount: 'number',
            cpuAllocationRatio: 'number',
            createTime: 'string',
            dedicatedHostCountGroupByHostType: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            dedicatedHostGroupDesc: 'string',
            dedicatedHostGroupId: 'string',
            diskAllocateRation: 'number',
            diskAllocatedAmount: 'number',
            diskAllocationRatio: 'number',
            diskUsedAmount: 'number',
            diskUtility: 'number',
            engine: 'string',
            hostNumber: 'number',
            hostReplacePolicy: 'string',
            instanceNumber: 'number',
            memAllocateRation: 'number',
            memAllocatedAmount: 'number',
            memAllocationRatio: 'number',
            memUsedAmount: 'number',
            memUtility: 'number',
            openPermission: 'string',
            text: 'string',
            VPCId: 'string',
            zoneIDList: DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroupsZoneIDList,
        };
    }
}
exports.DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups = DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups;
class DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dedicatedHostGroups: 'DedicatedHostGroups',
        };
    }
    static types() {
        return {
            dedicatedHostGroups: { 'type': 'array', 'itemType': DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroupsDedicatedHostGroups },
        };
    }
}
exports.DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups = DescribeDedicatedHostGroupsResponseBodyDedicatedHostGroups;
class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountName: 'AccountName',
            allocationStatus: 'AllocationStatus',
            bastionInstanceId: 'BastionInstanceId',
            CPUAllocationRatio: 'CPUAllocationRatio',
            cpuUsed: 'CpuUsed',
            createdTime: 'CreatedTime',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            dedicatedHostId: 'DedicatedHostId',
            diskAllocationRatio: 'DiskAllocationRatio',
            endTime: 'EndTime',
            engine: 'Engine',
            hostCPU: 'HostCPU',
            hostClass: 'HostClass',
            hostMem: 'HostMem',
            hostName: 'HostName',
            hostStatus: 'HostStatus',
            hostStorage: 'HostStorage',
            hostType: 'HostType',
            IPAddress: 'IPAddress',
            imageCategory: 'ImageCategory',
            instanceNumber: 'InstanceNumber',
            memAllocationRatio: 'MemAllocationRatio',
            memoryUsed: 'MemoryUsed',
            openPermission: 'OpenPermission',
            storageUsed: 'StorageUsed',
            VPCId: 'VPCId',
            vSwitchId: 'VSwitchId',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            accountName: 'string',
            allocationStatus: 'string',
            bastionInstanceId: 'string',
            CPUAllocationRatio: 'string',
            cpuUsed: 'string',
            createdTime: 'string',
            dedicatedHostGroupId: 'string',
            dedicatedHostId: 'string',
            diskAllocationRatio: 'string',
            endTime: 'string',
            engine: 'string',
            hostCPU: 'string',
            hostClass: 'string',
            hostMem: 'string',
            hostName: 'string',
            hostStatus: 'string',
            hostStorage: 'string',
            hostType: 'string',
            IPAddress: 'string',
            imageCategory: 'string',
            instanceNumber: 'string',
            memAllocationRatio: 'string',
            memoryUsed: 'string',
            openPermission: 'string',
            storageUsed: 'string',
            VPCId: 'string',
            vSwitchId: 'string',
            zoneId: 'string',
        };
    }
}
exports.DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts = DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts;
class DescribeDedicatedHostsResponseBodyDedicatedHosts extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dedicatedHosts: 'DedicatedHosts',
        };
    }
    static types() {
        return {
            dedicatedHosts: { 'type': 'array', 'itemType': DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHosts },
        };
    }
}
exports.DescribeDedicatedHostsResponseBodyDedicatedHosts = DescribeDedicatedHostsResponseBodyDedicatedHosts;
class DescribeDetachedBackupsResponseBodyItemsBackup extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupDownloadURL: 'BackupDownloadURL',
            backupEndTime: 'BackupEndTime',
            backupId: 'BackupId',
            backupIntranetDownloadURL: 'BackupIntranetDownloadURL',
            backupMethod: 'BackupMethod',
            backupMode: 'BackupMode',
            backupSize: 'BackupSize',
            backupStartTime: 'BackupStartTime',
            backupStatus: 'BackupStatus',
            backupType: 'BackupType',
            consistentTime: 'ConsistentTime',
            DBInstanceComment: 'DBInstanceComment',
            DBInstanceId: 'DBInstanceId',
            hostInstanceID: 'HostInstanceID',
            isAvail: 'IsAvail',
            metaStatus: 'MetaStatus',
            storeStatus: 'StoreStatus',
        };
    }
    static types() {
        return {
            backupDownloadURL: 'string',
            backupEndTime: 'string',
            backupId: 'string',
            backupIntranetDownloadURL: 'string',
            backupMethod: 'string',
            backupMode: 'string',
            backupSize: 'number',
            backupStartTime: 'string',
            backupStatus: 'string',
            backupType: 'string',
            consistentTime: 'number',
            DBInstanceComment: 'string',
            DBInstanceId: 'string',
            hostInstanceID: 'string',
            isAvail: 'number',
            metaStatus: 'string',
            storeStatus: 'string',
        };
    }
}
exports.DescribeDetachedBackupsResponseBodyItemsBackup = DescribeDetachedBackupsResponseBodyItemsBackup;
class DescribeDetachedBackupsResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backup: 'Backup',
        };
    }
    static types() {
        return {
            backup: { 'type': 'array', 'itemType': DescribeDetachedBackupsResponseBodyItemsBackup },
        };
    }
}
exports.DescribeDetachedBackupsResponseBodyItems = DescribeDetachedBackupsResponseBodyItems;
class DescribeDiagnosticReportListResponseBodyReportList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            diagnosticTime: 'DiagnosticTime',
            downloadURL: 'DownloadURL',
            endTime: 'EndTime',
            score: 'Score',
            startTime: 'StartTime',
        };
    }
    static types() {
        return {
            diagnosticTime: 'string',
            downloadURL: 'string',
            endTime: 'string',
            score: 'number',
            startTime: 'string',
        };
    }
}
exports.DescribeDiagnosticReportListResponseBodyReportList = DescribeDiagnosticReportListResponseBodyReportList;
class DescribeErrorLogsResponseBodyItemsErrorLog extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'CreateTime',
            errorInfo: 'ErrorInfo',
        };
    }
    static types() {
        return {
            createTime: 'string',
            errorInfo: 'string',
        };
    }
}
exports.DescribeErrorLogsResponseBodyItemsErrorLog = DescribeErrorLogsResponseBodyItemsErrorLog;
class DescribeErrorLogsResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorLog: 'ErrorLog',
        };
    }
    static types() {
        return {
            errorLog: { 'type': 'array', 'itemType': DescribeErrorLogsResponseBodyItemsErrorLog },
        };
    }
}
exports.DescribeErrorLogsResponseBodyItems = DescribeErrorLogsResponseBodyItems;
class DescribeEventsResponseBodyEventItemsEventItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            callerUid: 'CallerUid',
            eventId: 'EventId',
            eventName: 'EventName',
            eventPayload: 'EventPayload',
            eventReason: 'EventReason',
            eventRecordTime: 'EventRecordTime',
            eventTime: 'EventTime',
            eventType: 'EventType',
            eventUserType: 'EventUserType',
            regionId: 'RegionId',
            resourceName: 'ResourceName',
            resourceType: 'ResourceType',
        };
    }
    static types() {
        return {
            callerUid: 'number',
            eventId: 'number',
            eventName: 'string',
            eventPayload: 'string',
            eventReason: 'string',
            eventRecordTime: 'string',
            eventTime: 'string',
            eventType: 'string',
            eventUserType: 'string',
            regionId: 'string',
            resourceName: 'string',
            resourceType: 'string',
        };
    }
}
exports.DescribeEventsResponseBodyEventItemsEventItems = DescribeEventsResponseBodyEventItemsEventItems;
class DescribeEventsResponseBodyEventItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eventItems: 'EventItems',
        };
    }
    static types() {
        return {
            eventItems: { 'type': 'array', 'itemType': DescribeEventsResponseBodyEventItemsEventItems },
        };
    }
}
exports.DescribeEventsResponseBodyEventItems = DescribeEventsResponseBodyEventItems;
class DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceID: 'DBInstanceID',
            dtsInstance: 'DtsInstance',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            regionId: 'RegionId',
            resourceGroupId: 'ResourceGroupId',
            role: 'Role',
            status: 'Status',
        };
    }
    static types() {
        return {
            DBInstanceID: 'string',
            dtsInstance: 'string',
            engine: 'string',
            engineVersion: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            role: 'string',
            status: 'string',
        };
    }
}
exports.DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers = DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers;
class DescribeGadInstancesResponseBodyGadInstances extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            creationTime: 'CreationTime',
            description: 'Description',
            gadInstanceMembers: 'GadInstanceMembers',
            gadInstanceName: 'GadInstanceName',
            modificationTime: 'ModificationTime',
            service: 'Service',
            status: 'Status',
        };
    }
    static types() {
        return {
            creationTime: 'string',
            description: 'string',
            gadInstanceMembers: { 'type': 'array', 'itemType': DescribeGadInstancesResponseBodyGadInstancesGadInstanceMembers },
            gadInstanceName: 'string',
            modificationTime: 'string',
            service: 'string',
            status: 'string',
        };
    }
}
exports.DescribeGadInstancesResponseBodyGadInstances = DescribeGadInstancesResponseBodyGadInstances;
class DescribeHistoryEventsResponseBodyItemsData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cmsProduct: 'CmsProduct',
            dbType: 'DbType',
            detailImpact: 'DetailImpact',
            detailReason: 'DetailReason',
            endTime: 'EndTime',
            eventCategory: 'EventCategory',
            eventCode: 'EventCode',
            eventDetail: 'EventDetail',
            eventId: 'EventId',
            eventImpact: 'EventImpact',
            eventLevel: 'EventLevel',
            eventReason: 'EventReason',
            eventStatus: 'EventStatus',
            eventType: 'EventType',
            gmtCreated: 'GmtCreated',
            gmtModified: 'GmtModified',
            handleStatus: 'HandleStatus',
            hasLifeCycle: 'HasLifeCycle',
            instanceId: 'InstanceId',
            instanceName: 'InstanceName',
            isClosed: 'IsClosed',
            product: 'Product',
            regionId: 'RegionId',
            resourceType: 'ResourceType',
            sourceType: 'SourceType',
            startTime: 'StartTime',
            uid: 'Uid',
        };
    }
    static types() {
        return {
            cmsProduct: 'string',
            dbType: 'string',
            detailImpact: 'string',
            detailReason: 'string',
            endTime: 'string',
            eventCategory: 'string',
            eventCode: 'string',
            eventDetail: 'string',
            eventId: 'string',
            eventImpact: 'string',
            eventLevel: 'string',
            eventReason: 'string',
            eventStatus: 'string',
            eventType: 'string',
            gmtCreated: 'string',
            gmtModified: 'string',
            handleStatus: 'string',
            hasLifeCycle: 'number',
            instanceId: 'string',
            instanceName: 'string',
            isClosed: 'number',
            product: 'string',
            regionId: 'string',
            resourceType: 'string',
            sourceType: 'string',
            startTime: 'string',
            uid: 'string',
        };
    }
}
exports.DescribeHistoryEventsResponseBodyItemsData = DescribeHistoryEventsResponseBodyItemsData;
class DescribeHistoryEventsResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'Data',
            id: 'Id',
            region: 'Region',
            source: 'Source',
            specversion: 'Specversion',
            subject: 'Subject',
            time: 'Time',
            type: 'Type',
        };
    }
    static types() {
        return {
            data: DescribeHistoryEventsResponseBodyItemsData,
            id: 'string',
            region: 'string',
            source: 'string',
            specversion: 'string',
            subject: 'string',
            time: 'string',
            type: 'string',
        };
    }
}
exports.DescribeHistoryEventsResponseBodyItems = DescribeHistoryEventsResponseBodyItems;
class DescribeHistoryEventsStatResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eventCategory: 'EventCategory',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            eventCategory: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeHistoryEventsStatResponseBodyItems = DescribeHistoryEventsStatResponseBodyItems;
class DescribeHistoryTasksResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionInfo: 'ActionInfo',
            callerSource: 'CallerSource',
            callerUid: 'CallerUid',
            currentStepName: 'CurrentStepName',
            dbType: 'DbType',
            endTime: 'EndTime',
            instanceId: 'InstanceId',
            instanceName: 'InstanceName',
            instanceType: 'InstanceType',
            product: 'Product',
            progress: 'Progress',
            reasonCode: 'ReasonCode',
            regionId: 'RegionId',
            remainTime: 'RemainTime',
            startTime: 'StartTime',
            status: 'Status',
            taskDetail: 'TaskDetail',
            taskId: 'TaskId',
            taskType: 'TaskType',
            uid: 'Uid',
        };
    }
    static types() {
        return {
            actionInfo: 'string',
            callerSource: 'string',
            callerUid: 'string',
            currentStepName: 'string',
            dbType: 'string',
            endTime: 'string',
            instanceId: 'string',
            instanceName: 'string',
            instanceType: 'string',
            product: 'string',
            progress: 'number',
            reasonCode: 'string',
            regionId: 'string',
            remainTime: 'number',
            startTime: 'string',
            status: 'string',
            taskDetail: 'string',
            taskId: 'string',
            taskType: 'string',
            uid: 'string',
        };
    }
}
exports.DescribeHistoryTasksResponseBodyItems = DescribeHistoryTasksResponseBodyItems;
class DescribeHistoryTasksStatResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            status: 'Status',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            status: 'string',
            totalCount: 'number',
        };
    }
}
exports.DescribeHistoryTasksStatResponseBodyItems = DescribeHistoryTasksStatResponseBodyItems;
class DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoRenew: 'AutoRenew',
            DBInstanceId: 'DBInstanceId',
            duration: 'Duration',
            regionId: 'RegionId',
            status: 'Status',
        };
    }
    static types() {
        return {
            autoRenew: 'string',
            DBInstanceId: 'string',
            duration: 'number',
            regionId: 'string',
            status: 'string',
        };
    }
}
exports.DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem = DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem;
class DescribeInstanceAutoRenewalAttributeResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'Item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': DescribeInstanceAutoRenewalAttributeResponseBodyItemsItem },
        };
    }
}
exports.DescribeInstanceAutoRenewalAttributeResponseBodyItems = DescribeInstanceAutoRenewalAttributeResponseBodyItems;
class DescribeInstanceKeywordsResponseBodyWords extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            word: 'word',
        };
    }
    static types() {
        return {
            word: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeInstanceKeywordsResponseBodyWords = DescribeInstanceKeywordsResponseBodyWords;
class DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'Id',
            ips: 'Ips',
            templateId: 'TemplateId',
            templateName: 'TemplateName',
            userId: 'UserId',
        };
    }
    static types() {
        return {
            id: 'number',
            ips: 'string',
            templateId: 'number',
            templateName: 'string',
            userId: 'number',
        };
    }
}
exports.DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates = DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates;
class DescribeInstanceLinkedWhitelistTemplateResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            insName: 'InsName',
            templates: 'Templates',
        };
    }
    static types() {
        return {
            insName: 'string',
            templates: { 'type': 'array', 'itemType': DescribeInstanceLinkedWhitelistTemplateResponseBodyDataTemplates },
        };
    }
}
exports.DescribeInstanceLinkedWhitelistTemplateResponseBodyData = DescribeInstanceLinkedWhitelistTemplateResponseBodyData;
class DescribeLogBackupFilesResponseBodyItemsBinLogFile extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            downloadLink: 'DownloadLink',
            fileSize: 'FileSize',
            intranetDownloadLink: 'IntranetDownloadLink',
            linkExpiredTime: 'LinkExpiredTime',
            logBeginTime: 'LogBeginTime',
            logEndTime: 'LogEndTime',
        };
    }
    static types() {
        return {
            downloadLink: 'string',
            fileSize: 'number',
            intranetDownloadLink: 'string',
            linkExpiredTime: 'string',
            logBeginTime: 'string',
            logEndTime: 'string',
        };
    }
}
exports.DescribeLogBackupFilesResponseBodyItemsBinLogFile = DescribeLogBackupFilesResponseBodyItemsBinLogFile;
class DescribeLogBackupFilesResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            binLogFile: 'BinLogFile',
        };
    }
    static types() {
        return {
            binLogFile: { 'type': 'array', 'itemType': DescribeLogBackupFilesResponseBodyItemsBinLogFile },
        };
    }
}
exports.DescribeLogBackupFilesResponseBodyItems = DescribeLogBackupFilesResponseBodyItems;
class DescribeMarketingActivityResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'Category',
            chargeType: 'ChargeType',
            classCode: 'ClassCode',
            classGroup: 'ClassGroup',
            cpu: 'Cpu',
            diskSize: 'DiskSize',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            instanceId: 'InstanceId',
            instanceName: 'InstanceName',
            maxConnections: 'MaxConnections',
            maxIombps: 'MaxIombps',
            maxIops: 'MaxIops',
            memory: 'Memory',
            storageType: 'StorageType',
            upgradeCategory: 'UpgradeCategory',
            upgradeClassCode: 'UpgradeClassCode',
            upgradeClassGroup: 'UpgradeClassGroup',
            upgradeCpu: 'UpgradeCpu',
            upgradeDescContent: 'UpgradeDescContent',
            upgradeDiskSize: 'UpgradeDiskSize',
            upgradeMaxConnections: 'UpgradeMaxConnections',
            upgradeMaxIombps: 'UpgradeMaxIombps',
            upgradeMaxIops: 'UpgradeMaxIops',
            upgradeMemory: 'UpgradeMemory',
            upgradeReferencePrice: 'UpgradeReferencePrice',
            upgradeStorageType: 'UpgradeStorageType',
        };
    }
    static types() {
        return {
            category: 'string',
            chargeType: 'string',
            classCode: 'string',
            classGroup: 'string',
            cpu: 'string',
            diskSize: 'number',
            engine: 'string',
            engineVersion: 'string',
            instanceId: 'string',
            instanceName: 'string',
            maxConnections: 'number',
            maxIombps: 'number',
            maxIops: 'number',
            memory: 'number',
            storageType: 'string',
            upgradeCategory: 'string',
            upgradeClassCode: 'string',
            upgradeClassGroup: 'string',
            upgradeCpu: 'string',
            upgradeDescContent: 'string',
            upgradeDiskSize: 'number',
            upgradeMaxConnections: 'number',
            upgradeMaxIombps: 'number',
            upgradeMaxIops: 'number',
            upgradeMemory: 'number',
            upgradeReferencePrice: 'string',
            upgradeStorageType: 'string',
        };
    }
}
exports.DescribeMarketingActivityResponseBodyItems = DescribeMarketingActivityResponseBodyItems;
class DescribeMetaListResponseBodyItemsMeta extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            database: 'Database',
            size: 'Size',
            tables: 'Tables',
        };
    }
    static types() {
        return {
            database: 'string',
            size: 'string',
            tables: 'string',
        };
    }
}
exports.DescribeMetaListResponseBodyItemsMeta = DescribeMetaListResponseBodyItemsMeta;
class DescribeMetaListResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            meta: 'Meta',
        };
    }
    static types() {
        return {
            meta: { 'type': 'array', 'itemType': DescribeMetaListResponseBodyItemsMeta },
        };
    }
}
exports.DescribeMetaListResponseBodyItems = DescribeMetaListResponseBodyItems;
class DescribeMigrateTasksResponseBodyItemsMigrateTask extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupMode: 'BackupMode',
            createTime: 'CreateTime',
            DBName: 'DBName',
            description: 'Description',
            endTime: 'EndTime',
            isDBReplaced: 'IsDBReplaced',
            migrateTaskId: 'MigrateTaskId',
            status: 'Status',
        };
    }
    static types() {
        return {
            backupMode: 'string',
            createTime: 'string',
            DBName: 'string',
            description: 'string',
            endTime: 'string',
            isDBReplaced: 'string',
            migrateTaskId: 'string',
            status: 'string',
        };
    }
}
exports.DescribeMigrateTasksResponseBodyItemsMigrateTask = DescribeMigrateTasksResponseBodyItemsMigrateTask;
class DescribeMigrateTasksResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            migrateTask: 'MigrateTask',
        };
    }
    static types() {
        return {
            migrateTask: { 'type': 'array', 'itemType': DescribeMigrateTasksResponseBodyItemsMigrateTask },
        };
    }
}
exports.DescribeMigrateTasksResponseBodyItems = DescribeMigrateTasksResponseBodyItems;
class DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            address: 'Address',
            database: 'Database',
            mask: 'Mask',
            method: 'Method',
            option: 'Option',
            priorityId: 'PriorityId',
            type: 'Type',
            user: 'User',
        };
    }
    static types() {
        return {
            address: 'string',
            database: 'string',
            mask: 'string',
            method: 'string',
            option: 'string',
            priorityId: 'number',
            type: 'string',
            user: 'string',
        };
    }
}
exports.DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem = DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem;
class DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hbaItem: 'HbaItem',
        };
    }
    static types() {
        return {
            hbaItem: { 'type': 'array', 'itemType': DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItemsHbaItem },
        };
    }
}
exports.DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItems = DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItems;
class DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            address: 'Address',
            database: 'Database',
            mask: 'Mask',
            method: 'Method',
            option: 'Option',
            priorityId: 'PriorityId',
            type: 'Type',
            user: 'User',
        };
    }
    static types() {
        return {
            address: 'string',
            database: 'string',
            mask: 'string',
            method: 'string',
            option: 'string',
            priorityId: 'number',
            type: 'string',
            user: 'string',
        };
    }
}
exports.DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem = DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem;
class DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hbaItem: 'HbaItem',
        };
    }
    static types() {
        return {
            hbaItem: { 'type': 'array', 'itemType': DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItemsHbaItem },
        };
    }
}
exports.DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItems = DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItems;
class DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            afterHbaItems: 'AfterHbaItems',
            beforeHbaItems: 'BeforeHbaItems',
            modifyStatus: 'ModifyStatus',
            modifyTime: 'ModifyTime',
            statusReason: 'StatusReason',
        };
    }
    static types() {
        return {
            afterHbaItems: DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemAfterHbaItems,
            beforeHbaItems: DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItemBeforeHbaItems,
            modifyStatus: 'string',
            modifyTime: 'string',
            statusReason: 'string',
        };
    }
}
exports.DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem = DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem;
class DescribeModifyPGHbaConfigLogResponseBodyHbaLogItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hbaLogItem: 'HbaLogItem',
        };
    }
    static types() {
        return {
            hbaLogItem: { 'type': 'array', 'itemType': DescribeModifyPGHbaConfigLogResponseBodyHbaLogItemsHbaLogItem },
        };
    }
}
exports.DescribeModifyPGHbaConfigLogResponseBodyHbaLogItems = DescribeModifyPGHbaConfigLogResponseBodyHbaLogItems;
class DescribeModifyParameterLogResponseBodyItemsParameterChangeLog extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            modifyTime: 'ModifyTime',
            newParameterValue: 'NewParameterValue',
            oldParameterValue: 'OldParameterValue',
            parameterName: 'ParameterName',
            status: 'Status',
        };
    }
    static types() {
        return {
            modifyTime: 'string',
            newParameterValue: 'string',
            oldParameterValue: 'string',
            parameterName: 'string',
            status: 'string',
        };
    }
}
exports.DescribeModifyParameterLogResponseBodyItemsParameterChangeLog = DescribeModifyParameterLogResponseBodyItemsParameterChangeLog;
class DescribeModifyParameterLogResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            parameterChangeLog: 'ParameterChangeLog',
        };
    }
    static types() {
        return {
            parameterChangeLog: { 'type': 'array', 'itemType': DescribeModifyParameterLogResponseBodyItemsParameterChangeLog },
        };
    }
}
exports.DescribeModifyParameterLogResponseBodyItems = DescribeModifyParameterLogResponseBodyItems;
class DescribeOssDownloadsResponseBodyItemsOssDownload extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupMode: 'BackupMode',
            createTime: 'CreateTime',
            description: 'Description',
            endTime: 'EndTime',
            fileName: 'FileName',
            fileSize: 'FileSize',
            isAvailable: 'IsAvailable',
            status: 'Status',
        };
    }
    static types() {
        return {
            backupMode: 'string',
            createTime: 'string',
            description: 'string',
            endTime: 'string',
            fileName: 'string',
            fileSize: 'string',
            isAvailable: 'string',
            status: 'string',
        };
    }
}
exports.DescribeOssDownloadsResponseBodyItemsOssDownload = DescribeOssDownloadsResponseBodyItemsOssDownload;
class DescribeOssDownloadsResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ossDownload: 'OssDownload',
        };
    }
    static types() {
        return {
            ossDownload: { 'type': 'array', 'itemType': DescribeOssDownloadsResponseBodyItemsOssDownload },
        };
    }
}
exports.DescribeOssDownloadsResponseBodyItems = DescribeOssDownloadsResponseBodyItems;
class DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            address: 'Address',
            database: 'Database',
            mask: 'Mask',
            method: 'Method',
            option: 'Option',
            priorityId: 'PriorityId',
            type: 'Type',
            user: 'User',
        };
    }
    static types() {
        return {
            address: 'string',
            database: 'string',
            mask: 'string',
            method: 'string',
            option: 'string',
            priorityId: 'number',
            type: 'string',
            user: 'string',
        };
    }
}
exports.DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem = DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem;
class DescribePGHbaConfigResponseBodyDefaultHbaItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hbaItem: 'HbaItem',
        };
    }
    static types() {
        return {
            hbaItem: { 'type': 'array', 'itemType': DescribePGHbaConfigResponseBodyDefaultHbaItemsHbaItem },
        };
    }
}
exports.DescribePGHbaConfigResponseBodyDefaultHbaItems = DescribePGHbaConfigResponseBodyDefaultHbaItems;
class DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            address: 'Address',
            database: 'Database',
            mask: 'Mask',
            method: 'Method',
            option: 'Option',
            priorityId: 'PriorityId',
            type: 'Type',
            user: 'User',
        };
    }
    static types() {
        return {
            address: 'string',
            database: 'string',
            mask: 'string',
            method: 'string',
            option: 'string',
            priorityId: 'number',
            type: 'string',
            user: 'string',
        };
    }
}
exports.DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem = DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem;
class DescribePGHbaConfigResponseBodyRunningHbaItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hbaItem: 'HbaItem',
        };
    }
    static types() {
        return {
            hbaItem: { 'type': 'array', 'itemType': DescribePGHbaConfigResponseBodyRunningHbaItemsHbaItem },
        };
    }
}
exports.DescribePGHbaConfigResponseBodyRunningHbaItems = DescribePGHbaConfigResponseBodyRunningHbaItems;
class DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            paramName: 'ParamName',
            paramValue: 'ParamValue',
        };
    }
    static types() {
        return {
            paramName: 'string',
            paramValue: 'string',
        };
    }
}
exports.DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail = DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail;
class DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            parameterDetail: 'ParameterDetail',
        };
    }
    static types() {
        return {
            parameterDetail: { 'type': 'array', 'itemType': DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetailParameterDetail },
        };
    }
}
exports.DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail = DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail;
class DescribeParameterGroupResponseBodyParamGroupParameterGroup extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'CreateTime',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            forceRestart: 'ForceRestart',
            paramCounts: 'ParamCounts',
            paramDetail: 'ParamDetail',
            parameterGroupDesc: 'ParameterGroupDesc',
            parameterGroupId: 'ParameterGroupId',
            parameterGroupName: 'ParameterGroupName',
            parameterGroupType: 'ParameterGroupType',
            updateTime: 'UpdateTime',
        };
    }
    static types() {
        return {
            createTime: 'string',
            engine: 'string',
            engineVersion: 'string',
            forceRestart: 'number',
            paramCounts: 'number',
            paramDetail: DescribeParameterGroupResponseBodyParamGroupParameterGroupParamDetail,
            parameterGroupDesc: 'string',
            parameterGroupId: 'string',
            parameterGroupName: 'string',
            parameterGroupType: 'number',
            updateTime: 'string',
        };
    }
}
exports.DescribeParameterGroupResponseBodyParamGroupParameterGroup = DescribeParameterGroupResponseBodyParamGroupParameterGroup;
class DescribeParameterGroupResponseBodyParamGroup extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            parameterGroup: 'ParameterGroup',
        };
    }
    static types() {
        return {
            parameterGroup: { 'type': 'array', 'itemType': DescribeParameterGroupResponseBodyParamGroupParameterGroup },
        };
    }
}
exports.DescribeParameterGroupResponseBodyParamGroup = DescribeParameterGroupResponseBodyParamGroup;
class DescribeParameterGroupResponseBodyRelatedCustinsInfoRelatedCustinsInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appliedTime: 'AppliedTime',
            DBInstanceName: 'DBInstanceName',
        };
    }
    static types() {
        return {
            appliedTime: 'string',
            DBInstanceName: 'string',
        };
    }
}
exports.DescribeParameterGroupResponseBodyRelatedCustinsInfoRelatedCustinsInfo = DescribeParameterGroupResponseBodyRelatedCustinsInfoRelatedCustinsInfo;
class DescribeParameterGroupResponseBodyRelatedCustinsInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            relatedCustinsInfo: 'RelatedCustinsInfo',
        };
    }
    static types() {
        return {
            relatedCustinsInfo: { 'type': 'array', 'itemType': DescribeParameterGroupResponseBodyRelatedCustinsInfoRelatedCustinsInfo },
        };
    }
}
exports.DescribeParameterGroupResponseBodyRelatedCustinsInfo = DescribeParameterGroupResponseBodyRelatedCustinsInfo;
class DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'CreateTime',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            forceRestart: 'ForceRestart',
            paramCounts: 'ParamCounts',
            parameterGroupDesc: 'ParameterGroupDesc',
            parameterGroupId: 'ParameterGroupId',
            parameterGroupName: 'ParameterGroupName',
            parameterGroupType: 'ParameterGroupType',
            updateTime: 'UpdateTime',
        };
    }
    static types() {
        return {
            createTime: 'string',
            engine: 'string',
            engineVersion: 'string',
            forceRestart: 'number',
            paramCounts: 'number',
            parameterGroupDesc: 'string',
            parameterGroupId: 'string',
            parameterGroupName: 'string',
            parameterGroupType: 'number',
            updateTime: 'string',
        };
    }
}
exports.DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup = DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup;
class DescribeParameterGroupsResponseBodyParameterGroups extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            parameterGroup: 'ParameterGroup',
        };
    }
    static types() {
        return {
            parameterGroup: { 'type': 'array', 'itemType': DescribeParameterGroupsResponseBodyParameterGroupsParameterGroup },
        };
    }
}
exports.DescribeParameterGroupsResponseBodyParameterGroups = DescribeParameterGroupsResponseBodyParameterGroups;
class DescribeParameterTemplatesResponseBodyParametersTemplateRecord extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkingCode: 'CheckingCode',
            forceModify: 'ForceModify',
            forceRestart: 'ForceRestart',
            parameterDescription: 'ParameterDescription',
            parameterName: 'ParameterName',
            parameterValue: 'ParameterValue',
        };
    }
    static types() {
        return {
            checkingCode: 'string',
            forceModify: 'string',
            forceRestart: 'string',
            parameterDescription: 'string',
            parameterName: 'string',
            parameterValue: 'string',
        };
    }
}
exports.DescribeParameterTemplatesResponseBodyParametersTemplateRecord = DescribeParameterTemplatesResponseBodyParametersTemplateRecord;
class DescribeParameterTemplatesResponseBodyParameters extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            templateRecord: 'TemplateRecord',
        };
    }
    static types() {
        return {
            templateRecord: { 'type': 'array', 'itemType': DescribeParameterTemplatesResponseBodyParametersTemplateRecord },
        };
    }
}
exports.DescribeParameterTemplatesResponseBodyParameters = DescribeParameterTemplatesResponseBodyParameters;
class DescribeParametersResponseBodyConfigParametersDBInstanceParameter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            parameterDescription: 'ParameterDescription',
            parameterName: 'ParameterName',
            parameterValue: 'ParameterValue',
        };
    }
    static types() {
        return {
            parameterDescription: 'string',
            parameterName: 'string',
            parameterValue: 'string',
        };
    }
}
exports.DescribeParametersResponseBodyConfigParametersDBInstanceParameter = DescribeParametersResponseBodyConfigParametersDBInstanceParameter;
class DescribeParametersResponseBodyConfigParameters extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceParameter: 'DBInstanceParameter',
        };
    }
    static types() {
        return {
            DBInstanceParameter: { 'type': 'array', 'itemType': DescribeParametersResponseBodyConfigParametersDBInstanceParameter },
        };
    }
}
exports.DescribeParametersResponseBodyConfigParameters = DescribeParametersResponseBodyConfigParameters;
class DescribeParametersResponseBodyParamGroupInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            paramGroupId: 'ParamGroupId',
            parameterGroupDesc: 'ParameterGroupDesc',
            parameterGroupName: 'ParameterGroupName',
            parameterGroupType: 'ParameterGroupType',
        };
    }
    static types() {
        return {
            paramGroupId: 'string',
            parameterGroupDesc: 'string',
            parameterGroupName: 'string',
            parameterGroupType: 'string',
        };
    }
}
exports.DescribeParametersResponseBodyParamGroupInfo = DescribeParametersResponseBodyParamGroupInfo;
class DescribeParametersResponseBodyRunningParametersDBInstanceParameter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            parameterDescription: 'ParameterDescription',
            parameterName: 'ParameterName',
            parameterValue: 'ParameterValue',
        };
    }
    static types() {
        return {
            parameterDescription: 'string',
            parameterName: 'string',
            parameterValue: 'string',
        };
    }
}
exports.DescribeParametersResponseBodyRunningParametersDBInstanceParameter = DescribeParametersResponseBodyRunningParametersDBInstanceParameter;
class DescribeParametersResponseBodyRunningParameters extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceParameter: 'DBInstanceParameter',
        };
    }
    static types() {
        return {
            DBInstanceParameter: { 'type': 'array', 'itemType': DescribeParametersResponseBodyRunningParametersDBInstanceParameter },
        };
    }
}
exports.DescribeParametersResponseBodyRunningParameters = DescribeParametersResponseBodyRunningParameters;
class DescribePostgresExtensionsResponseBodyInstalledExtensions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'Category',
            comment: 'Comment',
            defaultVersion: 'DefaultVersion',
            installedVersion: 'InstalledVersion',
            name: 'Name',
            owner: 'Owner',
            priority: 'Priority',
            requires: 'Requires',
        };
    }
    static types() {
        return {
            category: 'string',
            comment: 'string',
            defaultVersion: 'string',
            installedVersion: 'string',
            name: 'string',
            owner: 'string',
            priority: 'string',
            requires: 'string',
        };
    }
}
exports.DescribePostgresExtensionsResponseBodyInstalledExtensions = DescribePostgresExtensionsResponseBodyInstalledExtensions;
class DescribePostgresExtensionsResponseBodyUninstalledExtensions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'Category',
            comment: 'Comment',
            defaultVersion: 'DefaultVersion',
            installedVersion: 'InstalledVersion',
            name: 'Name',
            owner: 'Owner',
            priority: 'Priority',
            requires: 'Requires',
        };
    }
    static types() {
        return {
            category: 'string',
            comment: 'string',
            defaultVersion: 'string',
            installedVersion: 'string',
            name: 'string',
            owner: 'string',
            priority: 'string',
            requires: 'string',
        };
    }
}
exports.DescribePostgresExtensionsResponseBodyUninstalledExtensions = DescribePostgresExtensionsResponseBodyUninstalledExtensions;
class DescribePriceRequestDBNode extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            classCode: 'ClassCode',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            classCode: 'string',
            zoneId: 'string',
        };
    }
}
exports.DescribePriceRequestDBNode = DescribePriceRequestDBNode;
class DescribePriceRequestServerlessConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxCapacity: 'MaxCapacity',
            minCapacity: 'MinCapacity',
        };
    }
    static types() {
        return {
            maxCapacity: 'number',
            minCapacity: 'number',
        };
    }
}
exports.DescribePriceRequestServerlessConfig = DescribePriceRequestServerlessConfig;
class DescribePriceResponseBodyPriceInfoActivityInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkErrMsg: 'CheckErrMsg',
            errorCode: 'ErrorCode',
            success: 'Success',
        };
    }
    static types() {
        return {
            checkErrMsg: 'string',
            errorCode: 'string',
            success: 'string',
        };
    }
}
exports.DescribePriceResponseBodyPriceInfoActivityInfo = DescribePriceResponseBodyPriceInfoActivityInfo;
class DescribePriceResponseBodyPriceInfoCouponsCoupon extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            couponNo: 'CouponNo',
            description: 'Description',
            isSelected: 'IsSelected',
            name: 'Name',
        };
    }
    static types() {
        return {
            couponNo: 'string',
            description: 'string',
            isSelected: 'string',
            name: 'string',
        };
    }
}
exports.DescribePriceResponseBodyPriceInfoCouponsCoupon = DescribePriceResponseBodyPriceInfoCouponsCoupon;
class DescribePriceResponseBodyPriceInfoCoupons extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            coupon: 'Coupon',
        };
    }
    static types() {
        return {
            coupon: { 'type': 'array', 'itemType': DescribePriceResponseBodyPriceInfoCouponsCoupon },
        };
    }
}
exports.DescribePriceResponseBodyPriceInfoCoupons = DescribePriceResponseBodyPriceInfoCoupons;
class DescribePriceResponseBodyPriceInfoRuleIds extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            ruleId: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribePriceResponseBodyPriceInfoRuleIds = DescribePriceResponseBodyPriceInfoRuleIds;
class DescribePriceResponseBodyPriceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            activityInfo: 'ActivityInfo',
            coupons: 'Coupons',
            currency: 'Currency',
            discountPrice: 'DiscountPrice',
            originalPrice: 'OriginalPrice',
            ruleIds: 'RuleIds',
            tradePrice: 'TradePrice',
        };
    }
    static types() {
        return {
            activityInfo: DescribePriceResponseBodyPriceInfoActivityInfo,
            coupons: DescribePriceResponseBodyPriceInfoCoupons,
            currency: 'string',
            discountPrice: 'number',
            originalPrice: 'number',
            ruleIds: DescribePriceResponseBodyPriceInfoRuleIds,
            tradePrice: 'number',
        };
    }
}
exports.DescribePriceResponseBodyPriceInfo = DescribePriceResponseBodyPriceInfo;
class DescribePriceResponseBodyRulesRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            name: 'Name',
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            description: 'string',
            name: 'string',
            ruleId: 'number',
        };
    }
}
exports.DescribePriceResponseBodyRulesRule = DescribePriceResponseBodyRulesRule;
class DescribePriceResponseBodyRules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            rule: 'Rule',
        };
    }
    static types() {
        return {
            rule: { 'type': 'array', 'itemType': DescribePriceResponseBodyRulesRule },
        };
    }
}
exports.DescribePriceResponseBodyRules = DescribePriceResponseBodyRules;
class DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endDate: 'EndDate',
            isTop: 'IsTop',
            noticeBarContent: 'NoticeBarContent',
            poppedUpButtonText: 'PoppedUpButtonText',
            poppedUpButtonType: 'PoppedUpButtonType',
            poppedUpButtonUrl: 'PoppedUpButtonUrl',
            poppedUpContent: 'PoppedUpContent',
            resourceNiche: 'ResourceNiche',
            startDate: 'StartDate',
        };
    }
    static types() {
        return {
            endDate: 'string',
            isTop: 'string',
            noticeBarContent: 'string',
            poppedUpButtonText: 'string',
            poppedUpButtonType: 'string',
            poppedUpButtonUrl: 'string',
            poppedUpContent: 'string',
            resourceNiche: 'string',
            startDate: 'string',
        };
    }
}
exports.DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting = DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting;
class DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            rdsInstanceResourceSetting: 'RdsInstanceResourceSetting',
        };
    }
    static types() {
        return {
            rdsInstanceResourceSetting: { 'type': 'array', 'itemType': DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettingsRdsInstanceResourceSetting },
        };
    }
}
exports.DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings = DescribeRdsResourceSettingsResponseBodyRdsInstanceResourceSettings;
class DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readDBInstanceName: 'ReadDBInstanceName',
        };
    }
    static types() {
        return {
            readDBInstanceName: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames = DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames;
class DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readDelayTime: 'ReadDelayTime',
        };
    }
    static types() {
        return {
            readDelayTime: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes = DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes;
class DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            flushLag: 'FlushLag',
            flushLatency: 'FlushLatency',
            readDBInstanceName: 'ReadDBInstanceName',
            replayLag: 'ReplayLag',
            replayLatency: 'ReplayLatency',
            sendLatency: 'SendLatency',
            writeLag: 'WriteLag',
            writeLatency: 'WriteLatency',
        };
    }
    static types() {
        return {
            flushLag: 'string',
            flushLatency: 'string',
            readDBInstanceName: 'string',
            replayLag: 'string',
            replayLatency: 'string',
            sendLatency: 'string',
            writeLag: 'string',
            writeLatency: 'string',
        };
    }
}
exports.DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay = DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay;
class DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readonlyInstanceDelay: 'ReadonlyInstanceDelay',
        };
    }
    static types() {
        return {
            readonlyInstanceDelay: { 'type': 'array', 'itemType': DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelayReadonlyInstanceDelay },
        };
    }
}
exports.DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay = DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay;
class DescribeReadDBInstanceDelayResponseBodyItemsItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            readDBInstanceNames: 'ReadDBInstanceNames',
            readDelayTimes: 'ReadDelayTimes',
            readonlyInstanceDelay: 'ReadonlyInstanceDelay',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            readDBInstanceNames: DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDBInstanceNames,
            readDelayTimes: DescribeReadDBInstanceDelayResponseBodyItemsItemsReadDelayTimes,
            readonlyInstanceDelay: DescribeReadDBInstanceDelayResponseBodyItemsItemsReadonlyInstanceDelay,
        };
    }
}
exports.DescribeReadDBInstanceDelayResponseBodyItemsItems = DescribeReadDBInstanceDelayResponseBodyItemsItems;
class DescribeReadDBInstanceDelayResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'Items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': DescribeReadDBInstanceDelayResponseBodyItemsItems },
        };
    }
}
exports.DescribeReadDBInstanceDelayResponseBodyItems = DescribeReadDBInstanceDelayResponseBodyItems;
class DescribeRegionInfosResponseBodyRegionsRDSRegion extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            regionId: 'RegionId',
        };
    }
    static types() {
        return {
            regionId: 'string',
        };
    }
}
exports.DescribeRegionInfosResponseBodyRegionsRDSRegion = DescribeRegionInfosResponseBodyRegionsRDSRegion;
class DescribeRegionInfosResponseBodyRegions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            RDSRegion: 'RDSRegion',
        };
    }
    static types() {
        return {
            RDSRegion: { 'type': 'array', 'itemType': DescribeRegionInfosResponseBodyRegionsRDSRegion },
        };
    }
}
exports.DescribeRegionInfosResponseBodyRegions = DescribeRegionInfosResponseBodyRegions;
class DescribeRegionsResponseBodyRegionsRDSRegion extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            localName: 'LocalName',
            regionEndpoint: 'RegionEndpoint',
            regionId: 'RegionId',
            zoneId: 'ZoneId',
            zoneName: 'ZoneName',
        };
    }
    static types() {
        return {
            localName: 'string',
            regionEndpoint: 'string',
            regionId: 'string',
            zoneId: 'string',
            zoneName: 'string',
        };
    }
}
exports.DescribeRegionsResponseBodyRegionsRDSRegion = DescribeRegionsResponseBodyRegionsRDSRegion;
class DescribeRegionsResponseBodyRegions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            RDSRegion: 'RDSRegion',
        };
    }
    static types() {
        return {
            RDSRegion: { 'type': 'array', 'itemType': DescribeRegionsResponseBodyRegionsRDSRegion },
        };
    }
}
exports.DescribeRegionsResponseBodyRegions = DescribeRegionsResponseBodyRegions;
class DescribeRenewalPriceResponseBodyPriceInfoActivityInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkErrMsg: 'CheckErrMsg',
            errorCode: 'ErrorCode',
            success: 'Success',
        };
    }
    static types() {
        return {
            checkErrMsg: 'string',
            errorCode: 'string',
            success: 'string',
        };
    }
}
exports.DescribeRenewalPriceResponseBodyPriceInfoActivityInfo = DescribeRenewalPriceResponseBodyPriceInfoActivityInfo;
class DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            couponNo: 'CouponNo',
            description: 'Description',
            isSelected: 'IsSelected',
            name: 'Name',
        };
    }
    static types() {
        return {
            couponNo: 'string',
            description: 'string',
            isSelected: 'string',
            name: 'string',
        };
    }
}
exports.DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon = DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon;
class DescribeRenewalPriceResponseBodyPriceInfoCoupons extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            coupon: 'Coupon',
        };
    }
    static types() {
        return {
            coupon: { 'type': 'array', 'itemType': DescribeRenewalPriceResponseBodyPriceInfoCouponsCoupon },
        };
    }
}
exports.DescribeRenewalPriceResponseBodyPriceInfoCoupons = DescribeRenewalPriceResponseBodyPriceInfoCoupons;
class DescribeRenewalPriceResponseBodyPriceInfoRuleIds extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            ruleId: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeRenewalPriceResponseBodyPriceInfoRuleIds = DescribeRenewalPriceResponseBodyPriceInfoRuleIds;
class DescribeRenewalPriceResponseBodyPriceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            activityInfo: 'ActivityInfo',
            coupons: 'Coupons',
            currency: 'Currency',
            discountPrice: 'DiscountPrice',
            originalPrice: 'OriginalPrice',
            ruleIds: 'RuleIds',
            tradePrice: 'TradePrice',
        };
    }
    static types() {
        return {
            activityInfo: DescribeRenewalPriceResponseBodyPriceInfoActivityInfo,
            coupons: DescribeRenewalPriceResponseBodyPriceInfoCoupons,
            currency: 'string',
            discountPrice: 'number',
            originalPrice: 'number',
            ruleIds: DescribeRenewalPriceResponseBodyPriceInfoRuleIds,
            tradePrice: 'number',
        };
    }
}
exports.DescribeRenewalPriceResponseBodyPriceInfo = DescribeRenewalPriceResponseBodyPriceInfo;
class DescribeRenewalPriceResponseBodyRulesRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            name: 'Name',
            ruleId: 'RuleId',
        };
    }
    static types() {
        return {
            description: 'string',
            name: 'string',
            ruleId: 'number',
        };
    }
}
exports.DescribeRenewalPriceResponseBodyRulesRule = DescribeRenewalPriceResponseBodyRulesRule;
class DescribeRenewalPriceResponseBodyRules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            rule: 'Rule',
        };
    }
    static types() {
        return {
            rule: { 'type': 'array', 'itemType': DescribeRenewalPriceResponseBodyRulesRule },
        };
    }
}
exports.DescribeRenewalPriceResponseBodyRules = DescribeRenewalPriceResponseBodyRules;
class DescribeResourceDetailsResponseBodyRdsEcsSecurityGroupRel extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            securityGroupName: 'SecurityGroupName',
        };
    }
    static types() {
        return {
            securityGroupName: 'string',
        };
    }
}
exports.DescribeResourceDetailsResponseBodyRdsEcsSecurityGroupRel = DescribeResourceDetailsResponseBodyRdsEcsSecurityGroupRel;
class DescribeSQLLogFilesResponseBodyItemsLogFile extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileID: 'FileID',
            logDownloadURL: 'LogDownloadURL',
            logEndTime: 'LogEndTime',
            logSize: 'LogSize',
            logStartTime: 'LogStartTime',
            logStatus: 'LogStatus',
        };
    }
    static types() {
        return {
            fileID: 'string',
            logDownloadURL: 'string',
            logEndTime: 'string',
            logSize: 'string',
            logStartTime: 'string',
            logStatus: 'string',
        };
    }
}
exports.DescribeSQLLogFilesResponseBodyItemsLogFile = DescribeSQLLogFilesResponseBodyItemsLogFile;
class DescribeSQLLogFilesResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            logFile: 'LogFile',
        };
    }
    static types() {
        return {
            logFile: { 'type': 'array', 'itemType': DescribeSQLLogFilesResponseBodyItemsLogFile },
        };
    }
}
exports.DescribeSQLLogFilesResponseBodyItems = DescribeSQLLogFilesResponseBodyItems;
class DescribeSQLLogRecordsResponseBodyItemsSQLRecord extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountName: 'AccountName',
            DBName: 'DBName',
            executeTime: 'ExecuteTime',
            hostAddress: 'HostAddress',
            returnRowCounts: 'ReturnRowCounts',
            SQLText: 'SQLText',
            threadID: 'ThreadID',
            totalExecutionTimes: 'TotalExecutionTimes',
        };
    }
    static types() {
        return {
            accountName: 'string',
            DBName: 'string',
            executeTime: 'string',
            hostAddress: 'string',
            returnRowCounts: 'number',
            SQLText: 'string',
            threadID: 'string',
            totalExecutionTimes: 'number',
        };
    }
}
exports.DescribeSQLLogRecordsResponseBodyItemsSQLRecord = DescribeSQLLogRecordsResponseBodyItemsSQLRecord;
class DescribeSQLLogRecordsResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            SQLRecord: 'SQLRecord',
        };
    }
    static types() {
        return {
            SQLRecord: { 'type': 'array', 'itemType': DescribeSQLLogRecordsResponseBodyItemsSQLRecord },
        };
    }
}
exports.DescribeSQLLogRecordsResponseBodyItems = DescribeSQLLogRecordsResponseBodyItems;
class DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            avgLatency: 'AvgLatency',
            SQLExecuteTimes: 'SQLExecuteTimes',
            SQLText: 'SQLText',
        };
    }
    static types() {
        return {
            avgLatency: 'number',
            SQLExecuteTimes: 'number',
            SQLText: 'string',
        };
    }
}
exports.DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem = DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem;
class DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            latencyTopNItem: 'LatencyTopNItem',
        };
    }
    static types() {
        return {
            latencyTopNItem: { 'type': 'array', 'itemType': DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItemsLatencyTopNItem },
        };
    }
}
exports.DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems = DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems;
class DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            SQLExecuteTimes: 'SQLExecuteTimes',
            SQLText: 'SQLText',
        };
    }
    static types() {
        return {
            SQLExecuteTimes: 'number',
            SQLText: 'string',
        };
    }
}
exports.DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem = DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem;
class DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            QPSTopNItem: 'QPSTopNItem',
        };
    }
    static types() {
        return {
            QPSTopNItem: { 'type': 'array', 'itemType': DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItemsQPSTopNItem },
        };
    }
}
exports.DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems = DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems;
class DescribeSQLLogReportListResponseBodyItemsItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            latencyTopNItems: 'LatencyTopNItems',
            QPSTopNItems: 'QPSTopNItems',
            reportTime: 'ReportTime',
        };
    }
    static types() {
        return {
            latencyTopNItems: DescribeSQLLogReportListResponseBodyItemsItemLatencyTopNItems,
            QPSTopNItems: DescribeSQLLogReportListResponseBodyItemsItemQPSTopNItems,
            reportTime: 'string',
        };
    }
}
exports.DescribeSQLLogReportListResponseBodyItemsItem = DescribeSQLLogReportListResponseBodyItemsItem;
class DescribeSQLLogReportListResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'Item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': DescribeSQLLogReportListResponseBodyItemsItem },
        };
    }
}
exports.DescribeSQLLogReportListResponseBodyItems = DescribeSQLLogReportListResponseBodyItems;
class DescribeSecretsResponseBodySecrets extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountId: 'AccountId',
            description: 'Description',
            regionId: 'RegionId',
            secretArn: 'SecretArn',
            secretName: 'SecretName',
            username: 'Username',
        };
    }
    static types() {
        return {
            accountId: 'string',
            description: 'string',
            regionId: 'string',
            secretArn: 'string',
            secretName: 'string',
            username: 'string',
        };
    }
}
exports.DescribeSecretsResponseBodySecrets = DescribeSecretsResponseBodySecrets;
class DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            networkType: 'NetworkType',
            regionId: 'RegionId',
            securityGroupId: 'SecurityGroupId',
            securityGroupName: 'SecurityGroupName',
        };
    }
    static types() {
        return {
            networkType: 'string',
            regionId: 'string',
            securityGroupId: 'string',
            securityGroupName: 'string',
        };
    }
}
exports.DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation = DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation;
class DescribeSecurityGroupConfigurationResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ecsSecurityGroupRelation: 'EcsSecurityGroupRelation',
        };
    }
    static types() {
        return {
            ecsSecurityGroupRelation: { 'type': 'array', 'itemType': DescribeSecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation },
        };
    }
}
exports.DescribeSecurityGroupConfigurationResponseBodyItems = DescribeSecurityGroupConfigurationResponseBodyItems;
class DescribeSlotsResponseBodySlots extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            database: 'Database',
            plugin: 'Plugin',
            slotName: 'SlotName',
            slotStatus: 'SlotStatus',
            slotType: 'SlotType',
            subReplayLag: 'SubReplayLag',
            temporary: 'Temporary',
            walDelay: 'WalDelay',
        };
    }
    static types() {
        return {
            database: 'string',
            plugin: 'string',
            slotName: 'string',
            slotStatus: 'string',
            slotType: 'string',
            subReplayLag: 'string',
            temporary: 'string',
            walDelay: 'string',
        };
    }
}
exports.DescribeSlotsResponseBodySlots = DescribeSlotsResponseBodySlots;
class DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applicationName: 'ApplicationName',
            clientHostName: 'ClientHostName',
            cpuTime: 'CpuTime',
            DBName: 'DBName',
            executionStartTime: 'ExecutionStartTime',
            hostAddress: 'HostAddress',
            lastRowsAffectedCount: 'LastRowsAffectedCount',
            lockTimes: 'LockTimes',
            logicalIORead: 'LogicalIORead',
            parseRowCounts: 'ParseRowCounts',
            physicalIORead: 'PhysicalIORead',
            queryTimeMS: 'QueryTimeMS',
            queryTimes: 'QueryTimes',
            returnRowCounts: 'ReturnRowCounts',
            rowsAffectedCount: 'RowsAffectedCount',
            SQLHash: 'SQLHash',
            SQLText: 'SQLText',
            userName: 'UserName',
            writeIOCount: 'WriteIOCount',
        };
    }
    static types() {
        return {
            applicationName: 'string',
            clientHostName: 'string',
            cpuTime: 'number',
            DBName: 'string',
            executionStartTime: 'string',
            hostAddress: 'string',
            lastRowsAffectedCount: 'number',
            lockTimes: 'number',
            logicalIORead: 'number',
            parseRowCounts: 'number',
            physicalIORead: 'number',
            queryTimeMS: 'number',
            queryTimes: 'number',
            returnRowCounts: 'number',
            rowsAffectedCount: 'number',
            SQLHash: 'string',
            SQLText: 'string',
            userName: 'string',
            writeIOCount: 'number',
        };
    }
}
exports.DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord = DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord;
class DescribeSlowLogRecordsResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            SQLSlowRecord: 'SQLSlowRecord',
        };
    }
    static types() {
        return {
            SQLSlowRecord: { 'type': 'array', 'itemType': DescribeSlowLogRecordsResponseBodyItemsSQLSlowRecord },
        };
    }
}
exports.DescribeSlowLogRecordsResponseBodyItems = DescribeSlowLogRecordsResponseBodyItems;
class DescribeSlowLogsResponseBodyItemsSQLSlowLog extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            avgExecutionTime: 'AvgExecutionTime',
            avgIOWriteCounts: 'AvgIOWriteCounts',
            avgLastRowsAffectedCounts: 'AvgLastRowsAffectedCounts',
            avgLogicalReadCounts: 'AvgLogicalReadCounts',
            avgPhysicalReadCounts: 'AvgPhysicalReadCounts',
            avgRowsAffectedCounts: 'AvgRowsAffectedCounts',
            createTime: 'CreateTime',
            DBName: 'DBName',
            maxExecutionTime: 'MaxExecutionTime',
            maxExecutionTimeMS: 'MaxExecutionTimeMS',
            maxIOWriteCounts: 'MaxIOWriteCounts',
            maxLastRowsAffectedCounts: 'MaxLastRowsAffectedCounts',
            maxLockTime: 'MaxLockTime',
            maxLockTimeMS: 'MaxLockTimeMS',
            maxLogicalReadCounts: 'MaxLogicalReadCounts',
            maxPhysicalReadCounts: 'MaxPhysicalReadCounts',
            maxRowsAffectedCounts: 'MaxRowsAffectedCounts',
            minIOWriteCounts: 'MinIOWriteCounts',
            minLastRowsAffectedCounts: 'MinLastRowsAffectedCounts',
            minLogicalReadCounts: 'MinLogicalReadCounts',
            minPhysicalReadCounts: 'MinPhysicalReadCounts',
            minRowsAffectedCounts: 'MinRowsAffectedCounts',
            mySQLTotalExecutionCounts: 'MySQLTotalExecutionCounts',
            mySQLTotalExecutionTimes: 'MySQLTotalExecutionTimes',
            parseMaxRowCount: 'ParseMaxRowCount',
            parseTotalRowCounts: 'ParseTotalRowCounts',
            reportTime: 'ReportTime',
            returnMaxRowCount: 'ReturnMaxRowCount',
            returnTotalRowCounts: 'ReturnTotalRowCounts',
            SQLHASH: 'SQLHASH',
            SQLIdStr: 'SQLIdStr',
            SQLServerAvgCpuTime: 'SQLServerAvgCpuTime',
            SQLServerAvgExecutionTime: 'SQLServerAvgExecutionTime',
            SQLServerMaxCpuTime: 'SQLServerMaxCpuTime',
            SQLServerMinCpuTime: 'SQLServerMinCpuTime',
            SQLServerMinExecutionTime: 'SQLServerMinExecutionTime',
            SQLServerTotalCpuTime: 'SQLServerTotalCpuTime',
            SQLServerTotalExecutionCounts: 'SQLServerTotalExecutionCounts',
            SQLServerTotalExecutionTimes: 'SQLServerTotalExecutionTimes',
            SQLText: 'SQLText',
            slowLogId: 'SlowLogId',
            totalIOWriteCounts: 'TotalIOWriteCounts',
            totalLastRowsAffectedCounts: 'TotalLastRowsAffectedCounts',
            totalLockTimes: 'TotalLockTimes',
            totalLogicalReadCounts: 'TotalLogicalReadCounts',
            totalPhysicalReadCounts: 'TotalPhysicalReadCounts',
            totalRowsAffectedCounts: 'TotalRowsAffectedCounts',
        };
    }
    static types() {
        return {
            avgExecutionTime: 'number',
            avgIOWriteCounts: 'number',
            avgLastRowsAffectedCounts: 'number',
            avgLogicalReadCounts: 'number',
            avgPhysicalReadCounts: 'number',
            avgRowsAffectedCounts: 'number',
            createTime: 'string',
            DBName: 'string',
            maxExecutionTime: 'number',
            maxExecutionTimeMS: 'number',
            maxIOWriteCounts: 'number',
            maxLastRowsAffectedCounts: 'number',
            maxLockTime: 'number',
            maxLockTimeMS: 'number',
            maxLogicalReadCounts: 'number',
            maxPhysicalReadCounts: 'number',
            maxRowsAffectedCounts: 'number',
            minIOWriteCounts: 'number',
            minLastRowsAffectedCounts: 'number',
            minLogicalReadCounts: 'number',
            minPhysicalReadCounts: 'number',
            minRowsAffectedCounts: 'number',
            mySQLTotalExecutionCounts: 'number',
            mySQLTotalExecutionTimes: 'number',
            parseMaxRowCount: 'number',
            parseTotalRowCounts: 'number',
            reportTime: 'string',
            returnMaxRowCount: 'number',
            returnTotalRowCounts: 'number',
            SQLHASH: 'string',
            SQLIdStr: 'string',
            SQLServerAvgCpuTime: 'number',
            SQLServerAvgExecutionTime: 'number',
            SQLServerMaxCpuTime: 'number',
            SQLServerMinCpuTime: 'number',
            SQLServerMinExecutionTime: 'number',
            SQLServerTotalCpuTime: 'number',
            SQLServerTotalExecutionCounts: 'number',
            SQLServerTotalExecutionTimes: 'number',
            SQLText: 'string',
            slowLogId: 'number',
            totalIOWriteCounts: 'number',
            totalLastRowsAffectedCounts: 'number',
            totalLockTimes: 'number',
            totalLogicalReadCounts: 'number',
            totalPhysicalReadCounts: 'number',
            totalRowsAffectedCounts: 'number',
        };
    }
}
exports.DescribeSlowLogsResponseBodyItemsSQLSlowLog = DescribeSlowLogsResponseBodyItemsSQLSlowLog;
class DescribeSlowLogsResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            SQLSlowLog: 'SQLSlowLog',
        };
    }
    static types() {
        return {
            SQLSlowLog: { 'type': 'array', 'itemType': DescribeSlowLogsResponseBodyItemsSQLSlowLog },
        };
    }
}
exports.DescribeSlowLogsResponseBodyItems = DescribeSlowLogsResponseBodyItems;
class DescribeTagsResponseBodyItemsTagInfosDBInstanceIds extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceIds: 'DBInstanceIds',
        };
    }
    static types() {
        return {
            DBInstanceIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeTagsResponseBodyItemsTagInfosDBInstanceIds = DescribeTagsResponseBodyItemsTagInfosDBInstanceIds;
class DescribeTagsResponseBodyItemsTagInfos extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceIds: 'DBInstanceIds',
            tagKey: 'TagKey',
            tagValue: 'TagValue',
        };
    }
    static types() {
        return {
            DBInstanceIds: DescribeTagsResponseBodyItemsTagInfosDBInstanceIds,
            tagKey: 'string',
            tagValue: 'string',
        };
    }
}
exports.DescribeTagsResponseBodyItemsTagInfos = DescribeTagsResponseBodyItemsTagInfos;
class DescribeTagsResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagInfos: 'TagInfos',
        };
    }
    static types() {
        return {
            tagInfos: { 'type': 'array', 'itemType': DescribeTagsResponseBodyItemsTagInfos },
        };
    }
}
exports.DescribeTagsResponseBodyItems = DescribeTagsResponseBodyItems;
class DescribeTasksResponseBodyItemsTaskProgressInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            beginTime: 'BeginTime',
            currentStepName: 'CurrentStepName',
            DBName: 'DBName',
            expectedFinishTime: 'ExpectedFinishTime',
            finishTime: 'FinishTime',
            progress: 'Progress',
            progressInfo: 'ProgressInfo',
            remain: 'Remain',
            status: 'Status',
            stepProgressInfo: 'StepProgressInfo',
            stepsInfo: 'StepsInfo',
            taskAction: 'TaskAction',
            taskErrorCode: 'TaskErrorCode',
            taskErrorMessage: 'TaskErrorMessage',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            beginTime: 'string',
            currentStepName: 'string',
            DBName: 'string',
            expectedFinishTime: 'string',
            finishTime: 'string',
            progress: 'string',
            progressInfo: 'string',
            remain: 'number',
            status: 'string',
            stepProgressInfo: 'string',
            stepsInfo: 'string',
            taskAction: 'string',
            taskErrorCode: 'string',
            taskErrorMessage: 'string',
            taskId: 'string',
        };
    }
}
exports.DescribeTasksResponseBodyItemsTaskProgressInfo = DescribeTasksResponseBodyItemsTaskProgressInfo;
class DescribeTasksResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            taskProgressInfo: 'TaskProgressInfo',
        };
    }
    static types() {
        return {
            taskProgressInfo: { 'type': 'array', 'itemType': DescribeTasksResponseBodyItemsTaskProgressInfo },
        };
    }
}
exports.DescribeTasksResponseBodyItems = DescribeTasksResponseBodyItems;
class DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkTime: 'CheckTime',
            detail: 'Detail',
            effectiveTime: 'EffectiveTime',
            result: 'Result',
            sourceMajorVersion: 'SourceMajorVersion',
            targetMajorVersion: 'TargetMajorVersion',
            taskId: 'TaskId',
        };
    }
    static types() {
        return {
            checkTime: 'string',
            detail: 'string',
            effectiveTime: 'string',
            result: 'string',
            sourceMajorVersion: 'string',
            targetMajorVersion: 'string',
            taskId: 'number',
        };
    }
}
exports.DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems = DescribeUpgradeMajorVersionPrecheckTaskResponseBodyItems;
class DescribeUpgradeMajorVersionTasksResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            collectStatMode: 'CollectStatMode',
            detail: 'Detail',
            endTime: 'EndTime',
            result: 'Result',
            sourceInsName: 'SourceInsName',
            sourceMajorVersion: 'SourceMajorVersion',
            startTime: 'StartTime',
            switchTime: 'SwitchTime',
            targetInsName: 'TargetInsName',
            targetMajorVersion: 'TargetMajorVersion',
            taskId: 'TaskId',
            upgradeMode: 'UpgradeMode',
        };
    }
    static types() {
        return {
            collectStatMode: 'string',
            detail: 'string',
            endTime: 'string',
            result: 'string',
            sourceInsName: 'string',
            sourceMajorVersion: 'string',
            startTime: 'string',
            switchTime: 'string',
            targetInsName: 'string',
            targetMajorVersion: 'string',
            taskId: 'number',
            upgradeMode: 'string',
        };
    }
}
exports.DescribeUpgradeMajorVersionTasksResponseBodyItems = DescribeUpgradeMajorVersionTasksResponseBodyItems;
class DescribeVSwitchesResponseBodyVSwitchs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availableIpAddressCount: 'AvailableIpAddressCount',
            cidrBlock: 'CidrBlock',
            description: 'Description',
            isDefault: 'IsDefault',
            izNo: 'IzNo',
            status: 'Status',
            vSwitchId: 'VSwitchId',
            vSwitchName: 'VSwitchName',
        };
    }
    static types() {
        return {
            availableIpAddressCount: 'string',
            cidrBlock: 'string',
            description: 'string',
            isDefault: 'boolean',
            izNo: 'string',
            status: 'string',
            vSwitchId: 'string',
            vSwitchName: 'string',
        };
    }
}
exports.DescribeVSwitchesResponseBodyVSwitchs = DescribeVSwitchesResponseBodyVSwitchs;
class DescribeWhitelistTemplateResponseBodyDataTemplate extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'Id',
            ips: 'Ips',
            templateId: 'TemplateId',
            templateName: 'TemplateName',
            userId: 'UserId',
        };
    }
    static types() {
        return {
            id: 'number',
            ips: 'string',
            templateId: 'number',
            templateName: 'string',
            userId: 'number',
        };
    }
}
exports.DescribeWhitelistTemplateResponseBodyDataTemplate = DescribeWhitelistTemplateResponseBodyDataTemplate;
class DescribeWhitelistTemplateResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            template: 'Template',
        };
    }
    static types() {
        return {
            template: DescribeWhitelistTemplateResponseBodyDataTemplate,
        };
    }
}
exports.DescribeWhitelistTemplateResponseBodyData = DescribeWhitelistTemplateResponseBodyData;
class DescribeWhitelistTemplateLinkedInstanceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            insName: 'InsName',
            templateId: 'TemplateId',
        };
    }
    static types() {
        return {
            insName: { 'type': 'array', 'itemType': 'string' },
            templateId: 'number',
        };
    }
}
exports.DescribeWhitelistTemplateLinkedInstanceResponseBodyData = DescribeWhitelistTemplateLinkedInstanceResponseBodyData;
class DetachWhitelistTemplateToInstanceResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            status: 'Status',
        };
    }
    static types() {
        return {
            status: 'string',
        };
    }
}
exports.DetachWhitelistTemplateToInstanceResponseBodyData = DetachWhitelistTemplateToInstanceResponseBodyData;
class GetDBInstanceTopologyResponseBodyDataConnections extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectionString: 'ConnectionString',
            DBInstanceName: 'DBInstanceName',
            netType: 'NetType',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            connectionString: 'string',
            DBInstanceName: 'string',
            netType: 'string',
            zoneId: 'string',
        };
    }
}
exports.GetDBInstanceTopologyResponseBodyDataConnections = GetDBInstanceTopologyResponseBodyDataConnections;
class GetDBInstanceTopologyResponseBodyDataNodes extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceName: 'DBInstanceName',
            dedicatedHostGroupId: 'DedicatedHostGroupId',
            dedicatedHostId: 'DedicatedHostId',
            nodeId: 'NodeId',
            role: 'Role',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            DBInstanceName: 'string',
            dedicatedHostGroupId: 'string',
            dedicatedHostId: 'string',
            nodeId: 'string',
            role: 'string',
            zoneId: 'string',
        };
    }
}
exports.GetDBInstanceTopologyResponseBodyDataNodes = GetDBInstanceTopologyResponseBodyDataNodes;
class GetDBInstanceTopologyResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connections: 'Connections',
            DBInstanceName: 'DBInstanceName',
            nodes: 'Nodes',
        };
    }
    static types() {
        return {
            connections: { 'type': 'array', 'itemType': GetDBInstanceTopologyResponseBodyDataConnections },
            DBInstanceName: 'string',
            nodes: { 'type': 'array', 'itemType': GetDBInstanceTopologyResponseBodyDataNodes },
        };
    }
}
exports.GetDBInstanceTopologyResponseBodyData = GetDBInstanceTopologyResponseBodyData;
class GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            certCommonName: 'CertCommonName',
            dbInstanceName: 'DbInstanceName',
            endpointName: 'EndpointName',
            endpointType: 'EndpointType',
            sslExpiredTime: 'SslExpiredTime',
        };
    }
    static types() {
        return {
            certCommonName: 'string',
            dbInstanceName: 'string',
            endpointName: 'string',
            endpointType: 'string',
            sslExpiredTime: 'string',
        };
    }
}
exports.GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems = GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems;
class GetDbProxyInstanceSslResponseBodyDbProxyCertListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dbProxyCertListItems: 'DbProxyCertListItems',
        };
    }
    static types() {
        return {
            dbProxyCertListItems: { 'type': 'array', 'itemType': GetDbProxyInstanceSslResponseBodyDbProxyCertListItemsDbProxyCertListItems },
        };
    }
}
exports.GetDbProxyInstanceSslResponseBodyDbProxyCertListItems = GetDbProxyInstanceSslResponseBodyDbProxyCertListItems;
class ListClassesResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            classCode: 'ClassCode',
            classGroup: 'ClassGroup',
            cpu: 'Cpu',
            encryptedMemory: 'EncryptedMemory',
            instructionSetArch: 'InstructionSetArch',
            maxConnections: 'MaxConnections',
            maxIOMBPS: 'MaxIOMBPS',
            maxIOPS: 'MaxIOPS',
            memoryClass: 'MemoryClass',
            referencePrice: 'ReferencePrice',
        };
    }
    static types() {
        return {
            classCode: 'string',
            classGroup: 'string',
            cpu: 'string',
            encryptedMemory: 'string',
            instructionSetArch: 'string',
            maxConnections: 'string',
            maxIOMBPS: 'string',
            maxIOPS: 'string',
            memoryClass: 'string',
            referencePrice: 'string',
        };
    }
}
exports.ListClassesResponseBodyItems = ListClassesResponseBodyItems;
class ListTagResourcesRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.ListTagResourcesRequestTag = ListTagResourcesRequestTag;
class ListTagResourcesResponseBodyTagResourcesTagResource extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resourceId: 'ResourceId',
            resourceType: 'ResourceType',
            tagKey: 'TagKey',
            tagValue: 'TagValue',
        };
    }
    static types() {
        return {
            resourceId: 'string',
            resourceType: 'string',
            tagKey: 'string',
            tagValue: 'string',
        };
    }
}
exports.ListTagResourcesResponseBodyTagResourcesTagResource = ListTagResourcesResponseBodyTagResourcesTagResource;
class ListTagResourcesResponseBodyTagResources extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagResource: 'TagResource',
        };
    }
    static types() {
        return {
            tagResource: { 'type': 'array', 'itemType': ListTagResourcesResponseBodyTagResourcesTagResource },
        };
    }
}
exports.ListTagResourcesResponseBodyTagResources = ListTagResourcesResponseBodyTagResources;
class ListUserBackupFilesResponseBodyRecords extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            backupId: 'BackupId',
            binlogInfo: 'BinlogInfo',
            comment: 'Comment',
            creationTime: 'CreationTime',
            engine: 'Engine',
            engineVersion: 'EngineVersion',
            finishTime: 'FinishTime',
            modificationTime: 'ModificationTime',
            ossBucket: 'OssBucket',
            ossFileMetaData: 'OssFileMetaData',
            ossFileName: 'OssFileName',
            ossFilePath: 'OssFilePath',
            ossFileSize: 'OssFileSize',
            ossUrl: 'OssUrl',
            reason: 'Reason',
            restoreSize: 'RestoreSize',
            retention: 'Retention',
            status: 'Status',
            zoneId: 'ZoneId',
        };
    }
    static types() {
        return {
            backupId: 'string',
            binlogInfo: 'string',
            comment: 'string',
            creationTime: 'string',
            engine: 'string',
            engineVersion: 'string',
            finishTime: 'string',
            modificationTime: 'string',
            ossBucket: 'string',
            ossFileMetaData: 'string',
            ossFileName: 'string',
            ossFilePath: 'string',
            ossFileSize: 'number',
            ossUrl: 'string',
            reason: 'string',
            restoreSize: 'string',
            retention: 'number',
            status: 'string',
            zoneId: 'string',
        };
    }
}
exports.ListUserBackupFilesResponseBodyRecords = ListUserBackupFilesResponseBodyRecords;
class ModifyDBInstanceEndpointRequestNodeItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceId: 'DBInstanceId',
            nodeId: 'NodeId',
            weight: 'Weight',
        };
    }
    static types() {
        return {
            DBInstanceId: 'string',
            nodeId: 'string',
            weight: 'number',
        };
    }
}
exports.ModifyDBInstanceEndpointRequestNodeItems = ModifyDBInstanceEndpointRequestNodeItems;
class ModifyDBInstanceEndpointResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceEndpointId: 'DBInstanceEndpointId',
            DBInstanceName: 'DBInstanceName',
        };
    }
    static types() {
        return {
            DBInstanceEndpointId: 'string',
            DBInstanceName: 'string',
        };
    }
}
exports.ModifyDBInstanceEndpointResponseBodyData = ModifyDBInstanceEndpointResponseBodyData;
class ModifyDBInstanceEndpointAddressResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            DBInstanceEndpointId: 'DBInstanceEndpointId',
            DBInstanceName: 'DBInstanceName',
        };
    }
    static types() {
        return {
            DBInstanceEndpointId: 'string',
            DBInstanceName: 'string',
        };
    }
}
exports.ModifyDBInstanceEndpointAddressResponseBodyData = ModifyDBInstanceEndpointAddressResponseBodyData;
class ModifyDBInstanceSpecRequestServerlessConfiguration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoPause: 'AutoPause',
            maxCapacity: 'MaxCapacity',
            minCapacity: 'MinCapacity',
            switchForce: 'SwitchForce',
        };
    }
    static types() {
        return {
            autoPause: 'boolean',
            maxCapacity: 'number',
            minCapacity: 'number',
            switchForce: 'boolean',
        };
    }
}
exports.ModifyDBInstanceSpecRequestServerlessConfiguration = ModifyDBInstanceSpecRequestServerlessConfiguration;
class ModifyDBNodeRequestDBNode extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            classCode: 'classCode',
            nodeId: 'nodeId',
        };
    }
    static types() {
        return {
            classCode: 'string',
            nodeId: 'string',
        };
    }
}
exports.ModifyDBNodeRequestDBNode = ModifyDBNodeRequestDBNode;
class ModifyPGHbaConfigRequestHbaItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            address: 'Address',
            database: 'Database',
            mask: 'Mask',
            method: 'Method',
            option: 'Option',
            priorityId: 'PriorityId',
            type: 'Type',
            user: 'User',
        };
    }
    static types() {
        return {
            address: 'string',
            database: 'string',
            mask: 'string',
            method: 'string',
            option: 'string',
            priorityId: 'number',
            type: 'string',
            user: 'string',
        };
    }
}
exports.ModifyPGHbaConfigRequestHbaItem = ModifyPGHbaConfigRequestHbaItem;
class ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            networkType: 'NetworkType',
            regionId: 'RegionId',
            securityGroupId: 'SecurityGroupId',
        };
    }
    static types() {
        return {
            networkType: 'string',
            regionId: 'string',
            securityGroupId: 'string',
        };
    }
}
exports.ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation = ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation;
class ModifySecurityGroupConfigurationResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ecsSecurityGroupRelation: 'EcsSecurityGroupRelation',
        };
    }
    static types() {
        return {
            ecsSecurityGroupRelation: { 'type': 'array', 'itemType': ModifySecurityGroupConfigurationResponseBodyItemsEcsSecurityGroupRelation },
        };
    }
}
exports.ModifySecurityGroupConfigurationResponseBodyItems = ModifySecurityGroupConfigurationResponseBodyItems;
class ModifyWhitelistTemplateResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            status: 'Status',
        };
    }
    static types() {
        return {
            status: 'string',
        };
    }
}
exports.ModifyWhitelistTemplateResponseBodyData = ModifyWhitelistTemplateResponseBodyData;
class PreCheckCreateOrderForCreateDBNodesRequestDBNode extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            classCode: 'classCode',
            zoneId: 'zoneId',
        };
    }
    static types() {
        return {
            classCode: 'string',
            zoneId: 'string',
        };
    }
}
exports.PreCheckCreateOrderForCreateDBNodesRequestDBNode = PreCheckCreateOrderForCreateDBNodesRequestDBNode;
class PreCheckCreateOrderForCreateDBNodesResponseBodyFailuresFailures extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            message: 'Message',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
        };
    }
}
exports.PreCheckCreateOrderForCreateDBNodesResponseBodyFailuresFailures = PreCheckCreateOrderForCreateDBNodesResponseBodyFailuresFailures;
class PreCheckCreateOrderForCreateDBNodesResponseBodyFailures extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failures: 'Failures',
        };
    }
    static types() {
        return {
            failures: { 'type': 'array', 'itemType': PreCheckCreateOrderForCreateDBNodesResponseBodyFailuresFailures },
        };
    }
}
exports.PreCheckCreateOrderForCreateDBNodesResponseBodyFailures = PreCheckCreateOrderForCreateDBNodesResponseBodyFailures;
class PreCheckCreateOrderForDeleteDBNodesResponseBodyFailuresFailures extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'Code',
            message: 'Message',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
        };
    }
}
exports.PreCheckCreateOrderForDeleteDBNodesResponseBodyFailuresFailures = PreCheckCreateOrderForDeleteDBNodesResponseBodyFailuresFailures;
class PreCheckCreateOrderForDeleteDBNodesResponseBodyFailures extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failures: 'Failures',
        };
    }
    static types() {
        return {
            failures: { 'type': 'array', 'itemType': PreCheckCreateOrderForDeleteDBNodesResponseBodyFailuresFailures },
        };
    }
}
exports.PreCheckCreateOrderForDeleteDBNodesResponseBodyFailures = PreCheckCreateOrderForDeleteDBNodesResponseBodyFailures;
class QueryNotifyResponseBodyDataNotifyItemList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliUid: 'AliUid',
            confirmFlag: 'ConfirmFlag',
            confirmor: 'Confirmor',
            gmtCreated: 'GmtCreated',
            gmtModified: 'GmtModified',
            id: 'Id',
            idempotentCount: 'IdempotentCount',
            idempotentId: 'IdempotentId',
            level: 'Level',
            notifyElement: 'NotifyElement',
            templateName: 'TemplateName',
            type: 'Type',
        };
    }
    static types() {
        return {
            aliUid: 'number',
            confirmFlag: 'boolean',
            confirmor: 'number',
            gmtCreated: 'string',
            gmtModified: 'string',
            id: 'number',
            idempotentCount: 'string',
            idempotentId: 'string',
            level: 'string',
            notifyElement: 'string',
            templateName: 'string',
            type: 'string',
        };
    }
}
exports.QueryNotifyResponseBodyDataNotifyItemList = QueryNotifyResponseBodyDataNotifyItemList;
class QueryNotifyResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            notifyItemList: 'NotifyItemList',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            totalRecordCount: 'TotalRecordCount',
        };
    }
    static types() {
        return {
            notifyItemList: { 'type': 'array', 'itemType': QueryNotifyResponseBodyDataNotifyItemList },
            pageNumber: 'number',
            pageSize: 'number',
            totalRecordCount: 'number',
        };
    }
}
exports.QueryNotifyResponseBodyData = QueryNotifyResponseBodyData;
class RemoveTagsFromResourceRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.RemoveTagsFromResourceRequestTag = RemoveTagsFromResourceRequestTag;
class TagResourcesRequestTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.TagResourcesRequestTag = TagResourcesRequestTag;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "regional";
        this._endpointMap = {
            'cn-qingdao': "rds.aliyuncs.com",
            'cn-beijing': "rds.aliyuncs.com",
            'cn-hangzhou': "rds.aliyuncs.com",
            'cn-shanghai': "rds.aliyuncs.com",
            'cn-shenzhen': "rds.aliyuncs.com",
            'cn-heyuan': "rds.aliyuncs.com",
            'cn-hongkong': "rds.aliyuncs.com",
            'ap-southeast-1': "rds.aliyuncs.com",
            'us-west-1': "rds.aliyuncs.com",
            'us-east-1': "rds.aliyuncs.com",
            'cn-shanghai-finance-1': "rds.aliyuncs.com",
            'cn-shenzhen-finance-1': "rds.aliyuncs.com",
            'cn-north-2-gov-1': "rds.aliyuncs.com",
            'ap-northeast-2-pop': "rds.aliyuncs.com",
            'cn-beijing-finance-1': "rds.aliyuncs.com",
            'cn-beijing-finance-pop': "rds.aliyuncs.com",
            'cn-beijing-gov-1': "rds.aliyuncs.com",
            'cn-beijing-nu16-b01': "rds.aliyuncs.com",
            'cn-edge-1': "rds.aliyuncs.com",
            'cn-fujian': "rds.aliyuncs.com",
            'cn-haidian-cm12-c01': "rds.aliyuncs.com",
            'cn-hangzhou-bj-b01': "rds.aliyuncs.com",
            'cn-hangzhou-finance': "rds-vpc.cn-hangzhou-finance.aliyuncs.com",
            'cn-hangzhou-internal-prod-1': "rds.aliyuncs.com",
            'cn-hangzhou-internal-test-1': "rds.aliyuncs.com",
            'cn-hangzhou-internal-test-2': "rds.aliyuncs.com",
            'cn-hangzhou-internal-test-3': "rds.aliyuncs.com",
            'cn-hangzhou-test-306': "rds.aliyuncs.com",
            'cn-hongkong-finance-pop': "rds.aliyuncs.com",
            'cn-qingdao-nebula': "rds.aliyuncs.com",
            'cn-shanghai-et15-b01': "rds.aliyuncs.com",
            'cn-shanghai-et2-b01': "rds.aliyuncs.com",
            'cn-shanghai-inner': "rds.aliyuncs.com",
            'cn-shanghai-internal-test-1': "rds.aliyuncs.com",
            'cn-shenzhen-inner': "rds.aliyuncs.com",
            'cn-shenzhen-st4-d01': "rds.aliyuncs.com",
            'cn-shenzhen-su18-b01': "rds.aliyuncs.com",
            'cn-wuhan': "rds.aliyuncs.com",
            'cn-yushanfang': "rds.aliyuncs.com",
            'cn-zhangbei': "rds.aliyuncs.com",
            'cn-zhangbei-na61-b01': "rds.aliyuncs.com",
            'cn-zhangjiakou-na62-a01': "rds.aliyuncs.com",
            'cn-zhengzhou-nebula-1': "rds.aliyuncs.com",
            'eu-west-1-oxs': "rds.aliyuncs.com",
            'rus-west-1-pop': "rds.aliyuncs.com",
        };
        this.checkConfig(config);
        this._endpoint = this.getEndpoint("rds", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
    }
    getEndpoint(productId, regionId, endpointRule, network, suffix, endpointMap, endpoint) {
        if (!tea_util_1.default.empty(endpoint)) {
            return endpoint;
        }
        if (!tea_util_1.default.isUnset(endpointMap) && !tea_util_1.default.empty(endpointMap[regionId])) {
            return endpointMap[regionId];
        }
        return endpoint_util_1.default.getEndpointRules(productId, regionId, endpointRule, network, suffix);
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Use the cloud migration feature](~~365562~~)
      *
      * @param request ActivateMigrationTargetInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ActivateMigrationTargetInstanceResponse
     */
    async activateMigrationTargetInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceName)) {
            query["DBInstanceName"] = request.DBInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.forceSwitch)) {
            query["ForceSwitch"] = request.forceSwitch;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.switchTime)) {
            query["SwitchTime"] = request.switchTime;
        }
        if (!tea_util_1.default.isUnset(request.switchTimeMode)) {
            query["SwitchTimeMode"] = request.switchTimeMode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ActivateMigrationTargetInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ActivateMigrationTargetInstanceResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Use the cloud migration feature](~~365562~~)
      *
      * @param request ActivateMigrationTargetInstanceRequest
      * @return ActivateMigrationTargetInstanceResponse
     */
    async activateMigrationTargetInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.activateMigrationTargetInstanceWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)Usage notes
      * *   Each tag consists of a tag key and a tag value. The tag key is required, and the tag value is optional.
      * *   The tag key and tag value cannot start with aliyun.
      * *   The tag key and tag value are not case-sensitive.
      * *   The maximum length of a tag key is 64 characters, and the maximum length of a tag value is 128 characters.
      * *   A maximum of 10 tags can be added to each instance. Each tag that is added to the same instance must have a unique tag key. If you add a new tag to the instance and the key of the new tag is the same as that of an existing tag, the new tag overwrites the existing tag.
      *
      * @param request AddTagsToResourceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return AddTagsToResourceResponse
     */
    async addTagsToResourceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            query["Tags"] = request.tags;
        }
        if (!tea_util_1.default.isUnset(request.proxyId)) {
            query["proxyId"] = request.proxyId;
        }
        if (!tea_util_1.default.isUnset(request.tag)) {
            query["Tag"] = request.tag;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "AddTagsToResource",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new AddTagsToResourceResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)Usage notes
      * *   Each tag consists of a tag key and a tag value. The tag key is required, and the tag value is optional.
      * *   The tag key and tag value cannot start with aliyun.
      * *   The tag key and tag value are not case-sensitive.
      * *   The maximum length of a tag key is 64 characters, and the maximum length of a tag value is 128 characters.
      * *   A maximum of 10 tags can be added to each instance. Each tag that is added to the same instance must have a unique tag key. If you add a new tag to the instance and the key of the new tag is the same as that of an existing tag, the new tag overwrites the existing tag.
      *
      * @param request AddTagsToResourceRequest
      * @return AddTagsToResourceResponse
     */
    async addTagsToResource(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.addTagsToResourceWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Apply for a public endpoint for an ApsaraDB RDS for MySQL instance](~~26128~~)
      * *   [Apply for a public endpoint for an ApsaraDB RDS for PostgreSQL instance](~~97738~~)
      * *   [Apply for a public endpoint for an ApsaraDB RDS for SQL Server instance](~~97736~~)
      * *   [Apply for a public endpoint for an ApsaraDB RDS for MariaDB instance](~~97740~~)
      *
      * @param request AllocateInstancePublicConnectionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return AllocateInstancePublicConnectionResponse
     */
    async allocateInstancePublicConnectionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.babelfishPort)) {
            query["BabelfishPort"] = request.babelfishPort;
        }
        if (!tea_util_1.default.isUnset(request.connectionStringPrefix)) {
            query["ConnectionStringPrefix"] = request.connectionStringPrefix;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.generalGroupName)) {
            query["GeneralGroupName"] = request.generalGroupName;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.PGBouncerPort)) {
            query["PGBouncerPort"] = request.PGBouncerPort;
        }
        if (!tea_util_1.default.isUnset(request.port)) {
            query["Port"] = request.port;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "AllocateInstancePublicConnection",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new AllocateInstancePublicConnectionResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Apply for a public endpoint for an ApsaraDB RDS for MySQL instance](~~26128~~)
      * *   [Apply for a public endpoint for an ApsaraDB RDS for PostgreSQL instance](~~97738~~)
      * *   [Apply for a public endpoint for an ApsaraDB RDS for SQL Server instance](~~97736~~)
      * *   [Apply for a public endpoint for an ApsaraDB RDS for MariaDB instance](~~97740~~)
      *
      * @param request AllocateInstancePublicConnectionRequest
      * @return AllocateInstancePublicConnectionResponse
     */
    async allocateInstancePublicConnection(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.allocateInstancePublicConnectionWithOptions(request, runtime);
    }
    /**
      * If read-only instances are attached to a primary ApsaraDB RDS for SQL Server instance, you can call this operation to apply for a unified read-only routing endpoint for the primary instance. After you apply for a read-only routing endpoint for a primary instance, the existing endpoints of the primary instance and its read-only instances remain valid. In addition, you can still apply for internal and public endpoints.
      * Before you call this operation, make sure that the following requirements are met:
      * *   If the instance runs MySQL, the instance uses a shared proxy.
      * *   The instance is in the Running state.
      * *   Read-only instances are attached to the primary instance.
      * *   The instance does not have an ongoing Data Transmission Service (DTS) migration task.
      * *   The instance runs one of the following database versions and RDS editions:
      *     *   SQL Server (cluster edition)
      *     *   MySQL 5.7 on RDS High-availability Edition with local SSDs
      *     *   MySQL 5.6
      *
      * @param request AllocateReadWriteSplittingConnectionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return AllocateReadWriteSplittingConnectionResponse
     */
    async allocateReadWriteSplittingConnectionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.connectionStringPrefix)) {
            query["ConnectionStringPrefix"] = request.connectionStringPrefix;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.distributionType)) {
            query["DistributionType"] = request.distributionType;
        }
        if (!tea_util_1.default.isUnset(request.maxDelayTime)) {
            query["MaxDelayTime"] = request.maxDelayTime;
        }
        if (!tea_util_1.default.isUnset(request.netType)) {
            query["NetType"] = request.netType;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.port)) {
            query["Port"] = request.port;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.weight)) {
            query["Weight"] = request.weight;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "AllocateReadWriteSplittingConnection",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new AllocateReadWriteSplittingConnectionResponse({}));
    }
    /**
      * If read-only instances are attached to a primary ApsaraDB RDS for SQL Server instance, you can call this operation to apply for a unified read-only routing endpoint for the primary instance. After you apply for a read-only routing endpoint for a primary instance, the existing endpoints of the primary instance and its read-only instances remain valid. In addition, you can still apply for internal and public endpoints.
      * Before you call this operation, make sure that the following requirements are met:
      * *   If the instance runs MySQL, the instance uses a shared proxy.
      * *   The instance is in the Running state.
      * *   Read-only instances are attached to the primary instance.
      * *   The instance does not have an ongoing Data Transmission Service (DTS) migration task.
      * *   The instance runs one of the following database versions and RDS editions:
      *     *   SQL Server (cluster edition)
      *     *   MySQL 5.7 on RDS High-availability Edition with local SSDs
      *     *   MySQL 5.6
      *
      * @param request AllocateReadWriteSplittingConnectionRequest
      * @return AllocateReadWriteSplittingConnectionResponse
     */
    async allocateReadWriteSplittingConnection(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.allocateReadWriteSplittingConnectionWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      *
      * @param request AttachWhitelistTemplateToInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return AttachWhitelistTemplateToInstanceResponse
     */
    async attachWhitelistTemplateToInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.insName)) {
            query["InsName"] = request.insName;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.templateId)) {
            query["TemplateId"] = request.templateId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "AttachWhitelistTemplateToInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new AttachWhitelistTemplateToInstanceResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      *
      * @param request AttachWhitelistTemplateToInstanceRequest
      * @return AttachWhitelistTemplateToInstanceResponse
     */
    async attachWhitelistTemplateToInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.attachWhitelistTemplateToInstanceWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### [](#)Feature description
      * When the [read/write splitting](~~51073~~) feature is enabled, this operation is used to calculate system-assigned read weights. For more information about custom read weights, see [DescribeDBInstanceNetInfo](~~610423~~).
      * ### [](#)Prerequisites
      * Before you call this operation, make sure that the following requirements are met:
      * *   If the instance runs MySQL, the instance uses a shared proxy.
      * *   The instance runs one of the following MySQL versions and RDS editions:
      *     *   MySQL 5.7 on RDS High-availability Edition (with local disks)
      *     *   MySQL 5.6
      *     *   SQL Server on RDS Cluster Edition
      *
      * @param request CalculateDBInstanceWeightRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CalculateDBInstanceWeightResponse
     */
    async calculateDBInstanceWeightWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CalculateDBInstanceWeight",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CalculateDBInstanceWeightResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### [](#)Feature description
      * When the [read/write splitting](~~51073~~) feature is enabled, this operation is used to calculate system-assigned read weights. For more information about custom read weights, see [DescribeDBInstanceNetInfo](~~610423~~).
      * ### [](#)Prerequisites
      * Before you call this operation, make sure that the following requirements are met:
      * *   If the instance runs MySQL, the instance uses a shared proxy.
      * *   The instance runs one of the following MySQL versions and RDS editions:
      *     *   MySQL 5.7 on RDS High-availability Edition (with local disks)
      *     *   MySQL 5.6
      *     *   SQL Server on RDS Cluster Edition
      *
      * @param request CalculateDBInstanceWeightRequest
      * @return CalculateDBInstanceWeightResponse
     */
    async calculateDBInstanceWeight(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.calculateDBInstanceWeightWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engine
      * *   SQL Server
      * ### [](#)Usage notes
      * This operation is supported for instances that run SQL Server and belong to the dedicated or dedicated host instance family. For more information about how to start a migration task, see [ImportDatabaseBetweenInstances](~~610592~~).
      * ### [](#)Precautions
      * This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition.
      *
      * @param request CancelImportRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CancelImportResponse
     */
    async cancelImportWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.importId)) {
            query["ImportId"] = request.importId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CancelImport",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CancelImportResponse({}));
    }
    /**
      * ### [](#)Supported database engine
      * *   SQL Server
      * ### [](#)Usage notes
      * This operation is supported for instances that run SQL Server and belong to the dedicated or dedicated host instance family. For more information about how to start a migration task, see [ImportDatabaseBetweenInstances](~~610592~~).
      * ### [](#)Precautions
      * This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition.
      *
      * @param request CancelImportRequest
      * @return CancelImportResponse
     */
    async cancelImport(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.cancelImportWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request CheckAccountNameAvailableRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CheckAccountNameAvailableResponse
     */
    async checkAccountNameAvailableWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountName)) {
            query["AccountName"] = request.accountName;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CheckAccountNameAvailable",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CheckAccountNameAvailableResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request CheckAccountNameAvailableRequest
      * @return CheckAccountNameAvailableResponse
     */
    async checkAccountNameAvailable(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.checkAccountNameAvailableWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request CheckCloudResourceAuthorizedRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CheckCloudResourceAuthorizedResponse
     */
    async checkCloudResourceAuthorizedWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        if (!tea_util_1.default.isUnset(request.targetRegionId)) {
            query["TargetRegionId"] = request.targetRegionId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CheckCloudResourceAuthorized",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CheckCloudResourceAuthorizedResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request CheckCloudResourceAuthorizedRequest
      * @return CheckCloudResourceAuthorizedResponse
     */
    async checkCloudResourceAuthorized(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.checkCloudResourceAuthorizedWithOptions(request, runtime);
    }
    /**
      * Before you call this operation, make sure that the instance runs one of the following database engines:
      * *   MySQL. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~).
      * *   SQL Server. For more information, see [Back up an ApsaraDB RDS for SQL Server instance across regions](~~187923~~).
      * *   PostgreSQL. For more information, see [Enable cross-region backups for an ApsaraDB RDS for PostgreSQL instance](~~206671~~).
      * > : If your RDS instance uses the new architecture and is created after October 10, 2022, this feature is not supported for the RDS instance. For more information, see [\\[Notice\\] SLR authorization is required to create an ApsaraDB RDS for PostgreSQL instance from October 10, 2022](~~452313~~).
      *
      * @param request CheckCreateDdrDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CheckCreateDdrDBInstanceResponse
     */
    async checkCreateDdrDBInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupSetId)) {
            query["BackupSetId"] = request.backupSetId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceClass)) {
            query["DBInstanceClass"] = request.DBInstanceClass;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorage)) {
            query["DBInstanceStorage"] = request.DBInstanceStorage;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.restoreTime)) {
            query["RestoreTime"] = request.restoreTime;
        }
        if (!tea_util_1.default.isUnset(request.restoreType)) {
            query["RestoreType"] = request.restoreType;
        }
        if (!tea_util_1.default.isUnset(request.sourceDBInstanceName)) {
            query["SourceDBInstanceName"] = request.sourceDBInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.sourceRegion)) {
            query["SourceRegion"] = request.sourceRegion;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CheckCreateDdrDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CheckCreateDdrDBInstanceResponse({}));
    }
    /**
      * Before you call this operation, make sure that the instance runs one of the following database engines:
      * *   MySQL. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~).
      * *   SQL Server. For more information, see [Back up an ApsaraDB RDS for SQL Server instance across regions](~~187923~~).
      * *   PostgreSQL. For more information, see [Enable cross-region backups for an ApsaraDB RDS for PostgreSQL instance](~~206671~~).
      * > : If your RDS instance uses the new architecture and is created after October 10, 2022, this feature is not supported for the RDS instance. For more information, see [\\[Notice\\] SLR authorization is required to create an ApsaraDB RDS for PostgreSQL instance from October 10, 2022](~~452313~~).
      *
      * @param request CheckCreateDdrDBInstanceRequest
      * @return CheckCreateDdrDBInstanceResponse
     */
    async checkCreateDdrDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.checkCreateDdrDBInstanceWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request CheckDBNameAvailableRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CheckDBNameAvailableResponse
     */
    async checkDBNameAvailableWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CheckDBNameAvailable",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CheckDBNameAvailableResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request CheckDBNameAvailableRequest
      * @return CheckDBNameAvailableResponse
     */
    async checkDBNameAvailable(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.checkDBNameAvailableWithOptions(request, runtime);
    }
    async checkInstanceExistWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CheckInstanceExist",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CheckInstanceExistResponse({}));
    }
    async checkInstanceExist(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.checkInstanceExistWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      *
      * @param request CheckServiceLinkedRoleRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CheckServiceLinkedRoleResponse
     */
    async checkServiceLinkedRoleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.serviceLinkedRole)) {
            query["ServiceLinkedRole"] = request.serviceLinkedRole;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CheckServiceLinkedRole",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CheckServiceLinkedRoleResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      *
      * @param request CheckServiceLinkedRoleRequest
      * @return CheckServiceLinkedRoleResponse
     */
    async checkServiceLinkedRole(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.checkServiceLinkedRoleWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Restore data of an ApsaraDB RDS for MySQL instance](~~96147~~)
      * *   [Restore data of an ApsaraDB RDS for PostgreSQL instance](~~96776~~)
      * *   [Restore data of an ApsaraDB RDS for SQL Server instance](~~95722~~)
      * *   [Restore data of an ApsaraDB RDS for MariaDB instance](~~97151~~)
      *
      * @param tmpReq CloneDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CloneDBInstanceResponse
     */
    async cloneDBInstanceWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new CloneDBInstanceShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.serverlessConfig)) {
            request.serverlessConfigShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.serverlessConfig, "ServerlessConfig", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.autoPay)) {
            query["AutoPay"] = request.autoPay;
        }
        if (!tea_util_1.default.isUnset(request.backupId)) {
            query["BackupId"] = request.backupId;
        }
        if (!tea_util_1.default.isUnset(request.backupType)) {
            query["BackupType"] = request.backupType;
        }
        if (!tea_util_1.default.isUnset(request.bpeEnabled)) {
            query["BpeEnabled"] = request.bpeEnabled;
        }
        if (!tea_util_1.default.isUnset(request.burstingEnabled)) {
            query["BurstingEnabled"] = request.burstingEnabled;
        }
        if (!tea_util_1.default.isUnset(request.category)) {
            query["Category"] = request.category;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceClass)) {
            query["DBInstanceClass"] = request.DBInstanceClass;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorage)) {
            query["DBInstanceStorage"] = request.DBInstanceStorage;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorageType)) {
            query["DBInstanceStorageType"] = request.DBInstanceStorageType;
        }
        if (!tea_util_1.default.isUnset(request.dbNames)) {
            query["DbNames"] = request.dbNames;
        }
        if (!tea_util_1.default.isUnset(request.dedicatedHostGroupId)) {
            query["DedicatedHostGroupId"] = request.dedicatedHostGroupId;
        }
        if (!tea_util_1.default.isUnset(request.deletionProtection)) {
            query["DeletionProtection"] = request.deletionProtection;
        }
        if (!tea_util_1.default.isUnset(request.instanceNetworkType)) {
            query["InstanceNetworkType"] = request.instanceNetworkType;
        }
        if (!tea_util_1.default.isUnset(request.payType)) {
            query["PayType"] = request.payType;
        }
        if (!tea_util_1.default.isUnset(request.period)) {
            query["Period"] = request.period;
        }
        if (!tea_util_1.default.isUnset(request.privateIpAddress)) {
            query["PrivateIpAddress"] = request.privateIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.restoreTable)) {
            query["RestoreTable"] = request.restoreTable;
        }
        if (!tea_util_1.default.isUnset(request.restoreTime)) {
            query["RestoreTime"] = request.restoreTime;
        }
        if (!tea_util_1.default.isUnset(request.serverlessConfigShrink)) {
            query["ServerlessConfig"] = request.serverlessConfigShrink;
        }
        if (!tea_util_1.default.isUnset(request.tableMeta)) {
            query["TableMeta"] = request.tableMeta;
        }
        if (!tea_util_1.default.isUnset(request.usedTime)) {
            query["UsedTime"] = request.usedTime;
        }
        if (!tea_util_1.default.isUnset(request.VPCId)) {
            query["VPCId"] = request.VPCId;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        if (!tea_util_1.default.isUnset(request.zoneIdSlave1)) {
            query["ZoneIdSlave1"] = request.zoneIdSlave1;
        }
        if (!tea_util_1.default.isUnset(request.zoneIdSlave2)) {
            query["ZoneIdSlave2"] = request.zoneIdSlave2;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CloneDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CloneDBInstanceResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Restore data of an ApsaraDB RDS for MySQL instance](~~96147~~)
      * *   [Restore data of an ApsaraDB RDS for PostgreSQL instance](~~96776~~)
      * *   [Restore data of an ApsaraDB RDS for SQL Server instance](~~95722~~)
      * *   [Restore data of an ApsaraDB RDS for MariaDB instance](~~97151~~)
      *
      * @param request CloneDBInstanceRequest
      * @return CloneDBInstanceResponse
     */
    async cloneDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.cloneDBInstanceWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
      *
      * @param request CloneParameterGroupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CloneParameterGroupResponse
     */
    async cloneParameterGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.parameterGroupDesc)) {
            query["ParameterGroupDesc"] = request.parameterGroupDesc;
        }
        if (!tea_util_1.default.isUnset(request.parameterGroupId)) {
            query["ParameterGroupId"] = request.parameterGroupId;
        }
        if (!tea_util_1.default.isUnset(request.parameterGroupName)) {
            query["ParameterGroupName"] = request.parameterGroupName;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.targetRegionId)) {
            query["TargetRegionId"] = request.targetRegionId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CloneParameterGroup",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CloneParameterGroupResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
      *
      * @param request CloneParameterGroupRequest
      * @return CloneParameterGroupResponse
     */
    async cloneParameterGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.cloneParameterGroupWithOptions(request, runtime);
    }
    /**
      * After you call the QueryNotify operation to query notifications for an instance, you can call this operation to mark the notifications as confirmed. For more information, see [Query notifications for an ApsaraDB RDS instance](~~427959~~).
      *
      * @param tmpReq ConfirmNotifyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ConfirmNotifyResponse
     */
    async confirmNotifyWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new ConfirmNotifyShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.notifyIdList)) {
            request.notifyIdListShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.notifyIdList, "NotifyIdList", "json");
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.confirmor)) {
            body["Confirmor"] = request.confirmor;
        }
        if (!tea_util_1.default.isUnset(request.notifyIdListShrink)) {
            body["NotifyIdList"] = request.notifyIdListShrink;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ConfirmNotify",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ConfirmNotifyResponse({}));
    }
    /**
      * After you call the QueryNotify operation to query notifications for an instance, you can call this operation to mark the notifications as confirmed. For more information, see [Query notifications for an ApsaraDB RDS instance](~~427959~~).
      *
      * @param request ConfirmNotifyRequest
      * @return ConfirmNotifyResponse
     */
    async confirmNotify(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.confirmNotifyWithOptions(request, runtime);
    }
    /**
      * This operation is phased out.
      *
      * @param request CopyDatabaseRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CopyDatabaseResponse
     */
    async copyDatabaseWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CopyDatabase",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CopyDatabaseResponse({}));
    }
    /**
      * This operation is phased out.
      *
      * @param request CopyDatabaseRequest
      * @return CopyDatabaseResponse
     */
    async copyDatabase(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.copyDatabaseWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * RDS SQL Server
      * ### References
      * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Replicate databases between ApsaraDB RDS for SQL Server instances](~~95702~~)
      *
      * @param request CopyDatabaseBetweenInstancesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CopyDatabaseBetweenInstancesResponse
     */
    async copyDatabaseBetweenInstancesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupId)) {
            query["BackupId"] = request.backupId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.dbNames)) {
            query["DbNames"] = request.dbNames;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.restoreTime)) {
            query["RestoreTime"] = request.restoreTime;
        }
        if (!tea_util_1.default.isUnset(request.syncUserPrivilege)) {
            query["SyncUserPrivilege"] = request.syncUserPrivilege;
        }
        if (!tea_util_1.default.isUnset(request.targetDBInstanceId)) {
            query["TargetDBInstanceId"] = request.targetDBInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CopyDatabaseBetweenInstances",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CopyDatabaseBetweenInstancesResponse({}));
    }
    /**
      * ### Supported database engines
      * RDS SQL Server
      * ### References
      * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Replicate databases between ApsaraDB RDS for SQL Server instances](~~95702~~)
      *
      * @param request CopyDatabaseBetweenInstancesRequest
      * @return CopyDatabaseBetweenInstancesResponse
     */
    async copyDatabaseBetweenInstances(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.copyDatabaseBetweenInstancesWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      * ### References
      * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Create an account on an ApsaraDB RDS for MySQL instance](~~96089~~)
      * *   [Create an account on an ApsaraDB RDS for PostgreSQL instance](~~96753~~)
      * *   [Create an account on an ApsaraDB RDS for SQL Server instance](~~95810~~)
      * *   [Create an account on an ApsaraDB RDS for MariaDB instance](~~97132~~)
      *
      * @param request CreateAccountRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateAccountResponse
     */
    async createAccountWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountDescription)) {
            query["AccountDescription"] = request.accountDescription;
        }
        if (!tea_util_1.default.isUnset(request.accountName)) {
            query["AccountName"] = request.accountName;
        }
        if (!tea_util_1.default.isUnset(request.accountPassword)) {
            query["AccountPassword"] = request.accountPassword;
        }
        if (!tea_util_1.default.isUnset(request.accountType)) {
            query["AccountType"] = request.accountType;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateAccount",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateAccountResponse({}));
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      * ### References
      * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Create an account on an ApsaraDB RDS for MySQL instance](~~96089~~)
      * *   [Create an account on an ApsaraDB RDS for PostgreSQL instance](~~96753~~)
      * *   [Create an account on an ApsaraDB RDS for SQL Server instance](~~95810~~)
      * *   [Create an account on an ApsaraDB RDS for MariaDB instance](~~97132~~)
      *
      * @param request CreateAccountRequest
      * @return CreateAccountResponse
     */
    async createAccount(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createAccountWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)Usage notes
      * This operation uses the backup feature of ApsaraDB RDS to create a backup set. You can also use an operation of Database Backup (DBS) to create a backup set. For more information, see [List of operations by function of DBS](~~437245~~).
      * ### [](#)Precautions
      * Before you call this operation, make sure that the following requirements are met:
      * *   The instance is in the Running state.
      * *   The instance does not have ongoing backup tasks.
      * *   The number of backup files that are created per day for an instance cannot exceed 20.
      * ### [](#)References
      * *   [Use the data backup feature for an ApsaraDB RDS for MySQL instance](~~378074~~)
      * *   [Use the data backup feature for an ApsaraDB RDS for PostgreSQL instance](~~96772~~)
      * *   [Use the data backup feature for an ApsaraDB RDS for SQL Server instance](~~95717~~)
      * *   [Use the data backup feature for an ApsaraDB RDS for MariaDB instance](~~97147~~)
      *
      * @param request CreateBackupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateBackupResponse
     */
    async createBackupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupMethod)) {
            query["BackupMethod"] = request.backupMethod;
        }
        if (!tea_util_1.default.isUnset(request.backupStrategy)) {
            query["BackupStrategy"] = request.backupStrategy;
        }
        if (!tea_util_1.default.isUnset(request.backupType)) {
            query["BackupType"] = request.backupType;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateBackup",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateBackupResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)Usage notes
      * This operation uses the backup feature of ApsaraDB RDS to create a backup set. You can also use an operation of Database Backup (DBS) to create a backup set. For more information, see [List of operations by function of DBS](~~437245~~).
      * ### [](#)Precautions
      * Before you call this operation, make sure that the following requirements are met:
      * *   The instance is in the Running state.
      * *   The instance does not have ongoing backup tasks.
      * *   The number of backup files that are created per day for an instance cannot exceed 20.
      * ### [](#)References
      * *   [Use the data backup feature for an ApsaraDB RDS for MySQL instance](~~378074~~)
      * *   [Use the data backup feature for an ApsaraDB RDS for PostgreSQL instance](~~96772~~)
      * *   [Use the data backup feature for an ApsaraDB RDS for SQL Server instance](~~95717~~)
      * *   [Use the data backup feature for an ApsaraDB RDS for MariaDB instance](~~97147~~)
      *
      * @param request CreateBackupRequest
      * @return CreateBackupResponse
     */
    async createBackup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createBackupWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Use the cloud migration feature](~~365562~~)
      *
      * @param request CreateCloudMigrationPrecheckTaskRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateCloudMigrationPrecheckTaskResponse
     */
    async createCloudMigrationPrecheckTaskWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceName)) {
            query["DBInstanceName"] = request.DBInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.sourceAccount)) {
            query["SourceAccount"] = request.sourceAccount;
        }
        if (!tea_util_1.default.isUnset(request.sourceCategory)) {
            query["SourceCategory"] = request.sourceCategory;
        }
        if (!tea_util_1.default.isUnset(request.sourceIpAddress)) {
            query["SourceIpAddress"] = request.sourceIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.sourcePassword)) {
            query["SourcePassword"] = request.sourcePassword;
        }
        if (!tea_util_1.default.isUnset(request.sourcePort)) {
            query["SourcePort"] = request.sourcePort;
        }
        if (!tea_util_1.default.isUnset(request.taskName)) {
            query["TaskName"] = request.taskName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateCloudMigrationPrecheckTask",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateCloudMigrationPrecheckTaskResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Use the cloud migration feature](~~365562~~)
      *
      * @param request CreateCloudMigrationPrecheckTaskRequest
      * @return CreateCloudMigrationPrecheckTaskResponse
     */
    async createCloudMigrationPrecheckTask(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createCloudMigrationPrecheckTaskWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Use the cloud migration feature](~~365562~~)
      *
      * @param request CreateCloudMigrationTaskRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateCloudMigrationTaskResponse
     */
    async createCloudMigrationTaskWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceName)) {
            query["DBInstanceName"] = request.DBInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.sourceAccount)) {
            query["SourceAccount"] = request.sourceAccount;
        }
        if (!tea_util_1.default.isUnset(request.sourceCategory)) {
            query["SourceCategory"] = request.sourceCategory;
        }
        if (!tea_util_1.default.isUnset(request.sourceIpAddress)) {
            query["SourceIpAddress"] = request.sourceIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.sourcePassword)) {
            query["SourcePassword"] = request.sourcePassword;
        }
        if (!tea_util_1.default.isUnset(request.sourcePort)) {
            query["SourcePort"] = request.sourcePort;
        }
        if (!tea_util_1.default.isUnset(request.taskName)) {
            query["TaskName"] = request.taskName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateCloudMigrationTask",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateCloudMigrationTaskResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Use the cloud migration feature](~~365562~~)
      *
      * @param request CreateCloudMigrationTaskRequest
      * @return CreateCloudMigrationTaskResponse
     */
    async createCloudMigrationTask(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createCloudMigrationTaskWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      * ### References
      * > : Fees are generated if the call is successful. Before you call this operation, carefully read the following documentation:
      * *   [Create an ApsaraDB RDS for MySQL instance](~~148036~~)
      * *   [Create a serverless ApsaraDB RDS for MySQL instance](~~412231~~)
      * *   [Create an ApsaraDB RDS for PostgreSQL instance](~~148038~~)
      * *   [Create a serverless ApsaraDB RDS for PostgreSQL instance](~~607753~~)
      * *   [Enable Babelfish for an ApsaraDB RDS for PostgreSQL instance](~~428615~~)
      * *   [Create an ApsaraDB RDS for SQL Server instance](~~148037~~)
      * *   [Create a serverless ApsaraDB RDS for SQL Server instance](~~603465~~)
      * *   [Create an ApsaraDB RDS for MariaDB instance](~~148040~~)
      *
      * @param tmpReq CreateDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateDBInstanceResponse
     */
    async createDBInstanceWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new CreateDBInstanceShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.serverlessConfig)) {
            request.serverlessConfigShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.serverlessConfig, "ServerlessConfig", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.amount)) {
            query["Amount"] = request.amount;
        }
        if (!tea_util_1.default.isUnset(request.autoPay)) {
            query["AutoPay"] = request.autoPay;
        }
        if (!tea_util_1.default.isUnset(request.autoRenew)) {
            query["AutoRenew"] = request.autoRenew;
        }
        if (!tea_util_1.default.isUnset(request.babelfishConfig)) {
            query["BabelfishConfig"] = request.babelfishConfig;
        }
        if (!tea_util_1.default.isUnset(request.bpeEnabled)) {
            query["BpeEnabled"] = request.bpeEnabled;
        }
        if (!tea_util_1.default.isUnset(request.burstingEnabled)) {
            query["BurstingEnabled"] = request.burstingEnabled;
        }
        if (!tea_util_1.default.isUnset(request.businessInfo)) {
            query["BusinessInfo"] = request.businessInfo;
        }
        if (!tea_util_1.default.isUnset(request.category)) {
            query["Category"] = request.category;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.connectionMode)) {
            query["ConnectionMode"] = request.connectionMode;
        }
        if (!tea_util_1.default.isUnset(request.connectionString)) {
            query["ConnectionString"] = request.connectionString;
        }
        if (!tea_util_1.default.isUnset(request.createStrategy)) {
            query["CreateStrategy"] = request.createStrategy;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceClass)) {
            query["DBInstanceClass"] = request.DBInstanceClass;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceDescription)) {
            query["DBInstanceDescription"] = request.DBInstanceDescription;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceNetType)) {
            query["DBInstanceNetType"] = request.DBInstanceNetType;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorage)) {
            query["DBInstanceStorage"] = request.DBInstanceStorage;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorageType)) {
            query["DBInstanceStorageType"] = request.DBInstanceStorageType;
        }
        if (!tea_util_1.default.isUnset(request.DBIsIgnoreCase)) {
            query["DBIsIgnoreCase"] = request.DBIsIgnoreCase;
        }
        if (!tea_util_1.default.isUnset(request.DBParamGroupId)) {
            query["DBParamGroupId"] = request.DBParamGroupId;
        }
        if (!tea_util_1.default.isUnset(request.DBTimeZone)) {
            query["DBTimeZone"] = request.DBTimeZone;
        }
        if (!tea_util_1.default.isUnset(request.dedicatedHostGroupId)) {
            query["DedicatedHostGroupId"] = request.dedicatedHostGroupId;
        }
        if (!tea_util_1.default.isUnset(request.deletionProtection)) {
            query["DeletionProtection"] = request.deletionProtection;
        }
        if (!tea_util_1.default.isUnset(request.dryRun)) {
            query["DryRun"] = request.dryRun;
        }
        if (!tea_util_1.default.isUnset(request.encryptionKey)) {
            query["EncryptionKey"] = request.encryptionKey;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.instanceNetworkType)) {
            query["InstanceNetworkType"] = request.instanceNetworkType;
        }
        if (!tea_util_1.default.isUnset(request.payType)) {
            query["PayType"] = request.payType;
        }
        if (!tea_util_1.default.isUnset(request.period)) {
            query["Period"] = request.period;
        }
        if (!tea_util_1.default.isUnset(request.port)) {
            query["Port"] = request.port;
        }
        if (!tea_util_1.default.isUnset(request.privateIpAddress)) {
            query["PrivateIpAddress"] = request.privateIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.roleARN)) {
            query["RoleARN"] = request.roleARN;
        }
        if (!tea_util_1.default.isUnset(request.securityIPList)) {
            query["SecurityIPList"] = request.securityIPList;
        }
        if (!tea_util_1.default.isUnset(request.serverlessConfigShrink)) {
            query["ServerlessConfig"] = request.serverlessConfigShrink;
        }
        if (!tea_util_1.default.isUnset(request.storageAutoScale)) {
            query["StorageAutoScale"] = request.storageAutoScale;
        }
        if (!tea_util_1.default.isUnset(request.storageThreshold)) {
            query["StorageThreshold"] = request.storageThreshold;
        }
        if (!tea_util_1.default.isUnset(request.storageUpperBound)) {
            query["StorageUpperBound"] = request.storageUpperBound;
        }
        if (!tea_util_1.default.isUnset(request.systemDBCharset)) {
            query["SystemDBCharset"] = request.systemDBCharset;
        }
        if (!tea_util_1.default.isUnset(request.tag)) {
            query["Tag"] = request.tag;
        }
        if (!tea_util_1.default.isUnset(request.targetDedicatedHostIdForLog)) {
            query["TargetDedicatedHostIdForLog"] = request.targetDedicatedHostIdForLog;
        }
        if (!tea_util_1.default.isUnset(request.targetDedicatedHostIdForMaster)) {
            query["TargetDedicatedHostIdForMaster"] = request.targetDedicatedHostIdForMaster;
        }
        if (!tea_util_1.default.isUnset(request.targetDedicatedHostIdForSlave)) {
            query["TargetDedicatedHostIdForSlave"] = request.targetDedicatedHostIdForSlave;
        }
        if (!tea_util_1.default.isUnset(request.targetMinorVersion)) {
            query["TargetMinorVersion"] = request.targetMinorVersion;
        }
        if (!tea_util_1.default.isUnset(request.usedTime)) {
            query["UsedTime"] = request.usedTime;
        }
        if (!tea_util_1.default.isUnset(request.userBackupId)) {
            query["UserBackupId"] = request.userBackupId;
        }
        if (!tea_util_1.default.isUnset(request.VPCId)) {
            query["VPCId"] = request.VPCId;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        if (!tea_util_1.default.isUnset(request.zoneIdSlave1)) {
            query["ZoneIdSlave1"] = request.zoneIdSlave1;
        }
        if (!tea_util_1.default.isUnset(request.zoneIdSlave2)) {
            query["ZoneIdSlave2"] = request.zoneIdSlave2;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDBInstanceResponse({}));
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      * ### References
      * > : Fees are generated if the call is successful. Before you call this operation, carefully read the following documentation:
      * *   [Create an ApsaraDB RDS for MySQL instance](~~148036~~)
      * *   [Create a serverless ApsaraDB RDS for MySQL instance](~~412231~~)
      * *   [Create an ApsaraDB RDS for PostgreSQL instance](~~148038~~)
      * *   [Create a serverless ApsaraDB RDS for PostgreSQL instance](~~607753~~)
      * *   [Enable Babelfish for an ApsaraDB RDS for PostgreSQL instance](~~428615~~)
      * *   [Create an ApsaraDB RDS for SQL Server instance](~~148037~~)
      * *   [Create a serverless ApsaraDB RDS for SQL Server instance](~~603465~~)
      * *   [Create an ApsaraDB RDS for MariaDB instance](~~148040~~)
      *
      * @param request CreateDBInstanceRequest
      * @return CreateDBInstanceResponse
     */
    async createDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDBInstanceWithOptions(request, runtime);
    }
    /**
      * ### Supported database engine
      * MySQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
      * [Add a read-only endpoint for a cluster](~~464132~~)
      *
      * @param tmpReq CreateDBInstanceEndpointRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateDBInstanceEndpointResponse
     */
    async createDBInstanceEndpointWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new CreateDBInstanceEndpointShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.nodeItems)) {
            request.nodeItemsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.nodeItems, "NodeItems", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.connectionStringPrefix)) {
            query["ConnectionStringPrefix"] = request.connectionStringPrefix;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceEndpointDescription)) {
            query["DBInstanceEndpointDescription"] = request.DBInstanceEndpointDescription;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceEndpointType)) {
            query["DBInstanceEndpointType"] = request.DBInstanceEndpointType;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.nodeItemsShrink)) {
            query["NodeItems"] = request.nodeItemsShrink;
        }
        if (!tea_util_1.default.isUnset(request.port)) {
            query["Port"] = request.port;
        }
        if (!tea_util_1.default.isUnset(request.privateIpAddress)) {
            query["PrivateIpAddress"] = request.privateIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        if (!tea_util_1.default.isUnset(request.vpcId)) {
            query["VpcId"] = request.vpcId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateDBInstanceEndpoint",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDBInstanceEndpointResponse({}));
    }
    /**
      * ### Supported database engine
      * MySQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
      * [Add a read-only endpoint for a cluster](~~464132~~)
      *
      * @param request CreateDBInstanceEndpointRequest
      * @return CreateDBInstanceEndpointResponse
     */
    async createDBInstanceEndpoint(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDBInstanceEndpointWithOptions(request, runtime);
    }
    /**
      * ### Supported database engine
      * MySQL
      * ### Precautions
      * *   You can create a public endpoint of an endpoint type only when no public endpoint is created for this endpoint type.
      * *   The node weights and other configurations are the same as those of the internal endpoint of this endpoint type. Only one public endpoint and one internal endpoint can be created for each endpoint type.
      *
      * @param request CreateDBInstanceEndpointAddressRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateDBInstanceEndpointAddressResponse
     */
    async createDBInstanceEndpointAddressWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.connectionStringPrefix)) {
            query["ConnectionStringPrefix"] = request.connectionStringPrefix;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceEndpointId)) {
            query["DBInstanceEndpointId"] = request.DBInstanceEndpointId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ipType)) {
            query["IpType"] = request.ipType;
        }
        if (!tea_util_1.default.isUnset(request.port)) {
            query["Port"] = request.port;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateDBInstanceEndpointAddress",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDBInstanceEndpointAddressResponse({}));
    }
    /**
      * ### Supported database engine
      * MySQL
      * ### Precautions
      * *   You can create a public endpoint of an endpoint type only when no public endpoint is created for this endpoint type.
      * *   The node weights and other configurations are the same as those of the internal endpoint of this endpoint type. Only one public endpoint and one internal endpoint can be created for each endpoint type.
      *
      * @param request CreateDBInstanceEndpointAddressRequest
      * @return CreateDBInstanceEndpointAddressResponse
     */
    async createDBInstanceEndpointAddress(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDBInstanceEndpointAddressWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      * ### References
      * > : Fees are generated if the call is successful. Before you call this operation, carefully read the following documentation:
      * *   [Manage ApsaraDB RDS for MySQL instances in the recycle bin](~~96065~~)
      * *   [Manage ApsaraDB RDS for PostgreSQL instances in the recycle bin](~~96752~~)
      * *   [Manage ApsaraDB RDS for SQL Server instances in the recycle bin](~~95669~~)
      * *   [Manage ApsaraDB RDS for MariaDB instances in the recycle bin](~~97131~~)
      *
      * @param request CreateDBInstanceForRebuildRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateDBInstanceForRebuildResponse
     */
    async createDBInstanceForRebuildWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceDescription)) {
            query["DBInstanceDescription"] = request.DBInstanceDescription;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceNetType)) {
            query["DBInstanceNetType"] = request.DBInstanceNetType;
        }
        if (!tea_util_1.default.isUnset(request.instanceNetworkType)) {
            query["InstanceNetworkType"] = request.instanceNetworkType;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.payType)) {
            query["PayType"] = request.payType;
        }
        if (!tea_util_1.default.isUnset(request.period)) {
            query["Period"] = request.period;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityIPList)) {
            query["SecurityIPList"] = request.securityIPList;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        if (!tea_util_1.default.isUnset(request.usedTime)) {
            query["UsedTime"] = request.usedTime;
        }
        if (!tea_util_1.default.isUnset(request.VPCId)) {
            query["VPCId"] = request.VPCId;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        if (!tea_util_1.default.isUnset(request.zoneIdSlave1)) {
            query["ZoneIdSlave1"] = request.zoneIdSlave1;
        }
        if (!tea_util_1.default.isUnset(request.zoneIdSlave2)) {
            query["ZoneIdSlave2"] = request.zoneIdSlave2;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateDBInstanceForRebuild",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDBInstanceForRebuildResponse({}));
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      * ### References
      * > : Fees are generated if the call is successful. Before you call this operation, carefully read the following documentation:
      * *   [Manage ApsaraDB RDS for MySQL instances in the recycle bin](~~96065~~)
      * *   [Manage ApsaraDB RDS for PostgreSQL instances in the recycle bin](~~96752~~)
      * *   [Manage ApsaraDB RDS for SQL Server instances in the recycle bin](~~95669~~)
      * *   [Manage ApsaraDB RDS for MariaDB instances in the recycle bin](~~97131~~)
      *
      * @param request CreateDBInstanceForRebuildRequest
      * @return CreateDBInstanceForRebuildResponse
     */
    async createDBInstanceForRebuild(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDBInstanceForRebuildWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * MySQL
      * ### References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Add a node to an ApsaraDB RDS for MySQL cluster](~~464129~~)
      *
      * @param tmpReq CreateDBNodesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateDBNodesResponse
     */
    async createDBNodesWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new CreateDBNodesShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.DBNode)) {
            request.DBNodeShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.DBNode, "DBNode", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBNodeShrink)) {
            query["DBNode"] = request.DBNodeShrink;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateDBNodes",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDBNodesResponse({}));
    }
    /**
      * ### Supported database engines
      * MySQL
      * ### References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Add a node to an ApsaraDB RDS for MySQL cluster](~~464129~~)
      *
      * @param request CreateDBNodesRequest
      * @return CreateDBNodesResponse
     */
    async createDBNodes(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDBNodesWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](~~184921~~)
      * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for PostgreSQL instance](~~418274~~)
      *
      * @param request CreateDBProxyEndpointAddressRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateDBProxyEndpointAddressResponse
     */
    async createDBProxyEndpointAddressWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.connectionStringPrefix)) {
            query["ConnectionStringPrefix"] = request.connectionStringPrefix;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyConnectStringNetType)) {
            query["DBProxyConnectStringNetType"] = request.DBProxyConnectStringNetType;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyEndpointId)) {
            query["DBProxyEndpointId"] = request.DBProxyEndpointId;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyEngineType)) {
            query["DBProxyEngineType"] = request.DBProxyEngineType;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyNewConnectStringPort)) {
            query["DBProxyNewConnectStringPort"] = request.DBProxyNewConnectStringPort;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.VPCId)) {
            query["VPCId"] = request.VPCId;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateDBProxyEndpointAddress",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDBProxyEndpointAddressResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](~~184921~~)
      * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for PostgreSQL instance](~~418274~~)
      *
      * @param request CreateDBProxyEndpointAddressRequest
      * @return CreateDBProxyEndpointAddressResponse
     */
    async createDBProxyEndpointAddress(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDBProxyEndpointAddressWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Create a database in an ApsaraDB RDS for MySQL instance](~~96105~~)
      * *   [Create a database in an ApsaraDB RDS for PostgreSQL instance](~~96758~~)
      * *   [Create a database in an ApsaraDB RDS for SQL Server instance](~~95698~~)
      * *   [Create a database in an ApsaraDB RDS for MariaDB instance](~~97136~~)
      *
      * @param request CreateDatabaseRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateDatabaseResponse
     */
    async createDatabaseWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.characterSetName)) {
            query["CharacterSetName"] = request.characterSetName;
        }
        if (!tea_util_1.default.isUnset(request.DBDescription)) {
            query["DBDescription"] = request.DBDescription;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateDatabase",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDatabaseResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Create a database in an ApsaraDB RDS for MySQL instance](~~96105~~)
      * *   [Create a database in an ApsaraDB RDS for PostgreSQL instance](~~96758~~)
      * *   [Create a database in an ApsaraDB RDS for SQL Server instance](~~95698~~)
      * *   [Create a database in an ApsaraDB RDS for MariaDB instance](~~97136~~)
      *
      * @param request CreateDatabaseRequest
      * @return CreateDatabaseResponse
     */
    async createDatabase(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDatabaseWithOptions(request, runtime);
    }
    /**
      * >  Before restoration, you can call the [CheckCreateDdrDBInstance](~~121721~~) operation to check whether a cross-region backup set can be used for cross-region restoration.
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
      *
      * @param request CreateDdrInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateDdrInstanceResponse
     */
    async createDdrInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupSetId)) {
            query["BackupSetId"] = request.backupSetId;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.connectionMode)) {
            query["ConnectionMode"] = request.connectionMode;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceClass)) {
            query["DBInstanceClass"] = request.DBInstanceClass;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceDescription)) {
            query["DBInstanceDescription"] = request.DBInstanceDescription;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceNetType)) {
            query["DBInstanceNetType"] = request.DBInstanceNetType;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorage)) {
            query["DBInstanceStorage"] = request.DBInstanceStorage;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorageType)) {
            query["DBInstanceStorageType"] = request.DBInstanceStorageType;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.instanceNetworkType)) {
            query["InstanceNetworkType"] = request.instanceNetworkType;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.payType)) {
            query["PayType"] = request.payType;
        }
        if (!tea_util_1.default.isUnset(request.period)) {
            query["Period"] = request.period;
        }
        if (!tea_util_1.default.isUnset(request.privateIpAddress)) {
            query["PrivateIpAddress"] = request.privateIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.restoreTime)) {
            query["RestoreTime"] = request.restoreTime;
        }
        if (!tea_util_1.default.isUnset(request.restoreType)) {
            query["RestoreType"] = request.restoreType;
        }
        if (!tea_util_1.default.isUnset(request.securityIPList)) {
            query["SecurityIPList"] = request.securityIPList;
        }
        if (!tea_util_1.default.isUnset(request.sourceDBInstanceName)) {
            query["SourceDBInstanceName"] = request.sourceDBInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.sourceRegion)) {
            query["SourceRegion"] = request.sourceRegion;
        }
        if (!tea_util_1.default.isUnset(request.systemDBCharset)) {
            query["SystemDBCharset"] = request.systemDBCharset;
        }
        if (!tea_util_1.default.isUnset(request.usedTime)) {
            query["UsedTime"] = request.usedTime;
        }
        if (!tea_util_1.default.isUnset(request.VPCId)) {
            query["VPCId"] = request.VPCId;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateDdrInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDdrInstanceResponse({}));
    }
    /**
      * >  Before restoration, you can call the [CheckCreateDdrDBInstance](~~121721~~) operation to check whether a cross-region backup set can be used for cross-region restoration.
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
      *
      * @param request CreateDdrInstanceRequest
      * @return CreateDdrInstanceResponse
     */
    async createDdrInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDdrInstanceWithOptions(request, runtime);
    }
    /**
      * >  This operation is no longer maintained. You can use the CreateDiagnosticReport operation of Database Autonomy Service (DAS) to create a diagnostic report.
      * After you call this operation to create a diagnostic report, you can call the DescribeDiagnosticReportList operation to download the diagnostic report.
      *
      * @param request CreateDiagnosticReportRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateDiagnosticReportResponse
     */
    async createDiagnosticReportWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateDiagnosticReport",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateDiagnosticReportResponse({}));
    }
    /**
      * >  This operation is no longer maintained. You can use the CreateDiagnosticReport operation of Database Autonomy Service (DAS) to create a diagnostic report.
      * After you call this operation to create a diagnostic report, you can call the DescribeDiagnosticReportList operation to download the diagnostic report.
      *
      * @param request CreateDiagnosticReportRequest
      * @return CreateDiagnosticReportResponse
     */
    async createDiagnosticReport(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createDiagnosticReportWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engine
      * *   MySQL
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Create and release an ApsaraDB RDS global active database cluster](~~328592~~)
      *
      * @param request CreateGADInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateGADInstanceResponse
     */
    async createGADInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.centralDBInstanceId)) {
            query["CentralDBInstanceId"] = request.centralDBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.centralRdsDtsAdminAccount)) {
            query["CentralRdsDtsAdminAccount"] = request.centralRdsDtsAdminAccount;
        }
        if (!tea_util_1.default.isUnset(request.centralRdsDtsAdminPassword)) {
            query["CentralRdsDtsAdminPassword"] = request.centralRdsDtsAdminPassword;
        }
        if (!tea_util_1.default.isUnset(request.centralRegionId)) {
            query["CentralRegionId"] = request.centralRegionId;
        }
        if (!tea_util_1.default.isUnset(request.DBList)) {
            query["DBList"] = request.DBList;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.tag)) {
            query["Tag"] = request.tag;
        }
        if (!tea_util_1.default.isUnset(request.unitNode)) {
            query["UnitNode"] = request.unitNode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateGADInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateGADInstanceResponse({}));
    }
    /**
      * ### [](#)Supported database engine
      * *   MySQL
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Create and release an ApsaraDB RDS global active database cluster](~~328592~~)
      *
      * @param request CreateGADInstanceRequest
      * @return CreateGADInstanceResponse
     */
    async createGADInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createGADInstanceWithOptions(request, runtime);
    }
    /**
      * ## [](#)Prerequisites
      * An ApsaraDB RDS global active database cluster is created. You can call the [CreateGADInstance](~~336893~~) operation to create a global active database cluster.
      * For more information, see [Add unit nodes to or move unit nodes from an ApsaraDB RDS global active database cluster](~~331851~~).
      *
      * @param request CreateGadInstanceMemberRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateGadInstanceMemberResponse
     */
    async createGadInstanceMemberWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.centralDBInstanceId)) {
            query["CentralDBInstanceId"] = request.centralDBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.centralRdsDtsAdminAccount)) {
            query["CentralRdsDtsAdminAccount"] = request.centralRdsDtsAdminAccount;
        }
        if (!tea_util_1.default.isUnset(request.centralRdsDtsAdminPassword)) {
            query["CentralRdsDtsAdminPassword"] = request.centralRdsDtsAdminPassword;
        }
        if (!tea_util_1.default.isUnset(request.centralRegionId)) {
            query["CentralRegionId"] = request.centralRegionId;
        }
        if (!tea_util_1.default.isUnset(request.DBList)) {
            query["DBList"] = request.DBList;
        }
        if (!tea_util_1.default.isUnset(request.gadInstanceId)) {
            query["GadInstanceId"] = request.gadInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.unitNode)) {
            query["UnitNode"] = request.unitNode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateGadInstanceMember",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateGadInstanceMemberResponse({}));
    }
    /**
      * ## [](#)Prerequisites
      * An ApsaraDB RDS global active database cluster is created. You can call the [CreateGADInstance](~~336893~~) operation to create a global active database cluster.
      * For more information, see [Add unit nodes to or move unit nodes from an ApsaraDB RDS global active database cluster](~~331851~~).
      *
      * @param request CreateGadInstanceMemberRequest
      * @return CreateGadInstanceMemberResponse
     */
    async createGadInstanceMember(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createGadInstanceMemberWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Migrate data from a self-managed SQL Server instance to an ApsaraDB RDS for SQL Server instance](~~100019~~)
      *
      * @param request CreateMigrateTaskRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateMigrateTaskResponse
     */
    async createMigrateTaskWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupMode)) {
            query["BackupMode"] = request.backupMode;
        }
        if (!tea_util_1.default.isUnset(request.checkDBMode)) {
            query["CheckDBMode"] = request.checkDBMode;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.isOnlineDB)) {
            query["IsOnlineDB"] = request.isOnlineDB;
        }
        if (!tea_util_1.default.isUnset(request.migrateTaskId)) {
            query["MigrateTaskId"] = request.migrateTaskId;
        }
        if (!tea_util_1.default.isUnset(request.OSSUrls)) {
            query["OSSUrls"] = request.OSSUrls;
        }
        if (!tea_util_1.default.isUnset(request.ossObjectPositions)) {
            query["OssObjectPositions"] = request.ossObjectPositions;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateMigrateTask",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateMigrateTaskResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Migrate data from a self-managed SQL Server instance to an ApsaraDB RDS for SQL Server instance](~~100019~~)
      *
      * @param request CreateMigrateTaskRequest
      * @return CreateMigrateTaskResponse
     */
    async createMigrateTask(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createMigrateTaskWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   SQL Server
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * This operation is used to migrate backup data to the cloud. Before you call this operation, make sure that you understand the descriptions in the following topics:
      * *   [Migrate the full backup data of a self-managed SQL Server database to an ApsaraDB RDS instance that runs SQL Server 2008 R2](~~95737~~)
      * *   [Migrate full backup data of SQL Server 2012, 2014, 2016, 2017, or 2019 databases](~~95738~~)
      * *   [Migrate incremental backup data to ApsaraDB RDS for SQL Server 2012, 2014, 2016, 2017, or 2019](~~95736~~)
      *
      * @param request CreateOnlineDatabaseTaskRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateOnlineDatabaseTaskResponse
     */
    async createOnlineDatabaseTaskWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.checkDBMode)) {
            query["CheckDBMode"] = request.checkDBMode;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.migrateTaskId)) {
            query["MigrateTaskId"] = request.migrateTaskId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateOnlineDatabaseTask",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateOnlineDatabaseTaskResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   SQL Server
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * This operation is used to migrate backup data to the cloud. Before you call this operation, make sure that you understand the descriptions in the following topics:
      * *   [Migrate the full backup data of a self-managed SQL Server database to an ApsaraDB RDS instance that runs SQL Server 2008 R2](~~95737~~)
      * *   [Migrate full backup data of SQL Server 2012, 2014, 2016, 2017, or 2019 databases](~~95738~~)
      * *   [Migrate incremental backup data to ApsaraDB RDS for SQL Server 2012, 2014, 2016, 2017, or 2019](~~95736~~)
      *
      * @param request CreateOnlineDatabaseTaskRequest
      * @return CreateOnlineDatabaseTaskResponse
     */
    async createOnlineDatabaseTask(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createOnlineDatabaseTaskWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * MySQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Add a node to an ApsaraDB RDS for MySQL cluster](~~464129~~)
      *
      * @param tmpReq CreateOrderForCreateDBNodesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateOrderForCreateDBNodesResponse
     */
    async createOrderForCreateDBNodesWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new CreateOrderForCreateDBNodesShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.DBNode)) {
            request.DBNodeShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.DBNode, "DBNode", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.autoPay)) {
            query["AutoPay"] = request.autoPay;
        }
        if (!tea_util_1.default.isUnset(request.businessInfo)) {
            query["BusinessInfo"] = request.businessInfo;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.commodityCode)) {
            query["CommodityCode"] = request.commodityCode;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBNodeShrink)) {
            query["DBNode"] = request.DBNodeShrink;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.nodeType)) {
            query["NodeType"] = request.nodeType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.promotionCode)) {
            query["PromotionCode"] = request.promotionCode;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resource)) {
            query["Resource"] = request.resource;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateOrderForCreateDBNodes",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateOrderForCreateDBNodesResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * MySQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Add a node to an ApsaraDB RDS for MySQL cluster](~~464129~~)
      *
      * @param request CreateOrderForCreateDBNodesRequest
      * @return CreateOrderForCreateDBNodesResponse
     */
    async createOrderForCreateDBNodes(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createOrderForCreateDBNodesWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * MySQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Delete a node from an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition](~~464130~~)
      *
      * @param tmpReq CreateOrderForDeleteDBNodesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateOrderForDeleteDBNodesResponse
     */
    async createOrderForDeleteDBNodesWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new CreateOrderForDeleteDBNodesShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.DBNodeId)) {
            request.DBNodeIdShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.DBNodeId, "DBNodeId", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.autoPay)) {
            query["AutoPay"] = request.autoPay;
        }
        if (!tea_util_1.default.isUnset(request.businessInfo)) {
            query["BusinessInfo"] = request.businessInfo;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.commodityCode)) {
            query["CommodityCode"] = request.commodityCode;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBNodeIdShrink)) {
            query["DBNodeId"] = request.DBNodeIdShrink;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.nodeType)) {
            query["NodeType"] = request.nodeType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.promotionCode)) {
            query["PromotionCode"] = request.promotionCode;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resource)) {
            query["Resource"] = request.resource;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateOrderForDeleteDBNodes",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateOrderForDeleteDBNodesResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * MySQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Delete a node from an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition](~~464130~~)
      *
      * @param request CreateOrderForDeleteDBNodesRequest
      * @return CreateOrderForDeleteDBNodesResponse
     */
    async createOrderForDeleteDBNodes(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createOrderForDeleteDBNodesWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
      *
      * @param request CreateParameterGroupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateParameterGroupResponse
     */
    async createParameterGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.parameterGroupDesc)) {
            query["ParameterGroupDesc"] = request.parameterGroupDesc;
        }
        if (!tea_util_1.default.isUnset(request.parameterGroupName)) {
            query["ParameterGroupName"] = request.parameterGroupName;
        }
        if (!tea_util_1.default.isUnset(request.parameters)) {
            query["Parameters"] = request.parameters;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateParameterGroup",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateParameterGroupResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
      *
      * @param request CreateParameterGroupRequest
      * @return CreateParameterGroupResponse
     */
    async createParameterGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createParameterGroupWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * RDS PostgreSQL
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Manage extensions](~~2402409~~)
      * ### [](#)Precautions
      * Install only the plug-ins that are supported by the major engine version of the instance. Otherwise, the installation fails.
      * *   For more information, see [Extensions supported by ApsaraDB RDS for PostgreSQL](~~142340~~).
      * *   You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the major engine version of an instance.
      *
      * @param request CreatePostgresExtensionsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreatePostgresExtensionsResponse
     */
    async createPostgresExtensionsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountName)) {
            query["AccountName"] = request.accountName;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBNames)) {
            query["DBNames"] = request.DBNames;
        }
        if (!tea_util_1.default.isUnset(request.extensions)) {
            query["Extensions"] = request.extensions;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.sourceDatabase)) {
            query["SourceDatabase"] = request.sourceDatabase;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreatePostgresExtensions",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreatePostgresExtensionsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * RDS PostgreSQL
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Manage extensions](~~2402409~~)
      * ### [](#)Precautions
      * Install only the plug-ins that are supported by the major engine version of the instance. Otherwise, the installation fails.
      * *   For more information, see [Extensions supported by ApsaraDB RDS for PostgreSQL](~~142340~~).
      * *   You can call the [DescribeDBInstanceAttribute](~~610394~~) operation to query the major engine version of an instance.
      *
      * @param request CreatePostgresExtensionsRequest
      * @return CreatePostgresExtensionsResponse
     */
    async createPostgresExtensions(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createPostgresExtensionsWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Create a read-only ApsaraDB RDS for MySQL instance](~~56991~~)
      * *   [Create a read-only ApsaraDB RDS for PostgreSQL instance](~~108959~~)
      * *   [Create a read-only ApsaraDB RDS for SQL Server instance](~~99005~~)
      *
      * @param request CreateReadOnlyDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateReadOnlyDBInstanceResponse
     */
    async createReadOnlyDBInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.autoPay)) {
            query["AutoPay"] = request.autoPay;
        }
        if (!tea_util_1.default.isUnset(request.autoRenew)) {
            query["AutoRenew"] = request.autoRenew;
        }
        if (!tea_util_1.default.isUnset(request.bpeEnabled)) {
            query["BpeEnabled"] = request.bpeEnabled;
        }
        if (!tea_util_1.default.isUnset(request.burstingEnabled)) {
            query["BurstingEnabled"] = request.burstingEnabled;
        }
        if (!tea_util_1.default.isUnset(request.category)) {
            query["Category"] = request.category;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceClass)) {
            query["DBInstanceClass"] = request.DBInstanceClass;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceDescription)) {
            query["DBInstanceDescription"] = request.DBInstanceDescription;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorage)) {
            query["DBInstanceStorage"] = request.DBInstanceStorage;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorageType)) {
            query["DBInstanceStorageType"] = request.DBInstanceStorageType;
        }
        if (!tea_util_1.default.isUnset(request.dedicatedHostGroupId)) {
            query["DedicatedHostGroupId"] = request.dedicatedHostGroupId;
        }
        if (!tea_util_1.default.isUnset(request.deletionProtection)) {
            query["DeletionProtection"] = request.deletionProtection;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.gdnInstanceName)) {
            query["GdnInstanceName"] = request.gdnInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.instanceNetworkType)) {
            query["InstanceNetworkType"] = request.instanceNetworkType;
        }
        if (!tea_util_1.default.isUnset(request.instructionSetArch)) {
            query["InstructionSetArch"] = request.instructionSetArch;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.payType)) {
            query["PayType"] = request.payType;
        }
        if (!tea_util_1.default.isUnset(request.period)) {
            query["Period"] = request.period;
        }
        if (!tea_util_1.default.isUnset(request.port)) {
            query["Port"] = request.port;
        }
        if (!tea_util_1.default.isUnset(request.privateIpAddress)) {
            query["PrivateIpAddress"] = request.privateIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.targetDedicatedHostIdForMaster)) {
            query["TargetDedicatedHostIdForMaster"] = request.targetDedicatedHostIdForMaster;
        }
        if (!tea_util_1.default.isUnset(request.tddlBizType)) {
            query["TddlBizType"] = request.tddlBizType;
        }
        if (!tea_util_1.default.isUnset(request.tddlRegionConfig)) {
            query["TddlRegionConfig"] = request.tddlRegionConfig;
        }
        if (!tea_util_1.default.isUnset(request.usedTime)) {
            query["UsedTime"] = request.usedTime;
        }
        if (!tea_util_1.default.isUnset(request.VPCId)) {
            query["VPCId"] = request.VPCId;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateReadOnlyDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateReadOnlyDBInstanceResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Create a read-only ApsaraDB RDS for MySQL instance](~~56991~~)
      * *   [Create a read-only ApsaraDB RDS for PostgreSQL instance](~~108959~~)
      * *   [Create a read-only ApsaraDB RDS for SQL Server instance](~~99005~~)
      *
      * @param request CreateReadOnlyDBInstanceRequest
      * @return CreateReadOnlyDBInstanceResponse
     */
    async createReadOnlyDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createReadOnlyDBInstanceWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      *
      * @param request CreateSecretRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateSecretResponse
     */
    async createSecretWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.dbInstanceId)) {
            query["DbInstanceId"] = request.dbInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.dbNames)) {
            query["DbNames"] = request.dbNames;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.password)) {
            query["Password"] = request.password;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.secretName)) {
            query["SecretName"] = request.secretName;
        }
        if (!tea_util_1.default.isUnset(request.username)) {
            query["Username"] = request.username;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateSecret",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateSecretResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      *
      * @param request CreateSecretRequest
      * @return CreateSecretResponse
     */
    async createSecret(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createSecretWithOptions(request, runtime);
    }
    /**
      * ### Supported database engine
      * PostgreSQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Service-linked roles](~~342840~~)
      *
      * @param request CreateServiceLinkedRoleRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateServiceLinkedRoleResponse
     */
    async createServiceLinkedRoleWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.serviceLinkedRole)) {
            query["ServiceLinkedRole"] = request.serviceLinkedRole;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateServiceLinkedRole",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateServiceLinkedRoleResponse({}));
    }
    /**
      * ### Supported database engine
      * PostgreSQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Service-linked roles](~~342840~~)
      *
      * @param request CreateServiceLinkedRoleRequest
      * @return CreateServiceLinkedRoleResponse
     */
    async createServiceLinkedRole(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createServiceLinkedRoleWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * Your RDS instance runs SQL Server 2008 R2 with local disks.
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Restore the data of an ApsaraDB RDS for SQL Server instance by using a temporary RDS instance](~~95724~~)
      *
      * @param request CreateTempDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return CreateTempDBInstanceResponse
     */
    async createTempDBInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupId)) {
            query["BackupId"] = request.backupId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.restoreTime)) {
            query["RestoreTime"] = request.restoreTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateTempDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateTempDBInstanceResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * Your RDS instance runs SQL Server 2008 R2 with local disks.
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Restore the data of an ApsaraDB RDS for SQL Server instance by using a temporary RDS instance](~~95724~~)
      *
      * @param request CreateTempDBInstanceRequest
      * @return CreateTempDBInstanceResponse
     */
    async createTempDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createTempDBInstanceWithOptions(request, runtime);
    }
    async createYouhuiForOrderWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.activityId)) {
            query["ActivityId"] = request.activityId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.promotionId)) {
            query["PromotionId"] = request.promotionId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateYouhuiForOrder",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateYouhuiForOrderResponse({}));
    }
    async createYouhuiForOrder(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.createYouhuiForOrderWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   SQL Server
      *
      * @param request DeleteADSettingRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteADSettingResponse
     */
    async deleteADSettingWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteADSetting",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteADSettingResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   SQL Server
      *
      * @param request DeleteADSettingRequest
      * @return DeleteADSettingResponse
     */
    async deleteADSetting(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteADSettingWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Delete a database account from an ApsaraDB RDS for MySQL instance](~~96104~~)
      * *   [Delete a database account from an ApsaraDB RDS for PostgreSQL instance](~~147649~~)
      * *   [Delete a database account from an ApsaraDB RDS for SQL Server instance](~~95694~~)
      * *   [Delete a database account from an ApsaraDB RDS for MariaDB instance](~~97135~~)
      *
      * @param request DeleteAccountRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteAccountResponse
     */
    async deleteAccountWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountName)) {
            query["AccountName"] = request.accountName;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteAccount",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteAccountResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Delete a database account from an ApsaraDB RDS for MySQL instance](~~96104~~)
      * *   [Delete a database account from an ApsaraDB RDS for PostgreSQL instance](~~147649~~)
      * *   [Delete a database account from an ApsaraDB RDS for SQL Server instance](~~95694~~)
      * *   [Delete a database account from an ApsaraDB RDS for MariaDB instance](~~97135~~)
      *
      * @param request DeleteAccountRequest
      * @return DeleteAccountResponse
     */
    async deleteAccount(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteAccountWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * > Only instances that run RDS High-availability Edition are supported.
      * ### Description
      * You can call this operation to delete backup sets of the instance itself. Backup sets of the associated instances such as read-only, disaster recovery, and cloned instances are not deleted.
      * ### Precautions
      * Before you call this operation, make sure that the following requirements are met:
      * *   The instance is in the Running state.
      * *   If the log backup feature is disabled, instances cannot be restored by point in time. You can delete data backup sets that are retained for more than seven days.
      * *   If the log backup feature is enabled and the log backup retention period is shorter than the data backup retention period, you can delete the data backup files that are retained for a period longer than the log backup retention period.
      *
      * @param request DeleteBackupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteBackupResponse
     */
    async deleteBackupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupId)) {
            query["BackupId"] = request.backupId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteBackup",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteBackupResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * > Only instances that run RDS High-availability Edition are supported.
      * ### Description
      * You can call this operation to delete backup sets of the instance itself. Backup sets of the associated instances such as read-only, disaster recovery, and cloned instances are not deleted.
      * ### Precautions
      * Before you call this operation, make sure that the following requirements are met:
      * *   The instance is in the Running state.
      * *   If the log backup feature is disabled, instances cannot be restored by point in time. You can delete data backup sets that are retained for more than seven days.
      * *   If the log backup feature is enabled and the log backup retention period is shorter than the data backup retention period, you can delete the data backup files that are retained for a period longer than the log backup retention period.
      *
      * @param request DeleteBackupRequest
      * @return DeleteBackupResponse
     */
    async deleteBackup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteBackupWithOptions(request, runtime);
    }
    /**
      * ### Supported database engine
      * SQL Server
      * ### Usage notes
      * This operation is available for users whose accounts are added to the whitelist. If your account is not added to the whitelist, you can join the Database Backup (DBS) DingTalk group whose ID is 35585947 and contact the on-duty engineer to add your account to the whitelist.
      *
      * @param request DeleteBackupFileRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteBackupFileResponse
     */
    async deleteBackupFileWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupId)) {
            query["BackupId"] = request.backupId;
        }
        if (!tea_util_1.default.isUnset(request.backupTime)) {
            query["BackupTime"] = request.backupTime;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteBackupFile",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteBackupFileResponse({}));
    }
    /**
      * ### Supported database engine
      * SQL Server
      * ### Usage notes
      * This operation is available for users whose accounts are added to the whitelist. If your account is not added to the whitelist, you can join the Database Backup (DBS) DingTalk group whose ID is 35585947 and contact the on-duty engineer to add your account to the whitelist.
      *
      * @param request DeleteBackupFileRequest
      * @return DeleteBackupFileResponse
     */
    async deleteBackupFile(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteBackupFileWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Note Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Release an ApsaraDB RDS for MySQL instance](~~96057~~)
      * *   [Release an ApsaraDB RDS for PostgreSQL instance](~~96749~~)
      * *   [Release an ApsaraDB RDS for SQL Server instance](~~95662~~)
      * *   [Release an ApsaraDB RDS for MariaDB instance](~~97128~~)
      *
      * @param request DeleteDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteDBInstanceResponse
     */
    async deleteDBInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.releasedKeepPolicy)) {
            query["ReleasedKeepPolicy"] = request.releasedKeepPolicy;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDBInstanceResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Note Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Release an ApsaraDB RDS for MySQL instance](~~96057~~)
      * *   [Release an ApsaraDB RDS for PostgreSQL instance](~~96749~~)
      * *   [Release an ApsaraDB RDS for SQL Server instance](~~95662~~)
      * *   [Release an ApsaraDB RDS for MariaDB instance](~~97128~~)
      *
      * @param request DeleteDBInstanceRequest
      * @return DeleteDBInstanceResponse
     */
    async deleteDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDBInstanceWithOptions(request, runtime);
    }
    /**
      * ### Supported database engine
      * MySQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Delete the read-only endpoint of an ApsaraDB RDS for MySQL cluster](~~464133~~)
      *
      * @param request DeleteDBInstanceEndpointRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteDBInstanceEndpointResponse
     */
    async deleteDBInstanceEndpointWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceEndpointId)) {
            query["DBInstanceEndpointId"] = request.DBInstanceEndpointId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDBInstanceEndpoint",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDBInstanceEndpointResponse({}));
    }
    /**
      * ### Supported database engine
      * MySQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Delete the read-only endpoint of an ApsaraDB RDS for MySQL cluster](~~464133~~)
      *
      * @param request DeleteDBInstanceEndpointRequest
      * @return DeleteDBInstanceEndpointResponse
     */
    async deleteDBInstanceEndpoint(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDBInstanceEndpointWithOptions(request, runtime);
    }
    /**
      * ### Supported database engine
      * MySQL
      * ### Precautions
      * You can delete only the public endpoint of each endpoint type from the instance. If you want to delete an internal endpoint of any endpoint type, you can delete the type of endpoint.
      *
      * @param request DeleteDBInstanceEndpointAddressRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteDBInstanceEndpointAddressResponse
     */
    async deleteDBInstanceEndpointAddressWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.connectionString)) {
            body["ConnectionString"] = request.connectionString;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceEndpointId)) {
            body["DBInstanceEndpointId"] = request.DBInstanceEndpointId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDBInstanceEndpointAddress",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDBInstanceEndpointAddressResponse({}));
    }
    /**
      * ### Supported database engine
      * MySQL
      * ### Precautions
      * You can delete only the public endpoint of each endpoint type from the instance. If you want to delete an internal endpoint of any endpoint type, you can delete the type of endpoint.
      *
      * @param request DeleteDBInstanceEndpointAddressRequest
      * @return DeleteDBInstanceEndpointAddressResponse
     */
    async deleteDBInstanceEndpointAddress(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDBInstanceEndpointAddressWithOptions(request, runtime);
    }
    /**
      * ### Supported database engine
      * MySQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Delete a node from an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition](~~464130~~)
      *
      * @param tmpReq DeleteDBNodesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteDBNodesResponse
     */
    async deleteDBNodesWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new DeleteDBNodesShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.DBNodeId)) {
            request.DBNodeIdShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.DBNodeId, "DBNodeId", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBNodeIdShrink)) {
            query["DBNodeId"] = request.DBNodeIdShrink;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDBNodes",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDBNodesResponse({}));
    }
    /**
      * ### Supported database engine
      * MySQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Delete a node from an ApsaraDB RDS for MySQL instance that runs RDS Cluster Edition](~~464130~~)
      *
      * @param request DeleteDBNodesRequest
      * @return DeleteDBNodesResponse
     */
    async deleteDBNodes(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDBNodesWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](~~184921~~)
      * *   [Configure the dedicated proxy endpoint for an ApsaraDB RDS for PostgreSQL instance](~~418274~~)
      *
      * @param request DeleteDBProxyEndpointAddressRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteDBProxyEndpointAddressResponse
     */
    async deleteDBProxyEndpointAddressWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyConnectStringNetType)) {
            query["DBProxyConnectStringNetType"] = request.DBProxyConnectStringNetType;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyEndpointId)) {
            query["DBProxyEndpointId"] = request.DBProxyEndpointId;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyEngineType)) {
            query["DBProxyEngineType"] = request.DBProxyEngineType;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDBProxyEndpointAddress",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDBProxyEndpointAddressResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](~~184921~~)
      * *   [Configure the dedicated proxy endpoint for an ApsaraDB RDS for PostgreSQL instance](~~418274~~)
      *
      * @param request DeleteDBProxyEndpointAddressRequest
      * @return DeleteDBProxyEndpointAddressResponse
     */
    async deleteDBProxyEndpointAddress(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDBProxyEndpointAddressWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      * ### [](#)References
      * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Delete a database from an ApsaraDB RDS for MySQL instance](~~96106~~)
      * *   [Delete a database from an ApsaraDB RDS for PostgreSQL instance](~~96759~~)
      * *   [Delete a database from an ApsaraDB RDS for SQL Server instance](~~95699~~)
      * *   [Delete a database from an ApsaraDB RDS for MariaDB instance](~~97137~~)
      *
      * @param request DeleteDatabaseRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteDatabaseResponse
     */
    async deleteDatabaseWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDatabase",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteDatabaseResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      * ### [](#)References
      * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Delete a database from an ApsaraDB RDS for MySQL instance](~~96106~~)
      * *   [Delete a database from an ApsaraDB RDS for PostgreSQL instance](~~96759~~)
      * *   [Delete a database from an ApsaraDB RDS for SQL Server instance](~~95699~~)
      * *   [Delete a database from an ApsaraDB RDS for MariaDB instance](~~97137~~)
      *
      * @param request DeleteDatabaseRequest
      * @return DeleteDatabaseResponse
     */
    async deleteDatabase(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteDatabaseWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * ### [Usage notes](#)
      * *   A global active database cluster cannot be restored after it is deleted. Proceed with caution.
      * *   If you delete a global active database cluster, the system removes all nodes and Data Transmission Service (DTS) synchronization tasks from the cluster. However, the system does not release the ApsaraDB RDS for MySQL instances that run as nodes in the cluster. If you no longer need the ApsaraDB RDS for MySQL instances, you can call the [DeleteDBInstance](~~26229~~) to release the instances one after another.
      *
      * @param request DeleteGadInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteGadInstanceResponse
     */
    async deleteGadInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.gadInstanceName)) {
            query["GadInstanceName"] = request.gadInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteGadInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteGadInstanceResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * ### [Usage notes](#)
      * *   A global active database cluster cannot be restored after it is deleted. Proceed with caution.
      * *   If you delete a global active database cluster, the system removes all nodes and Data Transmission Service (DTS) synchronization tasks from the cluster. However, the system does not release the ApsaraDB RDS for MySQL instances that run as nodes in the cluster. If you no longer need the ApsaraDB RDS for MySQL instances, you can call the [DeleteDBInstance](~~26229~~) to release the instances one after another.
      *
      * @param request DeleteGadInstanceRequest
      * @return DeleteGadInstanceResponse
     */
    async deleteGadInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteGadInstanceWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
      *
      * @param request DeleteParameterGroupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteParameterGroupResponse
     */
    async deleteParameterGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.parameterGroupId)) {
            query["ParameterGroupId"] = request.parameterGroupId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteParameterGroup",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteParameterGroupResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
      *
      * @param request DeleteParameterGroupRequest
      * @return DeleteParameterGroupResponse
     */
    async deleteParameterGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteParameterGroupWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * RDS PostgreSQL
      * ### References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Manage extensions](~~2402409~~)
      *
      * @param request DeletePostgresExtensionsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeletePostgresExtensionsResponse
     */
    async deletePostgresExtensionsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBNames)) {
            query["DBNames"] = request.DBNames;
        }
        if (!tea_util_1.default.isUnset(request.extensions)) {
            query["Extensions"] = request.extensions;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeletePostgresExtensions",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeletePostgresExtensionsResponse({}));
    }
    /**
      * ### Supported database engines
      * RDS PostgreSQL
      * ### References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Manage extensions](~~2402409~~)
      *
      * @param request DeletePostgresExtensionsRequest
      * @return DeletePostgresExtensionsResponse
     */
    async deletePostgresExtensions(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deletePostgresExtensionsWithOptions(request, runtime);
    }
    async deleteSecretWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.dbInstanceId)) {
            query["DbInstanceId"] = request.dbInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.secretArn)) {
            query["SecretArn"] = request.secretArn;
        }
        if (!tea_util_1.default.isUnset(request.secretName)) {
            query["SecretName"] = request.secretName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteSecret",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteSecretResponse({}));
    }
    async deleteSecret(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteSecretWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engine
      * *   PostgreSQL
      * ### [](#)Precautions
      * You can delete a replication slot only when the status of the slot is **INACTIVE**. You can call the DescribeSlots operation to query the status of a replication slot.
      *
      * @param request DeleteSlotRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteSlotResponse
     */
    async deleteSlotWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.slotName)) {
            query["SlotName"] = request.slotName;
        }
        if (!tea_util_1.default.isUnset(request.slotStatus)) {
            query["SlotStatus"] = request.slotStatus;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteSlot",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteSlotResponse({}));
    }
    /**
      * ### [](#)Supported database engine
      * *   PostgreSQL
      * ### [](#)Precautions
      * You can delete a replication slot only when the status of the slot is **INACTIVE**. You can call the DescribeSlots operation to query the status of a replication slot.
      *
      * @param request DeleteSlotRequest
      * @return DeleteSlotResponse
     */
    async deleteSlot(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteSlotWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * ### [](#)Description
      * *   A full backup file contains the data of a self-managed MySQL instance. You can restore the data of a self-managed MySQL instance from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
      * *   This operation deletes full backup files only from the ApsaraDB RDS console. This operation does not affect the full backup files that are stored as objects in Object Storage Service (OSS) buckets. After you call this operation to delete a full backup file, you can call the [ImportUserBackupFile](~~260266~~) operation to import the full backup file again.
      *
      * @param request DeleteUserBackupFileRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DeleteUserBackupFileResponse
     */
    async deleteUserBackupFileWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupId)) {
            query["BackupId"] = request.backupId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteUserBackupFile",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteUserBackupFileResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * ### [](#)Description
      * *   A full backup file contains the data of a self-managed MySQL instance. You can restore the data of a self-managed MySQL instance from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
      * *   This operation deletes full backup files only from the ApsaraDB RDS console. This operation does not affect the full backup files that are stored as objects in Object Storage Service (OSS) buckets. After you call this operation to delete a full backup file, you can call the [ImportUserBackupFile](~~260266~~) operation to import the full backup file again.
      *
      * @param request DeleteUserBackupFileRequest
      * @return DeleteUserBackupFileResponse
     */
    async deleteUserBackupFile(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.deleteUserBackupFileWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      *
      * @param request DescibeImportsFromDatabaseRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescibeImportsFromDatabaseResponse
     */
    async descibeImportsFromDatabaseWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.importId)) {
            query["ImportId"] = request.importId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescibeImportsFromDatabase",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescibeImportsFromDatabaseResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      *
      * @param request DescibeImportsFromDatabaseRequest
      * @return DescibeImportsFromDatabaseResponse
     */
    async descibeImportsFromDatabase(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.descibeImportsFromDatabaseWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   SQL Server
      *
      * @param request DescribeADInfoRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeADInfoResponse
     */
    async describeADInfoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeADInfo",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeADInfoResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   SQL Server
      *
      * @param request DescribeADInfoRequest
      * @return DescribeADInfoResponse
     */
    async describeADInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeADInfoWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request DescribeAccountsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeAccountsResponse
     */
    async describeAccountsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountName)) {
            query["AccountName"] = request.accountName;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeAccounts",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeAccountsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request DescribeAccountsRequest
      * @return DescribeAccountsResponse
     */
    async describeAccounts(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeAccountsWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request DescribeActionEventPolicyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeActionEventPolicyResponse
     */
    async describeActionEventPolicyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeActionEventPolicy",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeActionEventPolicyResponse({}));
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request DescribeActionEventPolicyRequest
      * @return DescribeActionEventPolicyResponse
     */
    async describeActionEventPolicy(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeActionEventPolicyWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeActiveOperationTasksRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeActiveOperationTasksResponse
     */
    async describeActiveOperationTasksWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.allowCancel)) {
            query["AllowCancel"] = request.allowCancel;
        }
        if (!tea_util_1.default.isUnset(request.allowChange)) {
            query["AllowChange"] = request.allowChange;
        }
        if (!tea_util_1.default.isUnset(request.changeLevel)) {
            query["ChangeLevel"] = request.changeLevel;
        }
        if (!tea_util_1.default.isUnset(request.dbType)) {
            query["DbType"] = request.dbType;
        }
        if (!tea_util_1.default.isUnset(request.insName)) {
            query["InsName"] = request.insName;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.productId)) {
            query["ProductId"] = request.productId;
        }
        if (!tea_util_1.default.isUnset(request.region)) {
            query["Region"] = request.region;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            query["Status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.taskType)) {
            query["TaskType"] = request.taskType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeActiveOperationTasks",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeActiveOperationTasksResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeActiveOperationTasksRequest
      * @return DescribeActiveOperationTasksResponse
     */
    async describeActiveOperationTasks(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeActiveOperationTasksWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      *
      * @param request DescribeAllWhitelistTemplateRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeAllWhitelistTemplateResponse
     */
    async describeAllWhitelistTemplateWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.fuzzySearch)) {
            query["FuzzySearch"] = request.fuzzySearch;
        }
        if (!tea_util_1.default.isUnset(request.maxRecordsPerPage)) {
            query["MaxRecordsPerPage"] = request.maxRecordsPerPage;
        }
        if (!tea_util_1.default.isUnset(request.pageNumbers)) {
            query["PageNumbers"] = request.pageNumbers;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.templateName)) {
            query["TemplateName"] = request.templateName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeAllWhitelistTemplate",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeAllWhitelistTemplateResponse({}));
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      *
      * @param request DescribeAllWhitelistTemplateRequest
      * @return DescribeAllWhitelistTemplateResponse
     */
    async describeAllWhitelistTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeAllWhitelistTemplateWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * MySQL
      * ### [](#)References
      * [Create and view an analytic instance](~~155180~~)
      *
      * @param request DescribeAnalyticdbByPrimaryDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeAnalyticdbByPrimaryDBInstanceResponse
     */
    async describeAnalyticdbByPrimaryDBInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeAnalyticdbByPrimaryDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeAnalyticdbByPrimaryDBInstanceResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * MySQL
      * ### [](#)References
      * [Create and view an analytic instance](~~155180~~)
      *
      * @param request DescribeAnalyticdbByPrimaryDBInstanceRequest
      * @return DescribeAnalyticdbByPrimaryDBInstanceResponse
     */
    async describeAnalyticdbByPrimaryDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeAnalyticdbByPrimaryDBInstanceWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeAvailableClassesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeAvailableClassesResponse
     */
    async describeAvailableClassesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.category)) {
            query["Category"] = request.category;
        }
        if (!tea_util_1.default.isUnset(request.commodityCode)) {
            query["CommodityCode"] = request.commodityCode;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorageType)) {
            query["DBInstanceStorageType"] = request.DBInstanceStorageType;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.instanceChargeType)) {
            query["InstanceChargeType"] = request.instanceChargeType;
        }
        if (!tea_util_1.default.isUnset(request.orderType)) {
            query["OrderType"] = request.orderType;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeAvailableClasses",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeAvailableClassesResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeAvailableClassesRequest
      * @return DescribeAvailableClassesResponse
     */
    async describeAvailableClasses(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeAvailableClassesWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
      *
      * @param request DescribeAvailableCrossRegionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeAvailableCrossRegionResponse
     */
    async describeAvailableCrossRegionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeAvailableCrossRegion",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeAvailableCrossRegionResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
      *
      * @param request DescribeAvailableCrossRegionRequest
      * @return DescribeAvailableCrossRegionResponse
     */
    async describeAvailableCrossRegion(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeAvailableCrossRegionWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [View the Enhanced Monitoring metrics](~~299200~~)
      *
      * @param request DescribeAvailableMetricsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeAvailableMetricsResponse
     */
    async describeAvailableMetricsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceName)) {
            query["DBInstanceName"] = request.DBInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeAvailableMetrics",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeAvailableMetricsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [View the Enhanced Monitoring metrics](~~299200~~)
      *
      * @param request DescribeAvailableMetricsRequest
      * @return DescribeAvailableMetricsResponse
     */
    async describeAvailableMetrics(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeAvailableMetricsWithOptions(request, runtime);
    }
    /**
      * >  To view the time range within which you can restore data from a standard backup set, see [DescribeBackups](~~26273~~)
      * ### [](#)Supported database engines
      * MySQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
      *
      * @param request DescribeAvailableRecoveryTimeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeAvailableRecoveryTimeResponse
     */
    async describeAvailableRecoveryTimeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.crossBackupId)) {
            query["CrossBackupId"] = request.crossBackupId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeAvailableRecoveryTime",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeAvailableRecoveryTimeResponse({}));
    }
    /**
      * >  To view the time range within which you can restore data from a standard backup set, see [DescribeBackups](~~26273~~)
      * ### [](#)Supported database engines
      * MySQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
      *
      * @param request DescribeAvailableRecoveryTimeRequest
      * @return DescribeAvailableRecoveryTimeResponse
     */
    async describeAvailableRecoveryTime(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeAvailableRecoveryTimeWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeAvailableZonesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeAvailableZonesResponse
     */
    async describeAvailableZonesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.category)) {
            query["Category"] = request.category;
        }
        if (!tea_util_1.default.isUnset(request.commodityCode)) {
            query["CommodityCode"] = request.commodityCode;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceName)) {
            query["DBInstanceName"] = request.DBInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.dispenseMode)) {
            query["DispenseMode"] = request.dispenseMode;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeAvailableZones",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeAvailableZonesResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeAvailableZonesRequest
      * @return DescribeAvailableZonesResponse
     */
    async describeAvailableZones(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeAvailableZonesWithOptions(request, runtime);
    }
    /**
      * > This operation is phased out.
      *
      * @param request DescribeBackupDatabaseRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeBackupDatabaseResponse
     */
    async describeBackupDatabaseWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupId)) {
            query["BackupId"] = request.backupId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeBackupDatabase",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeBackupDatabaseResponse({}));
    }
    /**
      * > This operation is phased out.
      *
      * @param request DescribeBackupDatabaseRequest
      * @return DescribeBackupDatabaseResponse
     */
    async describeBackupDatabase(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeBackupDatabaseWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeBackupPolicyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeBackupPolicyResponse
     */
    async describeBackupPolicyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupPolicyMode)) {
            query["BackupPolicyMode"] = request.backupPolicyMode;
        }
        if (!tea_util_1.default.isUnset(request.compressType)) {
            query["CompressType"] = request.compressType;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.releasedKeepPolicy)) {
            query["ReleasedKeepPolicy"] = request.releasedKeepPolicy;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeBackupPolicy",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeBackupPolicyResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeBackupPolicyRequest
      * @return DescribeBackupPolicyResponse
     */
    async describeBackupPolicy(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeBackupPolicyWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request DescribeBackupTasksRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeBackupTasksResponse
     */
    async describeBackupTasksWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupJobId)) {
            query["BackupJobId"] = request.backupJobId;
        }
        if (!tea_util_1.default.isUnset(request.backupJobStatus)) {
            query["BackupJobStatus"] = request.backupJobStatus;
        }
        if (!tea_util_1.default.isUnset(request.backupMode)) {
            query["BackupMode"] = request.backupMode;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.flag)) {
            query["Flag"] = request.flag;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeBackupTasks",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeBackupTasksResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request DescribeBackupTasksRequest
      * @return DescribeBackupTasksResponse
     */
    async describeBackupTasks(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeBackupTasksWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request DescribeBackupsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeBackupsResponse
     */
    async describeBackupsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupId)) {
            query["BackupId"] = request.backupId;
        }
        if (!tea_util_1.default.isUnset(request.backupMode)) {
            query["BackupMode"] = request.backupMode;
        }
        if (!tea_util_1.default.isUnset(request.backupStatus)) {
            query["BackupStatus"] = request.backupStatus;
        }
        if (!tea_util_1.default.isUnset(request.backupType)) {
            query["BackupType"] = request.backupType;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeBackups",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeBackupsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request DescribeBackupsRequest
      * @return DescribeBackupsResponse
     */
    async describeBackups(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeBackupsWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   MariaDB
      * ### Usage notes
      * *   If the return value of the **DownloadLink** parameter is NULL, ApsaraDB RDS does not provide a download URL.
      * *   If the return value of the **DownloadLink** parameter is not NULL, ApsaraDB RDS provides a URL for you to download backup files. The expiration time of the URL is specified by the **LinkExpiredTime** parameter. You must download the backup files before the expiration time.
      * *   If you use a RAM user to download backup files, you must grant permissions to the RAM user. For more information, see [Grant backup file download permissions to a RAM user with read-only permissions](~~100043~~).
      * *   Each log file that is returned by this operation contains the log entries that are generated over the time range that is specified by the StartTime and EndTime parameters.
      *
      * @param request DescribeBinlogFilesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeBinlogFilesResponse
     */
    async describeBinlogFilesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeBinlogFiles",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeBinlogFilesResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   MariaDB
      * ### Usage notes
      * *   If the return value of the **DownloadLink** parameter is NULL, ApsaraDB RDS does not provide a download URL.
      * *   If the return value of the **DownloadLink** parameter is not NULL, ApsaraDB RDS provides a URL for you to download backup files. The expiration time of the URL is specified by the **LinkExpiredTime** parameter. You must download the backup files before the expiration time.
      * *   If you use a RAM user to download backup files, you must grant permissions to the RAM user. For more information, see [Grant backup file download permissions to a RAM user with read-only permissions](~~100043~~).
      * *   Each log file that is returned by this operation contains the log entries that are generated over the time range that is specified by the StartTime and EndTime parameters.
      *
      * @param request DescribeBinlogFilesRequest
      * @return DescribeBinlogFilesResponse
     */
    async describeBinlogFiles(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeBinlogFilesWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeCharacterSetNameRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeCharacterSetNameResponse
     */
    async describeCharacterSetNameWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeCharacterSetName",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCharacterSetNameResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeCharacterSetNameRequest
      * @return DescribeCharacterSetNameResponse
     */
    async describeCharacterSetName(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeCharacterSetNameWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeClassDetailsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeClassDetailsResponse
     */
    async describeClassDetailsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.classCode)) {
            query["ClassCode"] = request.classCode;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.commodityCode)) {
            query["CommodityCode"] = request.commodityCode;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeClassDetails",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClassDetailsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeClassDetailsRequest
      * @return DescribeClassDetailsResponse
     */
    async describeClassDetails(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeClassDetailsWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      *
      * @param request DescribeCloudMigrationPrecheckResultRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeCloudMigrationPrecheckResultResponse
     */
    async describeCloudMigrationPrecheckResultWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceName)) {
            query["DBInstanceName"] = request.DBInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.sourceIpAddress)) {
            query["SourceIpAddress"] = request.sourceIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.sourcePort)) {
            query["SourcePort"] = request.sourcePort;
        }
        if (!tea_util_1.default.isUnset(request.taskId)) {
            query["TaskId"] = request.taskId;
        }
        if (!tea_util_1.default.isUnset(request.taskName)) {
            query["TaskName"] = request.taskName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeCloudMigrationPrecheckResult",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCloudMigrationPrecheckResultResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      *
      * @param request DescribeCloudMigrationPrecheckResultRequest
      * @return DescribeCloudMigrationPrecheckResultResponse
     */
    async describeCloudMigrationPrecheckResult(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeCloudMigrationPrecheckResultWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      *
      * @param request DescribeCloudMigrationResultRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeCloudMigrationResultResponse
     */
    async describeCloudMigrationResultWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceName)) {
            query["DBInstanceName"] = request.DBInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.sourceIpAddress)) {
            query["SourceIpAddress"] = request.sourceIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.sourcePort)) {
            query["SourcePort"] = request.sourcePort;
        }
        if (!tea_util_1.default.isUnset(request.taskId)) {
            query["TaskId"] = request.taskId;
        }
        if (!tea_util_1.default.isUnset(request.taskName)) {
            query["TaskName"] = request.taskName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeCloudMigrationResult",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCloudMigrationResultResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      *
      * @param request DescribeCloudMigrationResultRequest
      * @return DescribeCloudMigrationResultResponse
     */
    async describeCloudMigrationResult(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeCloudMigrationResultWithOptions(request, runtime);
    }
    /**
      * ### Supported database engine
      * SQL Server
      *
      * @param request DescribeCollationTimeZonesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeCollationTimeZonesResponse
     */
    async describeCollationTimeZonesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeCollationTimeZones",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCollationTimeZonesResponse({}));
    }
    /**
      * ### Supported database engine
      * SQL Server
      *
      * @param request DescribeCollationTimeZonesRequest
      * @return DescribeCollationTimeZonesResponse
     */
    async describeCollationTimeZones(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeCollationTimeZonesWithOptions(request, runtime);
    }
    /**
      * ApsaraDB RDS for MySQL instances support cross-region backup and restoration. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~) and [Restore the data of an ApsaraDB RDS for MySQL instance across regions](~~120875~~).
      * Before you call this operation, make sure that the instance runs one of the following database engines:
      * *   MySQL. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~).
      * *   SQL Server. For more information, see [Back up an ApsaraDB RDS for SQL Server instance across regions](~~187923~~).
      * *   PostgreSQL. For more information, see [Enable cross-region backups for an ApsaraDB RDS for PostgreSQL instance](~~206671~~).
      *
      * @param request DescribeCrossBackupMetaListRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeCrossBackupMetaListResponse
     */
    async describeCrossBackupMetaListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupSetId)) {
            query["BackupSetId"] = request.backupSetId;
        }
        if (!tea_util_1.default.isUnset(request.getDbName)) {
            query["GetDbName"] = request.getDbName;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageIndex)) {
            query["PageIndex"] = request.pageIndex;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.pattern)) {
            query["Pattern"] = request.pattern;
        }
        if (!tea_util_1.default.isUnset(request.region)) {
            query["Region"] = request.region;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeCrossBackupMetaList",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCrossBackupMetaListResponse({}));
    }
    /**
      * ApsaraDB RDS for MySQL instances support cross-region backup and restoration. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~) and [Restore the data of an ApsaraDB RDS for MySQL instance across regions](~~120875~~).
      * Before you call this operation, make sure that the instance runs one of the following database engines:
      * *   MySQL. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~).
      * *   SQL Server. For more information, see [Back up an ApsaraDB RDS for SQL Server instance across regions](~~187923~~).
      * *   PostgreSQL. For more information, see [Enable cross-region backups for an ApsaraDB RDS for PostgreSQL instance](~~206671~~).
      *
      * @param request DescribeCrossBackupMetaListRequest
      * @return DescribeCrossBackupMetaListResponse
     */
    async describeCrossBackupMetaList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeCrossBackupMetaListWithOptions(request, runtime);
    }
    /**
      * Before you call this operation, make sure that the instance runs one of the following database engines:
      * *   MySQL. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~).
      * *   SQL Server. For more information, see [Back up an ApsaraDB RDS for SQL Server instance across regions](~~187923~~).
      * *   PostgreSQL. For more information, see [Enable cross-region backups for an ApsaraDB RDS for PostgreSQL instance](~~206671~~).
      *
      * @param request DescribeCrossRegionBackupDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeCrossRegionBackupDBInstanceResponse
     */
    async describeCrossRegionBackupDBInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeCrossRegionBackupDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCrossRegionBackupDBInstanceResponse({}));
    }
    /**
      * Before you call this operation, make sure that the instance runs one of the following database engines:
      * *   MySQL. For more information, see [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~).
      * *   SQL Server. For more information, see [Back up an ApsaraDB RDS for SQL Server instance across regions](~~187923~~).
      * *   PostgreSQL. For more information, see [Enable cross-region backups for an ApsaraDB RDS for PostgreSQL instance](~~206671~~).
      *
      * @param request DescribeCrossRegionBackupDBInstanceRequest
      * @return DescribeCrossRegionBackupDBInstanceResponse
     */
    async describeCrossRegionBackupDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeCrossRegionBackupDBInstanceWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](~~120824~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
      * >  For more information about how to query cross-region log backup files, see [DescribeCrossRegionLogBackupFiles](~~121734~~).
      *
      * @param request DescribeCrossRegionBackupsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeCrossRegionBackupsResponse
     */
    async describeCrossRegionBackupsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupId)) {
            query["BackupId"] = request.backupId;
        }
        if (!tea_util_1.default.isUnset(request.crossBackupId)) {
            query["CrossBackupId"] = request.crossBackupId;
        }
        if (!tea_util_1.default.isUnset(request.crossBackupRegion)) {
            query["CrossBackupRegion"] = request.crossBackupRegion;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeCrossRegionBackups",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCrossRegionBackupsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](~~120824~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
      * >  For more information about how to query cross-region log backup files, see [DescribeCrossRegionLogBackupFiles](~~121734~~).
      *
      * @param request DescribeCrossRegionBackupsRequest
      * @return DescribeCrossRegionBackupsResponse
     */
    async describeCrossRegionBackups(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeCrossRegionBackupsWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](~~120824~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
      * >  For more information about how to query cross-region data backup files, see [DescribeCrossRegionBackups](~~121733~~).
      *
      * @param request DescribeCrossRegionLogBackupFilesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeCrossRegionLogBackupFilesResponse
     */
    async describeCrossRegionLogBackupFilesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.crossBackupRegion)) {
            query["CrossBackupRegion"] = request.crossBackupRegion;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeCrossRegionLogBackupFiles",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCrossRegionLogBackupFilesResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](~~120824~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
      * >  For more information about how to query cross-region data backup files, see [DescribeCrossRegionBackups](~~121733~~).
      *
      * @param request DescribeCrossRegionLogBackupFilesRequest
      * @return DescribeCrossRegionLogBackupFilesResponse
     */
    async describeCrossRegionLogBackupFiles(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeCrossRegionLogBackupFilesWithOptions(request, runtime);
    }
    async describeCurrentModifyOrderWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.dbInstanceId)) {
            query["DbInstanceId"] = request.dbInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeCurrentModifyOrder",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCurrentModifyOrderResponse({}));
    }
    async describeCurrentModifyOrder(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeCurrentModifyOrderWithOptions(request, runtime);
    }
    async describeCustinsResourceInfoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceIds)) {
            query["DBInstanceIds"] = request.DBInstanceIds;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeCustinsResourceInfo",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeCustinsResourceInfoResponse({}));
    }
    async describeCustinsResourceInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeCustinsResourceInfoWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request DescribeDBInstanceAttributeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstanceAttributeResponse
     */
    async describeDBInstanceAttributeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.expired)) {
            query["Expired"] = request.expired;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceAttribute",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceAttributeResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request DescribeDBInstanceAttributeRequest
      * @return DescribeDBInstanceAttributeResponse
     */
    async describeDBInstanceAttribute(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceAttributeWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeDBInstanceByTagsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstanceByTagsResponse
     */
    async describeDBInstanceByTagsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.proxyId)) {
            query["proxyId"] = request.proxyId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceByTags",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceByTagsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeDBInstanceByTagsRequest
      * @return DescribeDBInstanceByTagsResponse
     */
    async describeDBInstanceByTags(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceByTagsWithOptions(request, runtime);
    }
    async describeDBInstanceConnectivityWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = openapi_util_1.default.query(tea_util_1.default.toMap(request));
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceConnectivity",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "GET",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceConnectivityResponse({}));
    }
    async describeDBInstanceConnectivity(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceConnectivityWithOptions(request, runtime);
    }
    /**
      * This operation is phased out.
      *
      * @param request DescribeDBInstanceDetailRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstanceDetailResponse
     */
    async describeDBInstanceDetailWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceDetail",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceDetailResponse({}));
    }
    /**
      * This operation is phased out.
      *
      * @param request DescribeDBInstanceDetailRequest
      * @return DescribeDBInstanceDetailResponse
     */
    async describeDBInstanceDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceDetailWithOptions(request, runtime);
    }
    async describeDBInstanceEncryptionKeyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.encryptionKey)) {
            query["EncryptionKey"] = request.encryptionKey;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        if (!tea_util_1.default.isUnset(request.targetRegionId)) {
            query["TargetRegionId"] = request.targetRegionId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceEncryptionKey",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceEncryptionKeyResponse({}));
    }
    async describeDBInstanceEncryptionKey(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceEncryptionKeyWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * RDS MySQL
      *
      * @param request DescribeDBInstanceEndpointsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstanceEndpointsResponse
     */
    async describeDBInstanceEndpointsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceEndpointId)) {
            query["DBInstanceEndpointId"] = request.DBInstanceEndpointId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceEndpoints",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceEndpointsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * RDS MySQL
      *
      * @param request DescribeDBInstanceEndpointsRequest
      * @return DescribeDBInstanceEndpointsResponse
     */
    async describeDBInstanceEndpoints(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceEndpointsWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Query the data replication mode of an ApsaraDB RDS for MySQL instance](~~96055~~)
      * *   [Query the data replication mode of an ApsaraDB RDS for PostgreSQL instance](~~151265~~)
      * *   [Query the data replication mode of an ApsaraDB RDS for SQL Server instance](~~415433~~)
      *
      * @param request DescribeDBInstanceHAConfigRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstanceHAConfigResponse
     */
    async describeDBInstanceHAConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceHAConfig",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceHAConfigResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Query the data replication mode of an ApsaraDB RDS for MySQL instance](~~96055~~)
      * *   [Query the data replication mode of an ApsaraDB RDS for PostgreSQL instance](~~151265~~)
      * *   [Query the data replication mode of an ApsaraDB RDS for SQL Server instance](~~415433~~)
      *
      * @param request DescribeDBInstanceHAConfigRequest
      * @return DescribeDBInstanceHAConfigResponse
     */
    async describeDBInstanceHAConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceHAConfigWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request DescribeDBInstanceIPArrayListRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstanceIPArrayListResponse
     */
    async describeDBInstanceIPArrayListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.whitelistNetworkType)) {
            query["WhitelistNetworkType"] = request.whitelistNetworkType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceIPArrayList",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceIPArrayListResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request DescribeDBInstanceIPArrayListRequest
      * @return DescribeDBInstanceIPArrayListResponse
     */
    async describeDBInstanceIPArrayList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceIPArrayListWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * RDS SQL Server
      * ### [](#)Prerequisites
      * *   The RDS instance runs RDS Basic Edition, RDS High-availability Edition, or RDS Cluster Edition. If your RDS instance runs RDS High-availability Edition, make sure that the instance runs SQL Server 2012 or later.
      * *   The RDS instance belongs to a general-purpose or dedicated instance family. The shared instance family is not supported.
      * *   If the RDS instance runs RDS Basic Edition, the instance is created on or after September 02, 2022. You can view the Creation Time
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Configure a distributed transaction whitelist](~~124321~~)
      *
      * @param request DescribeDBInstanceIpHostnameRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstanceIpHostnameResponse
     */
    async describeDBInstanceIpHostnameWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceIpHostname",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceIpHostnameResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * RDS SQL Server
      * ### [](#)Prerequisites
      * *   The RDS instance runs RDS Basic Edition, RDS High-availability Edition, or RDS Cluster Edition. If your RDS instance runs RDS High-availability Edition, make sure that the instance runs SQL Server 2012 or later.
      * *   The RDS instance belongs to a general-purpose or dedicated instance family. The shared instance family is not supported.
      * *   If the RDS instance runs RDS Basic Edition, the instance is created on or after September 02, 2022. You can view the Creation Time
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Configure a distributed transaction whitelist](~~124321~~)
      *
      * @param request DescribeDBInstanceIpHostnameRequest
      * @return DescribeDBInstanceIpHostnameResponse
     */
    async describeDBInstanceIpHostname(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceIpHostnameWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [View the Enhanced Monitoring metrics](~~299200~~)
      *
      * @param request DescribeDBInstanceMetricsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstanceMetricsResponse
     */
    async describeDBInstanceMetricsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceName)) {
            query["DBInstanceName"] = request.DBInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceMetrics",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceMetricsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [View the Enhanced Monitoring metrics](~~299200~~)
      *
      * @param request DescribeDBInstanceMetricsRequest
      * @return DescribeDBInstanceMetricsResponse
     */
    async describeDBInstanceMetrics(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceMetricsWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeDBInstanceMonitorRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstanceMonitorResponse
     */
    async describeDBInstanceMonitorWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceMonitor",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceMonitorResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeDBInstanceMonitorRequest
      * @return DescribeDBInstanceMonitorResponse
     */
    async describeDBInstanceMonitor(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceMonitorWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeDBInstanceNetInfoRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstanceNetInfoResponse
     */
    async describeDBInstanceNetInfoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceNetRWSplitType)) {
            query["DBInstanceNetRWSplitType"] = request.DBInstanceNetRWSplitType;
        }
        if (!tea_util_1.default.isUnset(request.flag)) {
            query["Flag"] = request.flag;
        }
        if (!tea_util_1.default.isUnset(request.generalGroupName)) {
            query["GeneralGroupName"] = request.generalGroupName;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceNetInfo",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceNetInfoResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeDBInstanceNetInfoRequest
      * @return DescribeDBInstanceNetInfoResponse
     */
    async describeDBInstanceNetInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceNetInfoWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeDBInstanceNetInfoForChannelRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstanceNetInfoForChannelResponse
     */
    async describeDBInstanceNetInfoForChannelWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceNetRWSplitType)) {
            query["DBInstanceNetRWSplitType"] = request.DBInstanceNetRWSplitType;
        }
        if (!tea_util_1.default.isUnset(request.flag)) {
            query["Flag"] = request.flag;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceNetInfoForChannel",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceNetInfoForChannelResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeDBInstanceNetInfoForChannelRequest
      * @return DescribeDBInstanceNetInfoForChannelResponse
     */
    async describeDBInstanceNetInfoForChannel(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceNetInfoForChannelWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeDBInstancePerformanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstancePerformanceResponse
     */
    async describeDBInstancePerformanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.key)) {
            query["Key"] = request.key;
        }
        if (!tea_util_1.default.isUnset(request.nodeId)) {
            query["NodeId"] = request.nodeId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstancePerformance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstancePerformanceResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeDBInstancePerformanceRequest
      * @return DescribeDBInstancePerformanceResponse
     */
    async describeDBInstancePerformance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstancePerformanceWithOptions(request, runtime);
    }
    /**
      * @deprecated
      *
      * @param request DescribeDBInstancePromoteActivityRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstancePromoteActivityResponse
     */
    // Deprecated
    async describeDBInstancePromoteActivityWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.aliUid)) {
            query["AliUid"] = request.aliUid;
        }
        if (!tea_util_1.default.isUnset(request.dbInstanceName)) {
            query["DbInstanceName"] = request.dbInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstancePromoteActivity",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstancePromoteActivityResponse({}));
    }
    /**
      * @deprecated
      *
      * @param request DescribeDBInstancePromoteActivityRequest
      * @return DescribeDBInstancePromoteActivityResponse
     */
    // Deprecated
    async describeDBInstancePromoteActivity(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstancePromoteActivityWithOptions(request, runtime);
    }
    /**
      * This operation is used to query the original settings of shared proxies rather than the latest settings of dedicated proxies. For more information about how to query the settings of dedicated proxies, see [DescribeDBProxy](~~141055~~).
      * Before you call this operation, make sure that the following requirements are met:
      * *   The shared proxy feature must be enabled for the primary instance.
      * *   The read/write splitting feature must be enabled for the primary instance.
      *
      * @param request DescribeDBInstanceProxyConfigurationRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstanceProxyConfigurationResponse
     */
    async describeDBInstanceProxyConfigurationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceProxyConfiguration",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceProxyConfigurationResponse({}));
    }
    /**
      * This operation is used to query the original settings of shared proxies rather than the latest settings of dedicated proxies. For more information about how to query the settings of dedicated proxies, see [DescribeDBProxy](~~141055~~).
      * Before you call this operation, make sure that the following requirements are met:
      * *   The shared proxy feature must be enabled for the primary instance.
      * *   The read/write splitting feature must be enabled for the primary instance.
      *
      * @param request DescribeDBInstanceProxyConfigurationRequest
      * @return DescribeDBInstanceProxyConfigurationResponse
     */
    async describeDBInstanceProxyConfiguration(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceProxyConfigurationWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      *
      * @param request DescribeDBInstanceSSLRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstanceSSLResponse
     */
    async describeDBInstanceSSLWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceSSL",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceSSLResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      *
      * @param request DescribeDBInstanceSSLRequest
      * @return DescribeDBInstanceSSLResponse
     */
    async describeDBInstanceSSL(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceSSLWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      *
      * @param request DescribeDBInstanceTDERequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstanceTDEResponse
     */
    async describeDBInstanceTDEWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstanceTDE",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstanceTDEResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      *
      * @param request DescribeDBInstanceTDERequest
      * @return DescribeDBInstanceTDEResponse
     */
    async describeDBInstanceTDE(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstanceTDEWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeDBInstancesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstancesResponse
     */
    async describeDBInstancesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.category)) {
            query["Category"] = request.category;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.connectionMode)) {
            query["ConnectionMode"] = request.connectionMode;
        }
        if (!tea_util_1.default.isUnset(request.connectionString)) {
            query["ConnectionString"] = request.connectionString;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceClass)) {
            query["DBInstanceClass"] = request.DBInstanceClass;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStatus)) {
            query["DBInstanceStatus"] = request.DBInstanceStatus;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceType)) {
            query["DBInstanceType"] = request.DBInstanceType;
        }
        if (!tea_util_1.default.isUnset(request.dedicatedHostGroupId)) {
            query["DedicatedHostGroupId"] = request.dedicatedHostGroupId;
        }
        if (!tea_util_1.default.isUnset(request.dedicatedHostId)) {
            query["DedicatedHostId"] = request.dedicatedHostId;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.expired)) {
            query["Expired"] = request.expired;
        }
        if (!tea_util_1.default.isUnset(request.filter)) {
            query["Filter"] = request.filter;
        }
        if (!tea_util_1.default.isUnset(request.instanceLevel)) {
            query["InstanceLevel"] = request.instanceLevel;
        }
        if (!tea_util_1.default.isUnset(request.instanceNetworkType)) {
            query["InstanceNetworkType"] = request.instanceNetworkType;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.payType)) {
            query["PayType"] = request.payType;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.searchKey)) {
            query["SearchKey"] = request.searchKey;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            query["Tags"] = request.tags;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        if (!tea_util_1.default.isUnset(request.vpcId)) {
            query["VpcId"] = request.vpcId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        if (!tea_util_1.default.isUnset(request.proxyId)) {
            query["proxyId"] = request.proxyId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstances",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstancesResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeDBInstancesRequest
      * @return DescribeDBInstancesResponse
     */
    async describeDBInstances(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstancesWithOptions(request, runtime);
    }
    /**
      * @deprecated : DescribeDBInstancesAsCsv is deprecated, please use Rds::2014-08-15::DescribeDBInstances instead.
      * **
      * **Description:** This operation is phased out. Use the [DescribeDBInstances](~~610396~~) operation instead.
      *
      * @param request DescribeDBInstancesAsCsvRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstancesAsCsvResponse
     */
    // Deprecated
    async describeDBInstancesAsCsvWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.cachedAsync)) {
            query["CachedAsync"] = request.cachedAsync;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.exportKey)) {
            query["ExportKey"] = request.exportKey;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstancesAsCsv",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstancesAsCsvResponse({}));
    }
    /**
      * @deprecated : DescribeDBInstancesAsCsv is deprecated, please use Rds::2014-08-15::DescribeDBInstances instead.
      * **
      * **Description:** This operation is phased out. Use the [DescribeDBInstances](~~610396~~) operation instead.
      *
      * @param request DescribeDBInstancesAsCsvRequest
      * @return DescribeDBInstancesAsCsvResponse
     */
    // Deprecated
    async describeDBInstancesAsCsv(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstancesAsCsvWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request DescribeDBInstancesByExpireTimeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstancesByExpireTimeResponse
     */
    async describeDBInstancesByExpireTimeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.expirePeriod)) {
            query["ExpirePeriod"] = request.expirePeriod;
        }
        if (!tea_util_1.default.isUnset(request.expired)) {
            query["Expired"] = request.expired;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            query["Tags"] = request.tags;
        }
        if (!tea_util_1.default.isUnset(request.proxyId)) {
            query["proxyId"] = request.proxyId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstancesByExpireTime",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstancesByExpireTimeResponse({}));
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request DescribeDBInstancesByExpireTimeRequest
      * @return DescribeDBInstancesByExpireTimeResponse
     */
    async describeDBInstancesByExpireTime(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstancesByExpireTimeWithOptions(request, runtime);
    }
    /**
      * This operation is phased out.
      *
      * @param request DescribeDBInstancesByPerformanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstancesByPerformanceResponse
     */
    async describeDBInstancesByPerformanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.sortKey)) {
            query["SortKey"] = request.sortKey;
        }
        if (!tea_util_1.default.isUnset(request.sortMethod)) {
            query["SortMethod"] = request.sortMethod;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            query["Tags"] = request.tags;
        }
        if (!tea_util_1.default.isUnset(request.proxyId)) {
            query["proxyId"] = request.proxyId;
        }
        if (!tea_util_1.default.isUnset(request.tag)) {
            query["Tag"] = request.tag;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstancesByPerformance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstancesByPerformanceResponse({}));
    }
    /**
      * This operation is phased out.
      *
      * @param request DescribeDBInstancesByPerformanceRequest
      * @return DescribeDBInstancesByPerformanceResponse
     */
    async describeDBInstancesByPerformance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstancesByPerformanceWithOptions(request, runtime);
    }
    /**
      * This operation is phased out.
      *
      * @param request DescribeDBInstancesForCloneRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBInstancesForCloneResponse
     */
    async describeDBInstancesForCloneWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.connectionMode)) {
            query["ConnectionMode"] = request.connectionMode;
        }
        if (!tea_util_1.default.isUnset(request.currentInstanceId)) {
            query["CurrentInstanceId"] = request.currentInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceClass)) {
            query["DBInstanceClass"] = request.DBInstanceClass;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStatus)) {
            query["DBInstanceStatus"] = request.DBInstanceStatus;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceType)) {
            query["DBInstanceType"] = request.DBInstanceType;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.expired)) {
            query["Expired"] = request.expired;
        }
        if (!tea_util_1.default.isUnset(request.instanceNetworkType)) {
            query["InstanceNetworkType"] = request.instanceNetworkType;
        }
        if (!tea_util_1.default.isUnset(request.nodeType)) {
            query["NodeType"] = request.nodeType;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.payType)) {
            query["PayType"] = request.payType;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.searchKey)) {
            query["SearchKey"] = request.searchKey;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        if (!tea_util_1.default.isUnset(request.vpcId)) {
            query["VpcId"] = request.vpcId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        if (!tea_util_1.default.isUnset(request.proxyId)) {
            query["proxyId"] = request.proxyId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBInstancesForClone",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBInstancesForCloneResponse({}));
    }
    /**
      * This operation is phased out.
      *
      * @param request DescribeDBInstancesForCloneRequest
      * @return DescribeDBInstancesForCloneResponse
     */
    async describeDBInstancesForClone(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBInstancesForCloneWithOptions(request, runtime);
    }
    /**
      * Before you purchase or upgrade an instance that runs MySQL or PostgreSQL, you can call the DescribeDBMiniEngineVersions operation to query the minor engine versions that are available for the instance.
      *
      * @param request DescribeDBMiniEngineVersionsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBMiniEngineVersionsResponse
     */
    async describeDBMiniEngineVersionsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.dedicatedHostGroupId)) {
            query["DedicatedHostGroupId"] = request.dedicatedHostGroupId;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.minorVersionTag)) {
            query["MinorVersionTag"] = request.minorVersionTag;
        }
        if (!tea_util_1.default.isUnset(request.nodeType)) {
            query["NodeType"] = request.nodeType;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.storageType)) {
            query["StorageType"] = request.storageType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBMiniEngineVersions",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBMiniEngineVersionsResponse({}));
    }
    /**
      * Before you purchase or upgrade an instance that runs MySQL or PostgreSQL, you can call the DescribeDBMiniEngineVersions operation to query the minor engine versions that are available for the instance.
      *
      * @param request DescribeDBMiniEngineVersionsRequest
      * @return DescribeDBMiniEngineVersionsResponse
     */
    async describeDBMiniEngineVersions(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBMiniEngineVersionsWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      *
      * @param request DescribeDBProxyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBProxyResponse
     */
    async describeDBProxyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyEngineType)) {
            query["DBProxyEngineType"] = request.DBProxyEngineType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBProxy",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBProxyResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      *
      * @param request DescribeDBProxyRequest
      * @return DescribeDBProxyResponse
     */
    async describeDBProxy(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBProxyWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      *
      * @param request DescribeDBProxyEndpointRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBProxyEndpointResponse
     */
    async describeDBProxyEndpointWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyConnectString)) {
            query["DBProxyConnectString"] = request.DBProxyConnectString;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyEndpointId)) {
            query["DBProxyEndpointId"] = request.DBProxyEndpointId;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyEngineType)) {
            query["DBProxyEngineType"] = request.DBProxyEngineType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBProxyEndpoint",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBProxyEndpointResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      *
      * @param request DescribeDBProxyEndpointRequest
      * @return DescribeDBProxyEndpointResponse
     */
    async describeDBProxyEndpoint(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBProxyEndpointWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * >  Starting October 17, 2023, ApsaraDB RDS provides a dedicated proxy free of charge for each ApsaraDB RDS for MySQL instance on RDS Cluster Edition. For more information, see [\\[Special offers/Price changes\\] One proxy is provided free of charge for ApsaraDB RDS for MySQL instances on RDS Cluster Edition](~~2555466~~).
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [View the monitoring data of an ApsaraDB RDS for MySQL instance](~~194241~~)
      * *   [View the monitoring data of an ApsaraDB RDS for PostgreSQL instance](~~418275~~)
      *
      * @param request DescribeDBProxyPerformanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDBProxyPerformanceResponse
     */
    async describeDBProxyPerformanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyEngineType)) {
            query["DBProxyEngineType"] = request.DBProxyEngineType;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyInstanceType)) {
            query["DBProxyInstanceType"] = request.DBProxyInstanceType;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.metricsName)) {
            query["MetricsName"] = request.metricsName;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDBProxyPerformance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDBProxyPerformanceResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * >  Starting October 17, 2023, ApsaraDB RDS provides a dedicated proxy free of charge for each ApsaraDB RDS for MySQL instance on RDS Cluster Edition. For more information, see [\\[Special offers/Price changes\\] One proxy is provided free of charge for ApsaraDB RDS for MySQL instances on RDS Cluster Edition](~~2555466~~).
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [View the monitoring data of an ApsaraDB RDS for MySQL instance](~~194241~~)
      * *   [View the monitoring data of an ApsaraDB RDS for PostgreSQL instance](~~418275~~)
      *
      * @param request DescribeDBProxyPerformanceRequest
      * @return DescribeDBProxyPerformanceResponse
     */
    async describeDBProxyPerformance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDBProxyPerformanceWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Configures a distributed transaction whitelist for an ApsaraDB RDS for SQL Server instance](~~124321~~)
      *
      * @param request DescribeDTCSecurityIpHostsForSQLServerRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDTCSecurityIpHostsForSQLServerResponse
     */
    async describeDTCSecurityIpHostsForSQLServerWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDTCSecurityIpHostsForSQLServer",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDTCSecurityIpHostsForSQLServerResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Configures a distributed transaction whitelist for an ApsaraDB RDS for SQL Server instance](~~124321~~)
      *
      * @param request DescribeDTCSecurityIpHostsForSQLServerRequest
      * @return DescribeDTCSecurityIpHostsForSQLServerResponse
     */
    async describeDTCSecurityIpHostsForSQLServer(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDTCSecurityIpHostsForSQLServerWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeDatabasesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDatabasesResponse
     */
    async describeDatabasesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.DBStatus)) {
            query["DBStatus"] = request.DBStatus;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDatabases",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDatabasesResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeDatabasesRequest
      * @return DescribeDatabasesResponse
     */
    async describeDatabases(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDatabasesWithOptions(request, runtime);
    }
    /**
      * Dedicated clusters allow you to manage a number of instances in a cluster at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
      *
      * @param request DescribeDedicatedHostGroupsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDedicatedHostGroupsResponse
     */
    async describeDedicatedHostGroupsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dedicatedHostGroupId)) {
            query["DedicatedHostGroupId"] = request.dedicatedHostGroupId;
        }
        if (!tea_util_1.default.isUnset(request.imageCategory)) {
            query["ImageCategory"] = request.imageCategory;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDedicatedHostGroups",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDedicatedHostGroupsResponse({}));
    }
    /**
      * Dedicated clusters allow you to manage a number of instances in a cluster at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
      *
      * @param request DescribeDedicatedHostGroupsRequest
      * @return DescribeDedicatedHostGroupsResponse
     */
    async describeDedicatedHostGroups(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDedicatedHostGroupsWithOptions(request, runtime);
    }
    /**
      * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
      *
      * @param request DescribeDedicatedHostsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDedicatedHostsResponse
     */
    async describeDedicatedHostsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.allocationStatus)) {
            query["AllocationStatus"] = request.allocationStatus;
        }
        if (!tea_util_1.default.isUnset(request.dedicatedHostGroupId)) {
            query["DedicatedHostGroupId"] = request.dedicatedHostGroupId;
        }
        if (!tea_util_1.default.isUnset(request.dedicatedHostId)) {
            query["DedicatedHostId"] = request.dedicatedHostId;
        }
        if (!tea_util_1.default.isUnset(request.hostStatus)) {
            query["HostStatus"] = request.hostStatus;
        }
        if (!tea_util_1.default.isUnset(request.hostType)) {
            query["HostType"] = request.hostType;
        }
        if (!tea_util_1.default.isUnset(request.orderId)) {
            query["OrderId"] = request.orderId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDedicatedHosts",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDedicatedHostsResponse({}));
    }
    /**
      * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
      *
      * @param request DescribeDedicatedHostsRequest
      * @return DescribeDedicatedHostsResponse
     */
    async describeDedicatedHosts(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDedicatedHostsWithOptions(request, runtime);
    }
    /**
      * ### Supported database engine
      * MySQL
      * > This operation is available only for instances that use local disks.
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * For more information about how to retain the data backup files of an instance after the instance is released, see [Configure automatic backup](~~98818~~).
      *
      * @param request DescribeDetachedBackupsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDetachedBackupsResponse
     */
    async describeDetachedBackupsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupId)) {
            query["BackupId"] = request.backupId;
        }
        if (!tea_util_1.default.isUnset(request.backupMode)) {
            query["BackupMode"] = request.backupMode;
        }
        if (!tea_util_1.default.isUnset(request.backupStatus)) {
            query["BackupStatus"] = request.backupStatus;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.region)) {
            query["Region"] = request.region;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDetachedBackups",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDetachedBackupsResponse({}));
    }
    /**
      * ### Supported database engine
      * MySQL
      * > This operation is available only for instances that use local disks.
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * For more information about how to retain the data backup files of an instance after the instance is released, see [Configure automatic backup](~~98818~~).
      *
      * @param request DescribeDetachedBackupsRequest
      * @return DescribeDetachedBackupsResponse
     */
    async describeDetachedBackups(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDetachedBackupsWithOptions(request, runtime);
    }
    /**
      * @deprecated
      * >  This operation is phased out.
      *
      * @param request DescribeDiagnosticReportListRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeDiagnosticReportListResponse
     */
    // Deprecated
    async describeDiagnosticReportListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeDiagnosticReportList",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeDiagnosticReportListResponse({}));
    }
    /**
      * @deprecated
      * >  This operation is phased out.
      *
      * @param request DescribeDiagnosticReportListRequest
      * @return DescribeDiagnosticReportListResponse
     */
    // Deprecated
    async describeDiagnosticReportList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeDiagnosticReportListWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeErrorLogsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeErrorLogsResponse
     */
    async describeErrorLogsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeErrorLogs",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeErrorLogsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeErrorLogsRequest
      * @return DescribeErrorLogsResponse
     */
    async describeErrorLogs(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeErrorLogsWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Historical events of an ApsaraDB RDS for MySQL instance](~~129759~~)
      * *   [Historical events of an ApsaraDB RDS for PostgreSQL instance](~~131008~~)
      * *   [Historical events of an ApsaraDB RDS for SQL Server instance](~~131013~~)
      * *   [Historical events of an ApsaraDB RDS for MariaDB instance](~~131010~~)
      *
      * @param request DescribeEventsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeEventsResponse
     */
    async describeEventsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeEvents",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeEventsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Historical events of an ApsaraDB RDS for MySQL instance](~~129759~~)
      * *   [Historical events of an ApsaraDB RDS for PostgreSQL instance](~~131008~~)
      * *   [Historical events of an ApsaraDB RDS for SQL Server instance](~~131013~~)
      * *   [Historical events of an ApsaraDB RDS for MariaDB instance](~~131010~~)
      *
      * @param request DescribeEventsRequest
      * @return DescribeEventsResponse
     */
    async describeEvents(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeEventsWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      *
      * @param request DescribeGadInstancesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeGadInstancesResponse
     */
    async describeGadInstancesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.gadInstanceName)) {
            query["GadInstanceName"] = request.gadInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeGadInstances",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeGadInstancesResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      *
      * @param request DescribeGadInstancesRequest
      * @return DescribeGadInstancesResponse
     */
    async describeGadInstances(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeGadInstancesWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * [What is availability detection?](~~207467~~)
      *
      * @param request DescribeHADiagnoseConfigRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeHADiagnoseConfigResponse
     */
    async describeHADiagnoseConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeHADiagnoseConfig",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeHADiagnoseConfigResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * [What is availability detection?](~~207467~~)
      *
      * @param request DescribeHADiagnoseConfigRequest
      * @return DescribeHADiagnoseConfigResponse
     */
    async describeHADiagnoseConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeHADiagnoseConfigWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeHASwitchConfigRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeHASwitchConfigResponse
     */
    async describeHASwitchConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeHASwitchConfig",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeHASwitchConfigResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeHASwitchConfigRequest
      * @return DescribeHASwitchConfigResponse
     */
    async describeHASwitchConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeHASwitchConfigWithOptions(request, runtime);
    }
    async describeHistoryEventsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.archiveStatus)) {
            query["ArchiveStatus"] = request.archiveStatus;
        }
        if (!tea_util_1.default.isUnset(request.eventCategory)) {
            query["EventCategory"] = request.eventCategory;
        }
        if (!tea_util_1.default.isUnset(request.eventId)) {
            query["EventId"] = request.eventId;
        }
        if (!tea_util_1.default.isUnset(request.eventLevel)) {
            query["EventLevel"] = request.eventLevel;
        }
        if (!tea_util_1.default.isUnset(request.eventStatus)) {
            query["EventStatus"] = request.eventStatus;
        }
        if (!tea_util_1.default.isUnset(request.eventType)) {
            query["EventType"] = request.eventType;
        }
        if (!tea_util_1.default.isUnset(request.fromStartTime)) {
            query["FromStartTime"] = request.fromStartTime;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        if (!tea_util_1.default.isUnset(request.taskId)) {
            query["TaskId"] = request.taskId;
        }
        if (!tea_util_1.default.isUnset(request.toStartTime)) {
            query["ToStartTime"] = request.toStartTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeHistoryEvents",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeHistoryEventsResponse({}));
    }
    async describeHistoryEvents(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeHistoryEventsWithOptions(request, runtime);
    }
    async describeHistoryEventsStatWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.archiveStatus)) {
            query["ArchiveStatus"] = request.archiveStatus;
        }
        if (!tea_util_1.default.isUnset(request.fromStartTime)) {
            query["FromStartTime"] = request.fromStartTime;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        if (!tea_util_1.default.isUnset(request.toStartTime)) {
            query["ToStartTime"] = request.toStartTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeHistoryEventsStat",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeHistoryEventsStatResponse({}));
    }
    async describeHistoryEventsStat(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeHistoryEventsStatWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Tasks of an ApsaraDB RDS for MySQL instance](~~474275~~)
      * *   [Tasks of an ApsaraDB RDS for PostrgreSQL instance](~~474537~~)
      * *   [Tasks of an ApsaraDB RDS for SQL Server instance](~~614826~~)
      *
      * @param request DescribeHistoryTasksRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeHistoryTasksResponse
     */
    async describeHistoryTasksWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.fromExecTime)) {
            query["FromExecTime"] = request.fromExecTime;
        }
        if (!tea_util_1.default.isUnset(request.fromStartTime)) {
            query["FromStartTime"] = request.fromStartTime;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.instanceType)) {
            query["InstanceType"] = request.instanceType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            query["Status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.taskId)) {
            query["TaskId"] = request.taskId;
        }
        if (!tea_util_1.default.isUnset(request.taskType)) {
            query["TaskType"] = request.taskType;
        }
        if (!tea_util_1.default.isUnset(request.toExecTime)) {
            query["ToExecTime"] = request.toExecTime;
        }
        if (!tea_util_1.default.isUnset(request.toStartTime)) {
            query["ToStartTime"] = request.toStartTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeHistoryTasks",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeHistoryTasksResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Tasks of an ApsaraDB RDS for MySQL instance](~~474275~~)
      * *   [Tasks of an ApsaraDB RDS for PostrgreSQL instance](~~474537~~)
      * *   [Tasks of an ApsaraDB RDS for SQL Server instance](~~614826~~)
      *
      * @param request DescribeHistoryTasksRequest
      * @return DescribeHistoryTasksResponse
     */
    async describeHistoryTasks(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeHistoryTasksWithOptions(request, runtime);
    }
    async describeHistoryTasksStatWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.fromExecTime)) {
            query["FromExecTime"] = request.fromExecTime;
        }
        if (!tea_util_1.default.isUnset(request.fromStartTime)) {
            query["FromStartTime"] = request.fromStartTime;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            query["InstanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            query["Status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.taskId)) {
            query["TaskId"] = request.taskId;
        }
        if (!tea_util_1.default.isUnset(request.taskType)) {
            query["TaskType"] = request.taskType;
        }
        if (!tea_util_1.default.isUnset(request.toExecTime)) {
            query["ToExecTime"] = request.toExecTime;
        }
        if (!tea_util_1.default.isUnset(request.toStartTime)) {
            query["ToStartTime"] = request.toStartTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeHistoryTasksStat",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeHistoryTasksStatResponse({}));
    }
    async describeHistoryTasksStat(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeHistoryTasksStatWithOptions(request, runtime);
    }
    async describeHostGroupElasticStrategyParametersWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dedicatedHostGroupName)) {
            query["DedicatedHostGroupName"] = request.dedicatedHostGroupName;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeHostGroupElasticStrategyParameters",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeHostGroupElasticStrategyParametersResponse({}));
    }
    async describeHostGroupElasticStrategyParameters(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeHostGroupElasticStrategyParametersWithOptions(request, runtime);
    }
    /**
      * >  This operation is available only for instances that run SQL Server. If you require this operation, contact **Alibaba Cloud technical support**.
      * ### [](#)Prerequisites
      * The instance meets the following requirements:
      * *   The instance resides in a region other than the China (Zhangjiakou) region.
      * *   The instance runs RDS Basic Edition, RDS Cluster Edition, or RDS High-availability Edition. If your instance runs RDS High-availability Edition, make sure that the instance runs SQL Server 2012 or later.
      * *   The instance belongs to the general-purpose or dedicated instance family. The shared instance family is not supported.
      * *   The instance resides in a virtual private cloud (VPC). For more information about how to change the network type of an RDS instance, see [Change the network type](~~95707~~).
      * *   If the instance runs RDS High-availability Edition or RDS Cluster Edition, the instance is created on or after January 1, 2021. If the instance runs RDS Basic Edition, the instance is created on or after September 02, 2022. You can view the **Creation Time** parameter of an instance in the **Status** section of the **Basic Information** page in the ApsaraDB RDS console.
      * Your **Alibaba Cloud account** is used for logons.
      *
      * @param request DescribeHostWebShellRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeHostWebShellResponse
     */
    async describeHostWebShellWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountName)) {
            query["AccountName"] = request.accountName;
        }
        if (!tea_util_1.default.isUnset(request.accountPassword)) {
            query["AccountPassword"] = request.accountPassword;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.hostName)) {
            query["HostName"] = request.hostName;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionID)) {
            query["RegionID"] = request.regionID;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeHostWebShell",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeHostWebShellResponse({}));
    }
    /**
      * >  This operation is available only for instances that run SQL Server. If you require this operation, contact **Alibaba Cloud technical support**.
      * ### [](#)Prerequisites
      * The instance meets the following requirements:
      * *   The instance resides in a region other than the China (Zhangjiakou) region.
      * *   The instance runs RDS Basic Edition, RDS Cluster Edition, or RDS High-availability Edition. If your instance runs RDS High-availability Edition, make sure that the instance runs SQL Server 2012 or later.
      * *   The instance belongs to the general-purpose or dedicated instance family. The shared instance family is not supported.
      * *   The instance resides in a virtual private cloud (VPC). For more information about how to change the network type of an RDS instance, see [Change the network type](~~95707~~).
      * *   If the instance runs RDS High-availability Edition or RDS Cluster Edition, the instance is created on or after January 1, 2021. If the instance runs RDS Basic Edition, the instance is created on or after September 02, 2022. You can view the **Creation Time** parameter of an instance in the **Status** section of the **Basic Information** page in the ApsaraDB RDS console.
      * Your **Alibaba Cloud account** is used for logons.
      *
      * @param request DescribeHostWebShellRequest
      * @return DescribeHostWebShellResponse
     */
    async describeHostWebShell(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeHostWebShellWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeInstanceAutoRenewalAttributeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeInstanceAutoRenewalAttributeResponse
     */
    async describeInstanceAutoRenewalAttributeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.proxyId)) {
            query["proxyId"] = request.proxyId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeInstanceAutoRenewalAttribute",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeInstanceAutoRenewalAttributeResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeInstanceAutoRenewalAttributeRequest
      * @return DescribeInstanceAutoRenewalAttributeResponse
     */
    async describeInstanceAutoRenewalAttribute(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeInstanceAutoRenewalAttributeWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](~~120824~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
      *
      * @param request DescribeInstanceCrossBackupPolicyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeInstanceCrossBackupPolicyResponse
     */
    async describeInstanceCrossBackupPolicyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeInstanceCrossBackupPolicy",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeInstanceCrossBackupPolicyResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for MySQL instance](~~120824~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
      *
      * @param request DescribeInstanceCrossBackupPolicyRequest
      * @return DescribeInstanceCrossBackupPolicyResponse
     */
    async describeInstanceCrossBackupPolicy(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeInstanceCrossBackupPolicyWithOptions(request, runtime);
    }
    async describeInstanceKeywordsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.key)) {
            query["Key"] = request.key;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeInstanceKeywords",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeInstanceKeywordsResponse({}));
    }
    async describeInstanceKeywords(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeInstanceKeywordsWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      *
      * @param request DescribeInstanceLinkedWhitelistTemplateRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeInstanceLinkedWhitelistTemplateResponse
     */
    async describeInstanceLinkedWhitelistTemplateWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.insName)) {
            query["InsName"] = request.insName;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeInstanceLinkedWhitelistTemplate",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeInstanceLinkedWhitelistTemplateResponse({}));
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      *
      * @param request DescribeInstanceLinkedWhitelistTemplateRequest
      * @return DescribeInstanceLinkedWhitelistTemplateResponse
     */
    async describeInstanceLinkedWhitelistTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeInstanceLinkedWhitelistTemplateWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   MariaDB
      *
      * @param request DescribeLocalAvailableRecoveryTimeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeLocalAvailableRecoveryTimeResponse
     */
    async describeLocalAvailableRecoveryTimeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.region)) {
            query["Region"] = request.region;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeLocalAvailableRecoveryTime",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeLocalAvailableRecoveryTimeResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   MariaDB
      *
      * @param request DescribeLocalAvailableRecoveryTimeRequest
      * @return DescribeLocalAvailableRecoveryTimeResponse
     */
    async describeLocalAvailableRecoveryTime(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeLocalAvailableRecoveryTimeWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * SQL Server
      * >  You can call the DescribeBinlogFiles operation to query the log files of instances that run different database engines.
      *
      * @param request DescribeLogBackupFilesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeLogBackupFilesResponse
     */
    async describeLogBackupFilesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeLogBackupFiles",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeLogBackupFilesResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * SQL Server
      * >  You can call the DescribeBinlogFiles operation to query the log files of instances that run different database engines.
      *
      * @param request DescribeLogBackupFilesRequest
      * @return DescribeLogBackupFilesResponse
     */
    async describeLogBackupFiles(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeLogBackupFilesWithOptions(request, runtime);
    }
    async describeMarketingActivityWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.aliUid)) {
            query["AliUid"] = request.aliUid;
        }
        if (!tea_util_1.default.isUnset(request.bid)) {
            query["Bid"] = request.bid;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.upgradeCode)) {
            query["UpgradeCode"] = request.upgradeCode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeMarketingActivity",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeMarketingActivityResponse({}));
    }
    async describeMarketingActivity(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeMarketingActivityWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * MySQL
      * > This operation is available for RDS instances that run MySQL 8.0, MySQL 5.7, and MySQL 5.6 on RDS High-availability Edition with local disks.
      * ### [](#)Description
      * Before you call the [RestoreTable](~~131510~~) operation to restore individual databases or tables of an ApsaraDB RDS for MySQL instance, you can call this operation to query the information about the databases and tables that can be restored. For more information, see [Restore individual databases and tables of an ApsaraDB RDS for MySQL instance](~~103175~~).
      *
      * @param request DescribeMetaListRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeMetaListResponse
     */
    async describeMetaListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupSetID)) {
            query["BackupSetID"] = request.backupSetID;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.getDbName)) {
            query["GetDbName"] = request.getDbName;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageIndex)) {
            query["PageIndex"] = request.pageIndex;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.pattern)) {
            query["Pattern"] = request.pattern;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.restoreTime)) {
            query["RestoreTime"] = request.restoreTime;
        }
        if (!tea_util_1.default.isUnset(request.restoreType)) {
            query["RestoreType"] = request.restoreType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeMetaList",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeMetaListResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * MySQL
      * > This operation is available for RDS instances that run MySQL 8.0, MySQL 5.7, and MySQL 5.6 on RDS High-availability Edition with local disks.
      * ### [](#)Description
      * Before you call the [RestoreTable](~~131510~~) operation to restore individual databases or tables of an ApsaraDB RDS for MySQL instance, you can call this operation to query the information about the databases and tables that can be restored. For more information, see [Restore individual databases and tables of an ApsaraDB RDS for MySQL instance](~~103175~~).
      *
      * @param request DescribeMetaListRequest
      * @return DescribeMetaListResponse
     */
    async describeMetaList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeMetaListWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   SQL Server
      *
      * @param request DescribeMigrateTaskByIdRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeMigrateTaskByIdResponse
     */
    async describeMigrateTaskByIdWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.migrateTaskId)) {
            query["MigrateTaskId"] = request.migrateTaskId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeMigrateTaskById",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeMigrateTaskByIdResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   SQL Server
      *
      * @param request DescribeMigrateTaskByIdRequest
      * @return DescribeMigrateTaskByIdResponse
     */
    async describeMigrateTaskById(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeMigrateTaskByIdWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engine
      * *   SQL Server
      * ### [](#)Usage notes
      * This operation allows you to query the migration tasks that are created for the instance over the last week.
      * ### [](#)Precautions
      * *   This operation is supported only for migration tasks that are created to migrate full backup files.
      * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition.
      *
      * @param request DescribeMigrateTasksRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeMigrateTasksResponse
     */
    async describeMigrateTasksWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeMigrateTasks",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeMigrateTasksResponse({}));
    }
    /**
      * ### [](#)Supported database engine
      * *   SQL Server
      * ### [](#)Usage notes
      * This operation allows you to query the migration tasks that are created for the instance over the last week.
      * ### [](#)Precautions
      * *   This operation is supported only for migration tasks that are created to migrate full backup files.
      * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition.
      *
      * @param request DescribeMigrateTasksRequest
      * @return DescribeMigrateTasksResponse
     */
    async describeMigrateTasks(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeMigrateTasksWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * RDS PostgreSQL
      *
      * @param request DescribeModifyPGHbaConfigLogRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeModifyPGHbaConfigLogResponse
     */
    async describeModifyPGHbaConfigLogWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeModifyPGHbaConfigLog",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeModifyPGHbaConfigLogResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * RDS PostgreSQL
      *
      * @param request DescribeModifyPGHbaConfigLogRequest
      * @return DescribeModifyPGHbaConfigLogResponse
     */
    async describeModifyPGHbaConfigLog(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeModifyPGHbaConfigLogWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeModifyParameterLogRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeModifyParameterLogResponse
     */
    async describeModifyParameterLogWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeModifyParameterLog",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeModifyParameterLogResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeModifyParameterLogRequest
      * @return DescribeModifyParameterLogResponse
     */
    async describeModifyParameterLog(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeModifyParameterLogWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   SQL Server
      * ### [Usage notes](#)
      * This operation is not supported for instances that run SQL Server 2017 EE or SQL Server 2019 EE.
      *
      * @param request DescribeOssDownloadsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeOssDownloadsResponse
     */
    async describeOssDownloadsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.migrateTaskId)) {
            query["MigrateTaskId"] = request.migrateTaskId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeOssDownloads",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeOssDownloadsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   SQL Server
      * ### [Usage notes](#)
      * This operation is not supported for instances that run SQL Server 2017 EE or SQL Server 2019 EE.
      *
      * @param request DescribeOssDownloadsRequest
      * @return DescribeOssDownloadsResponse
     */
    async describeOssDownloads(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeOssDownloadsWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * RDS PostgreSQL
      *
      * @param request DescribePGHbaConfigRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribePGHbaConfigResponse
     */
    async describePGHbaConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribePGHbaConfig",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribePGHbaConfigResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * RDS PostgreSQL
      *
      * @param request DescribePGHbaConfigRequest
      * @return DescribePGHbaConfigResponse
     */
    async describePGHbaConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describePGHbaConfigWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use a parameter template for an ApsaraDB RDS for MySQL instance](~~130565~~)
      * *   [Use a parameter template for an ApsaraDB RDS for PostgreSQL instance](~~457176~~)
      *
      * @param request DescribeParameterGroupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeParameterGroupResponse
     */
    async describeParameterGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.parameterGroupId)) {
            query["ParameterGroupId"] = request.parameterGroupId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeParameterGroup",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeParameterGroupResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use a parameter template for an ApsaraDB RDS for MySQL instance](~~130565~~)
      * *   [Use a parameter template for an ApsaraDB RDS for PostgreSQL instance](~~457176~~)
      *
      * @param request DescribeParameterGroupRequest
      * @return DescribeParameterGroupResponse
     */
    async describeParameterGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeParameterGroupWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
      *
      * @param request DescribeParameterGroupsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeParameterGroupsResponse
     */
    async describeParameterGroupsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeParameterGroups",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeParameterGroupsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
      *
      * @param request DescribeParameterGroupsRequest
      * @return DescribeParameterGroupsResponse
     */
    async describeParameterGroups(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeParameterGroupsWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeParameterTemplatesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeParameterTemplatesResponse
     */
    async describeParameterTemplatesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.category)) {
            query["Category"] = request.category;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeParameterTemplates",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeParameterTemplatesResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeParameterTemplatesRequest
      * @return DescribeParameterTemplatesResponse
     */
    async describeParameterTemplates(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeParameterTemplatesWithOptions(request, runtime);
    }
    /**
      * ### Applicable engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeParametersRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeParametersResponse
     */
    async describeParametersWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeParameters",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeParametersResponse({}));
    }
    /**
      * ### Applicable engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeParametersRequest
      * @return DescribeParametersResponse
     */
    async describeParameters(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeParametersWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * RDS PostgreSQL
      * ### References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Manage extensions](~~2402409~~)
      *
      * @param request DescribePostgresExtensionsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribePostgresExtensionsResponse
     */
    async describePostgresExtensionsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribePostgresExtensions",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribePostgresExtensionsResponse({}));
    }
    /**
      * ### Supported database engines
      * RDS PostgreSQL
      * ### References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Manage extensions](~~2402409~~)
      *
      * @param request DescribePostgresExtensionsRequest
      * @return DescribePostgresExtensionsResponse
     */
    async describePostgresExtensions(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describePostgresExtensionsWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param tmpReq DescribePriceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribePriceResponse
     */
    async describePriceWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new DescribePriceShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.DBNode)) {
            request.DBNodeShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.DBNode, "DBNode", "json");
        }
        if (!tea_util_1.default.isUnset(tmpReq.serverlessConfig)) {
            request.serverlessConfigShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.serverlessConfig, "ServerlessConfig", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.commodityCode)) {
            query["CommodityCode"] = request.commodityCode;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceClass)) {
            query["DBInstanceClass"] = request.DBInstanceClass;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorage)) {
            query["DBInstanceStorage"] = request.DBInstanceStorage;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorageType)) {
            query["DBInstanceStorageType"] = request.DBInstanceStorageType;
        }
        if (!tea_util_1.default.isUnset(request.DBNodeShrink)) {
            query["DBNode"] = request.DBNodeShrink;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.instanceUsedType)) {
            query["InstanceUsedType"] = request.instanceUsedType;
        }
        if (!tea_util_1.default.isUnset(request.orderType)) {
            query["OrderType"] = request.orderType;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.payType)) {
            query["PayType"] = request.payType;
        }
        if (!tea_util_1.default.isUnset(request.quantity)) {
            query["Quantity"] = request.quantity;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.serverlessConfigShrink)) {
            query["ServerlessConfig"] = request.serverlessConfigShrink;
        }
        if (!tea_util_1.default.isUnset(request.timeType)) {
            query["TimeType"] = request.timeType;
        }
        if (!tea_util_1.default.isUnset(request.usedTime)) {
            query["UsedTime"] = request.usedTime;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribePrice",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribePriceResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribePriceRequest
      * @return DescribePriceResponse
     */
    async describePrice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describePriceWithOptions(request, runtime);
    }
    async describeQuickSaleConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.commodity)) {
            query["Commodity"] = request.commodity;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeQuickSaleConfig",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeQuickSaleConfigResponse({}));
    }
    async describeQuickSaleConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeQuickSaleConfigWithOptions(request, runtime);
    }
    /**
      * @deprecated
      *
      * @param request DescribeRdsResourceSettingsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeRdsResourceSettingsResponse
     */
    // Deprecated
    async describeRdsResourceSettingsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceNiche)) {
            query["ResourceNiche"] = request.resourceNiche;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeRdsResourceSettings",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeRdsResourceSettingsResponse({}));
    }
    /**
      * @deprecated
      *
      * @param request DescribeRdsResourceSettingsRequest
      * @return DescribeRdsResourceSettingsResponse
     */
    // Deprecated
    async describeRdsResourceSettings(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeRdsResourceSettingsWithOptions(request, runtime);
    }
    /**
      * Before you call this operation, make sure that the following requirements are met:
      * *   The primary instance must run the MySQL or PostgreSQL database engine.
      * *   The primary instance must be attached with a read-only instance.
      *
      * @param request DescribeReadDBInstanceDelayRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeReadDBInstanceDelayResponse
     */
    async describeReadDBInstanceDelayWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.readInstanceId)) {
            query["ReadInstanceId"] = request.readInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeReadDBInstanceDelay",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeReadDBInstanceDelayResponse({}));
    }
    /**
      * Before you call this operation, make sure that the following requirements are met:
      * *   The primary instance must run the MySQL or PostgreSQL database engine.
      * *   The primary instance must be attached with a read-only instance.
      *
      * @param request DescribeReadDBInstanceDelayRequest
      * @return DescribeReadDBInstanceDelayResponse
     */
    async describeReadDBInstanceDelay(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeReadDBInstanceDelayWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeRegionInfosRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeRegionInfosResponse
     */
    async describeRegionInfosWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeRegionInfos",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeRegionInfosResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeRegionInfosRequest
      * @return DescribeRegionInfosResponse
     */
    async describeRegionInfos(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeRegionInfosWithOptions(request, runtime);
    }
    /**
      * Before you call the [CreateDBInstance](~~26228~~) operation to create an RDS instance, you can call the DescribeRegions operation to query the available regions and zones.
      * >  If a zone supports the multi-zone deployment method, the value of the ZoneId parameter for the zone contains an MAZ part. Examples: cn-hangzhou-MAZ6(b,f) and cn-hangzhou-MAZ5(b,e,f).
      *
      * @param request DescribeRegionsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeRegionsResponse
     */
    async describeRegionsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.acceptLanguage)) {
            query["AcceptLanguage"] = request.acceptLanguage;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeRegions",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeRegionsResponse({}));
    }
    /**
      * Before you call the [CreateDBInstance](~~26228~~) operation to create an RDS instance, you can call the DescribeRegions operation to query the available regions and zones.
      * >  If a zone supports the multi-zone deployment method, the value of the ZoneId parameter for the zone contains an MAZ part. Examples: cn-hangzhou-MAZ6(b,f) and cn-hangzhou-MAZ5(b,e,f).
      *
      * @param request DescribeRegionsRequest
      * @return DescribeRegionsResponse
     */
    async describeRegions(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeRegionsWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeRenewalPriceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeRenewalPriceResponse
     */
    async describeRenewalPriceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.businessInfo)) {
            query["BusinessInfo"] = request.businessInfo;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceClass)) {
            query["DBInstanceClass"] = request.DBInstanceClass;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.orderType)) {
            query["OrderType"] = request.orderType;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.payType)) {
            query["PayType"] = request.payType;
        }
        if (!tea_util_1.default.isUnset(request.quantity)) {
            query["Quantity"] = request.quantity;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.timeType)) {
            query["TimeType"] = request.timeType;
        }
        if (!tea_util_1.default.isUnset(request.usedTime)) {
            query["UsedTime"] = request.usedTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeRenewalPrice",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeRenewalPriceResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeRenewalPriceRequest
      * @return DescribeRenewalPriceResponse
     */
    async describeRenewalPrice(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeRenewalPriceWithOptions(request, runtime);
    }
    async describeResourceDetailsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeResourceDetails",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeResourceDetailsResponse({}));
    }
    async describeResourceDetails(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeResourceDetailsWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeResourceUsageRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeResourceUsageResponse
     */
    async describeResourceUsageWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeResourceUsage",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeResourceUsageResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeResourceUsageRequest
      * @return DescribeResourceUsageResponse
     */
    async describeResourceUsage(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeResourceUsageWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      *
      * @param request DescribeSQLCollectorPolicyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeSQLCollectorPolicyResponse
     */
    async describeSQLCollectorPolicyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSQLCollectorPolicy",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSQLCollectorPolicyResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      *
      * @param request DescribeSQLCollectorPolicyRequest
      * @return DescribeSQLCollectorPolicyResponse
     */
    async describeSQLCollectorPolicy(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSQLCollectorPolicyWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      *
      * @param request DescribeSQLCollectorRetentionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeSQLCollectorRetentionResponse
     */
    async describeSQLCollectorRetentionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSQLCollectorRetention",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSQLCollectorRetentionResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      *
      * @param request DescribeSQLCollectorRetentionRequest
      * @return DescribeSQLCollectorRetentionResponse
     */
    async describeSQLCollectorRetention(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSQLCollectorRetentionWithOptions(request, runtime);
    }
    /**
      * Before you call this operation, make sure that the instance runs one of the following database engines:
      * *   MySQL
      * *   SQL Server 2008 R2
      * *   PostgreSQL
      * >
      * *   The DescribeSQLLogFiles operation cannot be called to query the log files that are generated by SQL Explorer Trial Edition for an ApsaraDB RDS for MySQL instance.
      * *   The DescribeSQLLogFiles operation cannot be called to query the log files that are generated by the SQL Explorer feature and manually exported from the ApsaraDB RDS console. The DescribeSQLLogFiles operation can be called to query the SQL Explorer log files that are generated by calling the [DescribeSQLLogRecords](~~610533~~) operation with the request parameter **Form** set to **File**.
      *
      * @param request DescribeSQLLogFilesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeSQLLogFilesResponse
     */
    async describeSQLLogFilesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.fileName)) {
            query["FileName"] = request.fileName;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSQLLogFiles",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSQLLogFilesResponse({}));
    }
    /**
      * Before you call this operation, make sure that the instance runs one of the following database engines:
      * *   MySQL
      * *   SQL Server 2008 R2
      * *   PostgreSQL
      * >
      * *   The DescribeSQLLogFiles operation cannot be called to query the log files that are generated by SQL Explorer Trial Edition for an ApsaraDB RDS for MySQL instance.
      * *   The DescribeSQLLogFiles operation cannot be called to query the log files that are generated by the SQL Explorer feature and manually exported from the ApsaraDB RDS console. The DescribeSQLLogFiles operation can be called to query the SQL Explorer log files that are generated by calling the [DescribeSQLLogRecords](~~610533~~) operation with the request parameter **Form** set to **File**.
      *
      * @param request DescribeSQLLogFilesRequest
      * @return DescribeSQLLogFilesResponse
     */
    async describeSQLLogFiles(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSQLLogFilesWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [Usage notes](#)
      * *   You can call this operation up to 1,000 times per minute per account. The calls initiated by using both your Alibaba Cloud account and RAM users within your Alibaba Cloud account are counted.
      * *   This operation cannot be used to query the logs that are generated by SQL Explorer Trial Edition for an ApsaraDB RDS for MySQL instance.
      * *   When you call this operation and set the **Form** parameter to **File** to generate an audit file, a maximum of 1 million log entries can be recorded in the audit file, and you cannot filter log entries by keyword.
      *
      * @param request DescribeSQLLogRecordsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeSQLLogRecordsResponse
     */
    async describeSQLLogRecordsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.database)) {
            query["Database"] = request.database;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.form)) {
            query["Form"] = request.form;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.queryKeywords)) {
            query["QueryKeywords"] = request.queryKeywords;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.SQLId)) {
            query["SQLId"] = request.SQLId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.user)) {
            query["User"] = request.user;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSQLLogRecords",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSQLLogRecordsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [Usage notes](#)
      * *   You can call this operation up to 1,000 times per minute per account. The calls initiated by using both your Alibaba Cloud account and RAM users within your Alibaba Cloud account are counted.
      * *   This operation cannot be used to query the logs that are generated by SQL Explorer Trial Edition for an ApsaraDB RDS for MySQL instance.
      * *   When you call this operation and set the **Form** parameter to **File** to generate an audit file, a maximum of 1 million log entries can be recorded in the audit file, and you cannot filter log entries by keyword.
      *
      * @param request DescribeSQLLogRecordsRequest
      * @return DescribeSQLLogRecordsResponse
     */
    async describeSQLLogRecords(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSQLLogRecordsWithOptions(request, runtime);
    }
    async describeSQLLogReportListWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSQLLogReportList",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSQLLogReportListResponse({}));
    }
    async describeSQLLogReportList(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSQLLogReportListWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engine
      * *   MySQL
      *
      * @param request DescribeSecretsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeSecretsResponse
     */
    async describeSecretsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.acceptLanguage)) {
            query["AcceptLanguage"] = request.acceptLanguage;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.dbInstanceId)) {
            query["DbInstanceId"] = request.dbInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.engine)) {
            query["Engine"] = request.engine;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSecrets",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSecretsResponse({}));
    }
    /**
      * ### [](#)Supported database engine
      * *   MySQL
      *
      * @param request DescribeSecretsRequest
      * @return DescribeSecretsResponse
     */
    async describeSecrets(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSecretsWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Configure a security group for an ApsaraDB RDS for MySQL instance](~~201042~~)
      * *   [Configure a security group for an ApsaraDB RDS for PostgreSQL instance](~~206310~~)
      * *   [Configure a security group for an ApsaraDB RDS for SQL Server instance](~~2392322~~)
      *
      * @param request DescribeSecurityGroupConfigurationRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeSecurityGroupConfigurationResponse
     */
    async describeSecurityGroupConfigurationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSecurityGroupConfiguration",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSecurityGroupConfigurationResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Configure a security group for an ApsaraDB RDS for MySQL instance](~~201042~~)
      * *   [Configure a security group for an ApsaraDB RDS for PostgreSQL instance](~~206310~~)
      * *   [Configure a security group for an ApsaraDB RDS for SQL Server instance](~~2392322~~)
      *
      * @param request DescribeSecurityGroupConfigurationRequest
      * @return DescribeSecurityGroupConfigurationResponse
     */
    async describeSecurityGroupConfiguration(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSecurityGroupConfigurationWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      *
      * @param request DescribeSlotsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeSlotsResponse
     */
    async describeSlotsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSlots",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSlotsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      *
      * @param request DescribeSlotsRequest
      * @return DescribeSlotsResponse
     */
    async describeSlots(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSlotsWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### Precautions
      * The response parameters returned by this operation are updated every minute.
      *
      * @param request DescribeSlowLogRecordsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeSlowLogRecordsResponse
     */
    async describeSlowLogRecordsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.nodeId)) {
            query["NodeId"] = request.nodeId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.SQLHASH)) {
            query["SQLHASH"] = request.SQLHASH;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSlowLogRecords",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSlowLogRecordsResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### Precautions
      * The response parameters returned by this operation are updated every minute.
      *
      * @param request DescribeSlowLogRecordsRequest
      * @return DescribeSlowLogRecordsResponse
     */
    async describeSlowLogRecords(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSlowLogRecordsWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      *     **
      *     **Note**MySQL 5.7 on RDS Basic Edition is not supported.
      * *   SQL Server
      *     **
      *     **Note**Only SQL Server 2008 R2 is supported.
      * *   MariaDB
      * ### Usage notes
      * Slow query logs are not collected in real time and may show a latency of 6 hours to 8 hours.
      *
      * @param request DescribeSlowLogsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeSlowLogsResponse
     */
    async describeSlowLogsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.sortKey)) {
            query["SortKey"] = request.sortKey;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSlowLogs",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSlowLogsResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      *     **
      *     **Note**MySQL 5.7 on RDS Basic Edition is not supported.
      * *   SQL Server
      *     **
      *     **Note**Only SQL Server 2008 R2 is supported.
      * *   MariaDB
      * ### Usage notes
      * Slow query logs are not collected in real time and may show a latency of 6 hours to 8 hours.
      *
      * @param request DescribeSlowLogsRequest
      * @return DescribeSlowLogsResponse
     */
    async describeSlowLogs(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSlowLogsWithOptions(request, runtime);
    }
    /**
      * ### Supported database engine
      * SQL Server
      *
      * @param request DescribeSupportOnlineResizeDiskRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeSupportOnlineResizeDiskResponse
     */
    async describeSupportOnlineResizeDiskWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeSupportOnlineResizeDisk",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeSupportOnlineResizeDiskResponse({}));
    }
    /**
      * ### Supported database engine
      * SQL Server
      *
      * @param request DescribeSupportOnlineResizeDiskRequest
      * @return DescribeSupportOnlineResizeDiskResponse
     */
    async describeSupportOnlineResizeDisk(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeSupportOnlineResizeDiskWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [Usage notes](#)
      * *   If an instance ID is specified, all tags that are added to this instance are queried, and other filter conditions are invalid.
      * *   If you specify only TagKey, the results that match the specified TagKey are returned. If you specify both TagKey and TagValue, the results that match both the specified TagKey and TagValue are returned.
      *
      * @param request DescribeTagsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeTagsResponse
     */
    async describeTagsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            query["Tags"] = request.tags;
        }
        if (!tea_util_1.default.isUnset(request.proxyId)) {
            query["proxyId"] = request.proxyId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeTags",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeTagsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [Usage notes](#)
      * *   If an instance ID is specified, all tags that are added to this instance are queried, and other filter conditions are invalid.
      * *   If you specify only TagKey, the results that match the specified TagKey are returned. If you specify both TagKey and TagValue, the results that match both the specified TagKey and TagValue are returned.
      *
      * @param request DescribeTagsRequest
      * @return DescribeTagsResponse
     */
    async describeTags(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeTagsWithOptions(request, runtime);
    }
    /**
      * This operation is phased out.
      *
      * @param request DescribeTasksRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeTasksResponse
     */
    async describeTasksWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["EndTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["StartTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            query["Status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.taskAction)) {
            query["TaskAction"] = request.taskAction;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeTasks",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeTasksResponse({}));
    }
    /**
      * This operation is phased out.
      *
      * @param request DescribeTasksRequest
      * @return DescribeTasksResponse
     */
    async describeTasks(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeTasksWithOptions(request, runtime);
    }
    /**
      * Before you upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance, you must perform an upgrade check and make sure that the check result is **Success**. You can call this operation to query the upgrade check report.
      * If the check result is **Fail**, you must handle the errors that occurred. For more information about how to handle common errors, see [Introduction to the check report for a major engine version upgrade to an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/apsaradb-for-rds/latest/introduction-to-the-check-report-of-a-major-engine-version-upgrade-for-an-apsaradb-rds-for-postgresql-instance).
      *
      * @param request DescribeUpgradeMajorVersionPrecheckTaskRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeUpgradeMajorVersionPrecheckTaskResponse
     */
    async describeUpgradeMajorVersionPrecheckTaskWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.targetMajorVersion)) {
            query["TargetMajorVersion"] = request.targetMajorVersion;
        }
        if (!tea_util_1.default.isUnset(request.taskId)) {
            query["TaskId"] = request.taskId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeUpgradeMajorVersionPrecheckTask",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeUpgradeMajorVersionPrecheckTaskResponse({}));
    }
    /**
      * Before you upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance, you must perform an upgrade check and make sure that the check result is **Success**. You can call this operation to query the upgrade check report.
      * If the check result is **Fail**, you must handle the errors that occurred. For more information about how to handle common errors, see [Introduction to the check report for a major engine version upgrade to an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/apsaradb-for-rds/latest/introduction-to-the-check-report-of-a-major-engine-version-upgrade-for-an-apsaradb-rds-for-postgresql-instance).
      *
      * @param request DescribeUpgradeMajorVersionPrecheckTaskRequest
      * @return DescribeUpgradeMajorVersionPrecheckTaskResponse
     */
    async describeUpgradeMajorVersionPrecheckTask(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeUpgradeMajorVersionPrecheckTaskWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * PostgreSQL
      *
      * @param request DescribeUpgradeMajorVersionTasksRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeUpgradeMajorVersionTasksResponse
     */
    async describeUpgradeMajorVersionTasksWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.targetMajorVersion)) {
            query["TargetMajorVersion"] = request.targetMajorVersion;
        }
        if (!tea_util_1.default.isUnset(request.taskId)) {
            query["TaskId"] = request.taskId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeUpgradeMajorVersionTasks",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeUpgradeMajorVersionTasksResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * PostgreSQL
      *
      * @param request DescribeUpgradeMajorVersionTasksRequest
      * @return DescribeUpgradeMajorVersionTasksResponse
     */
    async describeUpgradeMajorVersionTasks(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeUpgradeMajorVersionTasksWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeVSwitchesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeVSwitchesResponse
     */
    async describeVSwitchesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dedicatedHostGroupId)) {
            query["DedicatedHostGroupId"] = request.dedicatedHostGroupId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        if (!tea_util_1.default.isUnset(request.vpcId)) {
            query["VpcId"] = request.vpcId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeVSwitches",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeVSwitchesResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request DescribeVSwitchesRequest
      * @return DescribeVSwitchesResponse
     */
    async describeVSwitches(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeVSwitchesWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      *
      * @param request DescribeWhitelistTemplateRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeWhitelistTemplateResponse
     */
    async describeWhitelistTemplateWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.templateId)) {
            query["TemplateId"] = request.templateId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeWhitelistTemplate",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeWhitelistTemplateResponse({}));
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      *
      * @param request DescribeWhitelistTemplateRequest
      * @return DescribeWhitelistTemplateResponse
     */
    async describeWhitelistTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeWhitelistTemplateWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      *
      * @param request DescribeWhitelistTemplateLinkedInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DescribeWhitelistTemplateLinkedInstanceResponse
     */
    async describeWhitelistTemplateLinkedInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.templateId)) {
            body["TemplateId"] = request.templateId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DescribeWhitelistTemplateLinkedInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeWhitelistTemplateLinkedInstanceResponse({}));
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      *
      * @param request DescribeWhitelistTemplateLinkedInstanceRequest
      * @return DescribeWhitelistTemplateLinkedInstanceResponse
     */
    async describeWhitelistTemplateLinkedInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.describeWhitelistTemplateLinkedInstanceWithOptions(request, runtime);
    }
    /**
      * The DestroyDBInstance operation is phased out.
      *
      * @param request DestroyDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DestroyDBInstanceResponse
     */
    async destroyDBInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DestroyDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DestroyDBInstanceResponse({}));
    }
    /**
      * The DestroyDBInstance operation is phased out.
      *
      * @param request DestroyDBInstanceRequest
      * @return DestroyDBInstanceResponse
     */
    async destroyDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.destroyDBInstanceWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * ### [Usage notes](#)
      * This operation can be used to remove only unit nodes.
      *
      * @param request DetachGadInstanceMemberRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DetachGadInstanceMemberResponse
     */
    async detachGadInstanceMemberWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.gadInstanceName)) {
            query["GadInstanceName"] = request.gadInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.memberInstanceName)) {
            query["MemberInstanceName"] = request.memberInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DetachGadInstanceMember",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DetachGadInstanceMemberResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * ### [Usage notes](#)
      * This operation can be used to remove only unit nodes.
      *
      * @param request DetachGadInstanceMemberRequest
      * @return DetachGadInstanceMemberResponse
     */
    async detachGadInstanceMember(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.detachGadInstanceMemberWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      *
      * @param request DetachWhitelistTemplateToInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return DetachWhitelistTemplateToInstanceResponse
     */
    async detachWhitelistTemplateToInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.insName)) {
            query["InsName"] = request.insName;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.templateId)) {
            query["TemplateId"] = request.templateId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DetachWhitelistTemplateToInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DetachWhitelistTemplateToInstanceResponse({}));
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      *
      * @param request DetachWhitelistTemplateToInstanceRequest
      * @return DetachWhitelistTemplateToInstanceResponse
     */
    async detachWhitelistTemplateToInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.detachWhitelistTemplateToInstanceWithOptions(request, runtime);
    }
    async evaluateLocalExtendDiskWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceName)) {
            query["DBInstanceName"] = request.DBInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.storage)) {
            query["Storage"] = request.storage;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "EvaluateLocalExtendDisk",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new EvaluateLocalExtendDiskResponse({}));
    }
    async evaluateLocalExtendDisk(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.evaluateLocalExtendDiskWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request GetDBInstanceTopologyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetDBInstanceTopologyResponse
     */
    async getDBInstanceTopologyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetDBInstanceTopology",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetDBInstanceTopologyResponse({}));
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request GetDBInstanceTopologyRequest
      * @return GetDBInstanceTopologyResponse
     */
    async getDBInstanceTopology(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getDBInstanceTopologyWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * RDS MySQL
      *
      * @param request GetDbProxyInstanceSslRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GetDbProxyInstanceSslResponse
     */
    async getDbProxyInstanceSslWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBProxyEngineType)) {
            query["DBProxyEngineType"] = request.DBProxyEngineType;
        }
        if (!tea_util_1.default.isUnset(request.dbInstanceId)) {
            query["DbInstanceId"] = request.dbInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.dbInstanceId)) {
            query["DbInstanceId"] = request.dbInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetDbProxyInstanceSsl",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetDbProxyInstanceSslResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * RDS MySQL
      *
      * @param request GetDbProxyInstanceSslRequest
      * @return GetDbProxyInstanceSslResponse
     */
    async getDbProxyInstanceSsl(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.getDbProxyInstanceSslWithOptions(request, runtime);
    }
    /**
      * Each account can be granted permissions on one or more databases. Before you call this operation, make sure that the instance is in the Running state.
      * > This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition or run PostgreSQL with local disks.
      *
      * @param request GrantAccountPrivilegeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GrantAccountPrivilegeResponse
     */
    async grantAccountPrivilegeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountName)) {
            query["AccountName"] = request.accountName;
        }
        if (!tea_util_1.default.isUnset(request.accountPrivilege)) {
            query["AccountPrivilege"] = request.accountPrivilege;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GrantAccountPrivilege",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GrantAccountPrivilegeResponse({}));
    }
    /**
      * Each account can be granted permissions on one or more databases. Before you call this operation, make sure that the instance is in the Running state.
      * > This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition or run PostgreSQL with local disks.
      *
      * @param request GrantAccountPrivilegeRequest
      * @return GrantAccountPrivilegeResponse
     */
    async grantAccountPrivilege(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.grantAccountPrivilegeWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Grant permissions to the service account of an ApsaraDB RDS for MySQL instance](~~96102~~)
      * *   [Grant permissions to the service account of an ApsaraDB RDS for SQL Server instance](~~95693~~)
      *
      * @param request GrantOperatorPermissionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return GrantOperatorPermissionResponse
     */
    async grantOperatorPermissionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.expiredTime)) {
            query["ExpiredTime"] = request.expiredTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.privileges)) {
            query["Privileges"] = request.privileges;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GrantOperatorPermission",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GrantOperatorPermissionResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Grant permissions to the service account of an ApsaraDB RDS for MySQL instance](~~96102~~)
      * *   [Grant permissions to the service account of an ApsaraDB RDS for SQL Server instance](~~95693~~)
      *
      * @param request GrantOperatorPermissionRequest
      * @return GrantOperatorPermissionResponse
     */
    async grantOperatorPermission(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.grantOperatorPermissionWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engine
      * *   SQL Server
      * ### [](#)Description
      * We recommend that you use Data Transmission Service (DTS). DTS provides data migration, subscription, and synchronization features that allow you to establish stable, secure transmission links. For more information, see [DTS API overview](~~49456~~).
      * ### [](#)Precautions
      * *   During the migration, the source instance is in the **Migrating** state, and the destination instance is in the **Importing** state.
      * *   Before you call this operation, make sure that the following requirements are met:
      *     *   The source and destination instances must run SQL Server and belong to the dedicated or dedicated host instance family. For more information about the supported instance types, see [Primary instance types](~~26312~~).
      *     *   The source and destination instances must be created by using the same user credentials.
      *     *   The instance is in the Running state.
      *     *   The source and destination databases must be in the Running state.
      *     *   The remaining storage of the destination instance must be greater than the storage capacity of the source instance.
      * >
      * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition.
      * *   You can migrate the data of multiple databases at a time.
      *
      * @param request ImportDatabaseBetweenInstancesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ImportDatabaseBetweenInstancesResponse
     */
    async importDatabaseBetweenInstancesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInfo)) {
            query["DBInfo"] = request.DBInfo;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.sourceDBInstanceId)) {
            query["SourceDBInstanceId"] = request.sourceDBInstanceId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ImportDatabaseBetweenInstances",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ImportDatabaseBetweenInstancesResponse({}));
    }
    /**
      * ### [](#)Supported database engine
      * *   SQL Server
      * ### [](#)Description
      * We recommend that you use Data Transmission Service (DTS). DTS provides data migration, subscription, and synchronization features that allow you to establish stable, secure transmission links. For more information, see [DTS API overview](~~49456~~).
      * ### [](#)Precautions
      * *   During the migration, the source instance is in the **Migrating** state, and the destination instance is in the **Importing** state.
      * *   Before you call this operation, make sure that the following requirements are met:
      *     *   The source and destination instances must run SQL Server and belong to the dedicated or dedicated host instance family. For more information about the supported instance types, see [Primary instance types](~~26312~~).
      *     *   The source and destination instances must be created by using the same user credentials.
      *     *   The instance is in the Running state.
      *     *   The source and destination databases must be in the Running state.
      *     *   The remaining storage of the destination instance must be greater than the storage capacity of the source instance.
      * >
      * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition.
      * *   You can migrate the data of multiple databases at a time.
      *
      * @param request ImportDatabaseBetweenInstancesRequest
      * @return ImportDatabaseBetweenInstancesResponse
     */
    async importDatabaseBetweenInstances(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.importDatabaseBetweenInstancesWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * ### [](#)Description
      * A full backup file contains the data of a self-managed MySQL instance. You can restore the data of a self-managed MySQL instance from a full backup file to an ApsaraDB RDS for MySQL instance.
      * ### [](#)Usage notes
      * Before you call this operation, make sure that the following requirements are met:
      * *   The self-managed MySQL instance runs MySQL 5.7 and is backed up by using XtraBackup. The name of the backup file ends with `_qp.xb`. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
      * *   The full backup file of the self-managed MySQL instance is uploaded to an Object Storage Service (OSS) bucket in the region of the ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
      * >  This operation is supported only for MySQL 5.7.
      *
      * @param request ImportUserBackupFileRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ImportUserBackupFileResponse
     */
    async importUserBackupFileWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupFile)) {
            query["BackupFile"] = request.backupFile;
        }
        if (!tea_util_1.default.isUnset(request.bucketRegion)) {
            query["BucketRegion"] = request.bucketRegion;
        }
        if (!tea_util_1.default.isUnset(request.comment)) {
            query["Comment"] = request.comment;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.restoreSize)) {
            query["RestoreSize"] = request.restoreSize;
        }
        if (!tea_util_1.default.isUnset(request.retention)) {
            query["Retention"] = request.retention;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ImportUserBackupFile",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ImportUserBackupFileResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * ### [](#)Description
      * A full backup file contains the data of a self-managed MySQL instance. You can restore the data of a self-managed MySQL instance from a full backup file to an ApsaraDB RDS for MySQL instance.
      * ### [](#)Usage notes
      * Before you call this operation, make sure that the following requirements are met:
      * *   The self-managed MySQL instance runs MySQL 5.7 and is backed up by using XtraBackup. The name of the backup file ends with `_qp.xb`. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
      * *   The full backup file of the self-managed MySQL instance is uploaded to an Object Storage Service (OSS) bucket in the region of the ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
      * >  This operation is supported only for MySQL 5.7.
      *
      * @param request ImportUserBackupFileRequest
      * @return ImportUserBackupFileResponse
     */
    async importUserBackupFile(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.importUserBackupFileWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request ListClassesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListClassesResponse
     */
    async listClassesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.commodityCode)) {
            query["CommodityCode"] = request.commodityCode;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.orderType)) {
            query["OrderType"] = request.orderType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListClasses",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListClassesResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request ListClassesRequest
      * @return ListClassesResponse
     */
    async listClasses(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listClassesWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request ListTagResourcesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListTagResourcesResponse
     */
    async listTagResourcesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceId)) {
            query["ResourceId"] = request.resourceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.tag)) {
            query["Tag"] = request.tag;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListTagResources",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListTagResourcesResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      *
      * @param request ListTagResourcesRequest
      * @return ListTagResourcesResponse
     */
    async listTagResources(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listTagResourcesWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * ### [](#)Feature description
      * *   A full backup file contains the data of a self-managed MySQL database. You can restore the data of a self-managed MySQL database from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
      * *   Before you call the [CreateDBInstance](~~26228~~) operation to create an ApsaraDB RDS for MySQL instance into which you want to import full backup files, you can call this operation to query the IDs of full backup files.
      * *   You can call the [ImportUserBackupFile](~~260266~~) operation to import a full backup file into an ApsaraDB RDS for MySQL instance.
      *
      * @param request ListUserBackupFilesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ListUserBackupFilesResponse
     */
    async listUserBackupFilesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupId)) {
            query["BackupId"] = request.backupId;
        }
        if (!tea_util_1.default.isUnset(request.comment)) {
            query["Comment"] = request.comment;
        }
        if (!tea_util_1.default.isUnset(request.ossUrl)) {
            query["OssUrl"] = request.ossUrl;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            query["Status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            query["Tags"] = request.tags;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListUserBackupFiles",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListUserBackupFilesResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * ### [](#)Feature description
      * *   A full backup file contains the data of a self-managed MySQL database. You can restore the data of a self-managed MySQL database from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 instance to the cloud](~~251779~~).
      * *   Before you call the [CreateDBInstance](~~26228~~) operation to create an ApsaraDB RDS for MySQL instance into which you want to import full backup files, you can call this operation to query the IDs of full backup files.
      * *   You can call the [ImportUserBackupFile](~~260266~~) operation to import a full backup file into an ApsaraDB RDS for MySQL instance.
      *
      * @param request ListUserBackupFilesRequest
      * @return ListUserBackupFilesResponse
     */
    async listUserBackupFiles(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.listUserBackupFilesWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Lock an account of an ApsaraDB RDS for PostgreSQL instance](~~147649~~)
      *
      * @param request LockAccountRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return LockAccountResponse
     */
    async lockAccountWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountName)) {
            query["AccountName"] = request.accountName;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "LockAccount",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new LockAccountResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Lock an account of an ApsaraDB RDS for PostgreSQL instance](~~147649~~)
      *
      * @param request LockAccountRequest
      * @return LockAccountResponse
     */
    async lockAccount(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.lockAccountWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Migrate an ApsaraDB RDS for MySQL instance across zones in the same region](~~96746~~)
      * *   [Migrate an ApsaraDB RDS for PostgreSQL instance across zones in the same region](~~96746~~)
      * *   [Migrate an ApsaraDB RDS for SQL Server instance across zones in the same region](~~95658~~)
      *
      * @param request MigrateConnectionToOtherZoneRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return MigrateConnectionToOtherZoneResponse
     */
    async migrateConnectionToOtherZoneWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.connectionString)) {
            query["ConnectionString"] = request.connectionString;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "MigrateConnectionToOtherZone",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new MigrateConnectionToOtherZoneResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Migrate an ApsaraDB RDS for MySQL instance across zones in the same region](~~96746~~)
      * *   [Migrate an ApsaraDB RDS for PostgreSQL instance across zones in the same region](~~96746~~)
      * *   [Migrate an ApsaraDB RDS for SQL Server instance across zones in the same region](~~95658~~)
      *
      * @param request MigrateConnectionToOtherZoneRequest
      * @return MigrateConnectionToOtherZoneResponse
     */
    async migrateConnectionToOtherZone(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.migrateConnectionToOtherZoneWithOptions(request, runtime);
    }
    /**
      * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
      *
      * @param request MigrateDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return MigrateDBInstanceResponse
     */
    async migrateDBInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.dedicatedHostGroupId)) {
            query["DedicatedHostGroupId"] = request.dedicatedHostGroupId;
        }
        if (!tea_util_1.default.isUnset(request.effectiveTime)) {
            query["EffectiveTime"] = request.effectiveTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.specifiedTime)) {
            query["SpecifiedTime"] = request.specifiedTime;
        }
        if (!tea_util_1.default.isUnset(request.targetDedicatedHostIdForMaster)) {
            query["TargetDedicatedHostIdForMaster"] = request.targetDedicatedHostIdForMaster;
        }
        if (!tea_util_1.default.isUnset(request.targetDedicatedHostIdForSlave)) {
            query["TargetDedicatedHostIdForSlave"] = request.targetDedicatedHostIdForSlave;
        }
        if (!tea_util_1.default.isUnset(request.zoneIdForFollower)) {
            query["ZoneIdForFollower"] = request.zoneIdForFollower;
        }
        if (!tea_util_1.default.isUnset(request.zoneIdForLog)) {
            query["ZoneIdForLog"] = request.zoneIdForLog;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "MigrateDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new MigrateDBInstanceResponse({}));
    }
    /**
      * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
      *
      * @param request MigrateDBInstanceRequest
      * @return MigrateDBInstanceResponse
     */
    async migrateDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.migrateDBInstanceWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Change the whitelist mode of an ApsaraDB RDS for MySQL instance to the enhanced whitelist mode](~~96117~~)
      * *   [Change the whitelist mode of an ApsaraDB RDS for PostgreSQL instance to the enhanced whitelist mode](~~96767~~)
      *
      * @param request MigrateSecurityIPModeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return MigrateSecurityIPModeResponse
     */
    async migrateSecurityIPModeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "MigrateSecurityIPMode",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new MigrateSecurityIPModeResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Change the whitelist mode of an ApsaraDB RDS for MySQL instance to the enhanced whitelist mode](~~96117~~)
      * *   [Change the whitelist mode of an ApsaraDB RDS for PostgreSQL instance to the enhanced whitelist mode](~~96767~~)
      *
      * @param request MigrateSecurityIPModeRequest
      * @return MigrateSecurityIPModeResponse
     */
    async migrateSecurityIPMode(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.migrateSecurityIPModeWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Migrate an ApsaraDB RDS for MySQL instance across zones in the same region](~~96053~~)
      * *   [Migrate an ApsaraDB RDS for PostgreSQL instance across zones in the same region](~~96746~~)
      * *   [Migrate an ApsaraDB RDS for SQL Server instance across zones in the same region](~~95658~~)
      *
      * @param request MigrateToOtherZoneRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return MigrateToOtherZoneResponse
     */
    async migrateToOtherZoneWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.category)) {
            query["Category"] = request.category;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceClass)) {
            query["DBInstanceClass"] = request.DBInstanceClass;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorage)) {
            query["DBInstanceStorage"] = request.DBInstanceStorage;
        }
        if (!tea_util_1.default.isUnset(request.effectiveTime)) {
            query["EffectiveTime"] = request.effectiveTime;
        }
        if (!tea_util_1.default.isUnset(request.isModifySpec)) {
            query["IsModifySpec"] = request.isModifySpec;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.switchTime)) {
            query["SwitchTime"] = request.switchTime;
        }
        if (!tea_util_1.default.isUnset(request.VPCId)) {
            query["VPCId"] = request.VPCId;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        if (!tea_util_1.default.isUnset(request.zoneIdSlave1)) {
            query["ZoneIdSlave1"] = request.zoneIdSlave1;
        }
        if (!tea_util_1.default.isUnset(request.zoneIdSlave2)) {
            query["ZoneIdSlave2"] = request.zoneIdSlave2;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "MigrateToOtherZone",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new MigrateToOtherZoneResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Migrate an ApsaraDB RDS for MySQL instance across zones in the same region](~~96053~~)
      * *   [Migrate an ApsaraDB RDS for PostgreSQL instance across zones in the same region](~~96746~~)
      * *   [Migrate an ApsaraDB RDS for SQL Server instance across zones in the same region](~~95658~~)
      *
      * @param request MigrateToOtherZoneRequest
      * @return MigrateToOtherZoneResponse
     */
    async migrateToOtherZone(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.migrateToOtherZoneWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engine
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Connect an RDS instance to a self-managed domain](~~170734~~)
      *
      * @param request ModifyADInfoRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyADInfoResponse
     */
    async modifyADInfoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ADAccountName)) {
            query["ADAccountName"] = request.ADAccountName;
        }
        if (!tea_util_1.default.isUnset(request.ADDNS)) {
            query["ADDNS"] = request.ADDNS;
        }
        if (!tea_util_1.default.isUnset(request.ADPassword)) {
            query["ADPassword"] = request.ADPassword;
        }
        if (!tea_util_1.default.isUnset(request.ADServerIpAddress)) {
            query["ADServerIpAddress"] = request.ADServerIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyADInfo",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyADInfoResponse({}));
    }
    /**
      * ### [](#)Supported database engine
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Connect an RDS instance to a self-managed domain](~~170734~~)
      *
      * @param request ModifyADInfoRequest
      * @return ModifyADInfoResponse
     */
    async modifyADInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyADInfoWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request ModifyAccountDescriptionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyAccountDescriptionResponse
     */
    async modifyAccountDescriptionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountDescription)) {
            query["AccountDescription"] = request.accountDescription;
        }
        if (!tea_util_1.default.isUnset(request.accountName)) {
            query["AccountName"] = request.accountName;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyAccountDescription",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyAccountDescriptionResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request ModifyAccountDescriptionRequest
      * @return ModifyAccountDescriptionResponse
     */
    async modifyAccountDescription(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyAccountDescriptionWithOptions(request, runtime);
    }
    /**
      * The event history feature enables you to view historical events that occurred in a region over a specific time range. These events include instance creation and parameter reconfiguration. For more information, see [Event history](~~129759~~).
      *
      * @param request ModifyActionEventPolicyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyActionEventPolicyResponse
     */
    async modifyActionEventPolicyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.enableEventLog)) {
            query["EnableEventLog"] = request.enableEventLog;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyActionEventPolicy",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyActionEventPolicyResponse({}));
    }
    /**
      * The event history feature enables you to view historical events that occurred in a region over a specific time range. These events include instance creation and parameter reconfiguration. For more information, see [Event history](~~129759~~).
      *
      * @param request ModifyActionEventPolicyRequest
      * @return ModifyActionEventPolicyResponse
     */
    async modifyActionEventPolicy(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyActionEventPolicyWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Scheduled events for ApsaraDB RDS for MySQL instances](~~104183~~)
      * *   [Scheduled events for ApsaraDB RDS for PostgreSQL instances](~~104452~~)
      * *   [Scheduled events for ApsaraDB RDS for SQL Server instances](~~104451~~)
      * *   [Scheduled events for ApsaraDB RDS for MariaDB instances](~~104454~~)
      *
      * @param request ModifyActiveOperationTasksRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyActiveOperationTasksResponse
     */
    async modifyActiveOperationTasksWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ids)) {
            query["Ids"] = request.ids;
        }
        if (!tea_util_1.default.isUnset(request.immediateStart)) {
            query["ImmediateStart"] = request.immediateStart;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        if (!tea_util_1.default.isUnset(request.switchTime)) {
            query["SwitchTime"] = request.switchTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyActiveOperationTasks",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyActiveOperationTasksResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Scheduled events for ApsaraDB RDS for MySQL instances](~~104183~~)
      * *   [Scheduled events for ApsaraDB RDS for PostgreSQL instances](~~104452~~)
      * *   [Scheduled events for ApsaraDB RDS for SQL Server instances](~~104451~~)
      * *   [Scheduled events for ApsaraDB RDS for MariaDB instances](~~104454~~)
      *
      * @param request ModifyActiveOperationTasksRequest
      * @return ModifyActiveOperationTasksResponse
     */
    async modifyActiveOperationTasks(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyActiveOperationTasksWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Configure an automatic backup policy for an ApsaraDB RDS for MySQL instance](~~98818~~)
      * *   [Configure an automatic backup policy for an ApsaraDB RDS for PostgreSQL instance](~~96772~~)
      * *   [Configure an automatic backup policy for an ApsaraDB RDS for SQL Server instance](~~95717~~)
      * *   [Configure an automatic backup policy for an ApsaraDB RDS for MariaDB instance](~~97147~~)
      *
      * @param request ModifyBackupPolicyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyBackupPolicyResponse
     */
    async modifyBackupPolicyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.archiveBackupKeepCount)) {
            query["ArchiveBackupKeepCount"] = request.archiveBackupKeepCount;
        }
        if (!tea_util_1.default.isUnset(request.archiveBackupKeepPolicy)) {
            query["ArchiveBackupKeepPolicy"] = request.archiveBackupKeepPolicy;
        }
        if (!tea_util_1.default.isUnset(request.archiveBackupRetentionPeriod)) {
            query["ArchiveBackupRetentionPeriod"] = request.archiveBackupRetentionPeriod;
        }
        if (!tea_util_1.default.isUnset(request.backupInterval)) {
            query["BackupInterval"] = request.backupInterval;
        }
        if (!tea_util_1.default.isUnset(request.backupLog)) {
            query["BackupLog"] = request.backupLog;
        }
        if (!tea_util_1.default.isUnset(request.backupMethod)) {
            query["BackupMethod"] = request.backupMethod;
        }
        if (!tea_util_1.default.isUnset(request.backupPolicyMode)) {
            query["BackupPolicyMode"] = request.backupPolicyMode;
        }
        if (!tea_util_1.default.isUnset(request.backupPriority)) {
            query["BackupPriority"] = request.backupPriority;
        }
        if (!tea_util_1.default.isUnset(request.backupRetentionPeriod)) {
            query["BackupRetentionPeriod"] = request.backupRetentionPeriod;
        }
        if (!tea_util_1.default.isUnset(request.category)) {
            query["Category"] = request.category;
        }
        if (!tea_util_1.default.isUnset(request.compressType)) {
            query["CompressType"] = request.compressType;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.enableBackupLog)) {
            query["EnableBackupLog"] = request.enableBackupLog;
        }
        if (!tea_util_1.default.isUnset(request.enableIncrementDataBackup)) {
            query["EnableIncrementDataBackup"] = request.enableIncrementDataBackup;
        }
        if (!tea_util_1.default.isUnset(request.highSpaceUsageProtection)) {
            query["HighSpaceUsageProtection"] = request.highSpaceUsageProtection;
        }
        if (!tea_util_1.default.isUnset(request.localLogRetentionHours)) {
            query["LocalLogRetentionHours"] = request.localLogRetentionHours;
        }
        if (!tea_util_1.default.isUnset(request.localLogRetentionSpace)) {
            query["LocalLogRetentionSpace"] = request.localLogRetentionSpace;
        }
        if (!tea_util_1.default.isUnset(request.logBackupFrequency)) {
            query["LogBackupFrequency"] = request.logBackupFrequency;
        }
        if (!tea_util_1.default.isUnset(request.logBackupLocalRetentionNumber)) {
            query["LogBackupLocalRetentionNumber"] = request.logBackupLocalRetentionNumber;
        }
        if (!tea_util_1.default.isUnset(request.logBackupRetentionPeriod)) {
            query["LogBackupRetentionPeriod"] = request.logBackupRetentionPeriod;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.preferredBackupPeriod)) {
            query["PreferredBackupPeriod"] = request.preferredBackupPeriod;
        }
        if (!tea_util_1.default.isUnset(request.preferredBackupTime)) {
            query["PreferredBackupTime"] = request.preferredBackupTime;
        }
        if (!tea_util_1.default.isUnset(request.releasedKeepPolicy)) {
            query["ReleasedKeepPolicy"] = request.releasedKeepPolicy;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyBackupPolicy",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyBackupPolicyResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Configure an automatic backup policy for an ApsaraDB RDS for MySQL instance](~~98818~~)
      * *   [Configure an automatic backup policy for an ApsaraDB RDS for PostgreSQL instance](~~96772~~)
      * *   [Configure an automatic backup policy for an ApsaraDB RDS for SQL Server instance](~~95717~~)
      * *   [Configure an automatic backup policy for an ApsaraDB RDS for MariaDB instance](~~97147~~)
      *
      * @param request ModifyBackupPolicyRequest
      * @return ModifyBackupPolicyResponse
     */
    async modifyBackupPolicy(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyBackupPolicyWithOptions(request, runtime);
    }
    /**
      * > This operation is phased out.
      *
      * @param request ModifyCollationTimeZoneRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyCollationTimeZoneResponse
     */
    async modifyCollationTimeZoneWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.collation)) {
            query["Collation"] = request.collation;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.timezone)) {
            query["Timezone"] = request.timezone;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyCollationTimeZone",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyCollationTimeZoneResponse({}));
    }
    /**
      * > This operation is phased out.
      *
      * @param request ModifyCollationTimeZoneRequest
      * @return ModifyCollationTimeZoneResponse
     */
    async modifyCollationTimeZone(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyCollationTimeZoneWithOptions(request, runtime);
    }
    async modifyCustinsResourceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.adjustDeadline)) {
            query["AdjustDeadline"] = request.adjustDeadline;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.increaseRatio)) {
            query["IncreaseRatio"] = request.increaseRatio;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.restoreOriginalSpecification)) {
            query["RestoreOriginalSpecification"] = request.restoreOriginalSpecification;
        }
        if (!tea_util_1.default.isUnset(request.targetValue)) {
            query["TargetValue"] = request.targetValue;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyCustinsResource",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyCustinsResourceResponse({}));
    }
    async modifyCustinsResource(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyCustinsResourceWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request ModifyDBDescriptionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBDescriptionResponse
     */
    async modifyDBDescriptionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBDescription)) {
            query["DBDescription"] = request.DBDescription;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBDescription",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBDescriptionResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      *
      * @param request ModifyDBDescriptionRequest
      * @return ModifyDBDescriptionResponse
     */
    async modifyDBDescription(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBDescriptionWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Modify automatic update settings for an ApsaraDB RDS for MySQL instance](~~96059~~)
      * *   [Modify automatic update settings for an ApsaraDB RDS for PostgreSQL instance](~~146895~~)
      *
      * @param request ModifyDBInstanceAutoUpgradeMinorVersionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceAutoUpgradeMinorVersionResponse
     */
    async modifyDBInstanceAutoUpgradeMinorVersionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.autoUpgradeMinorVersion)) {
            query["AutoUpgradeMinorVersion"] = request.autoUpgradeMinorVersion;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceAutoUpgradeMinorVersion",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceAutoUpgradeMinorVersionResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Modify automatic update settings for an ApsaraDB RDS for MySQL instance](~~96059~~)
      * *   [Modify automatic update settings for an ApsaraDB RDS for PostgreSQL instance](~~146895~~)
      *
      * @param request ModifyDBInstanceAutoUpgradeMinorVersionRequest
      * @return ModifyDBInstanceAutoUpgradeMinorVersionResponse
     */
    async modifyDBInstanceAutoUpgradeMinorVersion(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceAutoUpgradeMinorVersionWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      * >  The configuration item that is supported is [PgBouncer](~~2398301~~) of ApsaraDB RDS for PostgreSQL instances.
      *
      * @param request ModifyDBInstanceConfigRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceConfigResponse
     */
    async modifyDBInstanceConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.configName)) {
            query["ConfigName"] = request.configName;
        }
        if (!tea_util_1.default.isUnset(request.configValue)) {
            query["ConfigValue"] = request.configValue;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceConfig",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceConfigResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      * >  The configuration item that is supported is [PgBouncer](~~2398301~~) of ApsaraDB RDS for PostgreSQL instances.
      *
      * @param request ModifyDBInstanceConfigRequest
      * @return ModifyDBInstanceConfigResponse
     */
    async modifyDBInstanceConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceConfigWithOptions(request, runtime);
    }
    /**
      * > The API has been taken offline
      *
      * @param request ModifyDBInstanceConnectionModeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceConnectionModeResponse
     */
    async modifyDBInstanceConnectionModeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.connectionMode)) {
            query["ConnectionMode"] = request.connectionMode;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceConnectionMode",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceConnectionModeResponse({}));
    }
    /**
      * > The API has been taken offline
      *
      * @param request ModifyDBInstanceConnectionModeRequest
      * @return ModifyDBInstanceConnectionModeResponse
     */
    async modifyDBInstanceConnectionMode(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceConnectionModeWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
      * *   [Change the endpoint and port number of an ApsaraDB RDS for MySQL instance](~~96163~~)
      * *   [Change the endpoint and port number of an ApsaraDB RDS for PostgreSQL instance](~~96788~~)
      * *   [Change the endpoint and port number of an ApsaraDB RDS for SQL Server instance](~~95740~~)
      * *   [Change the endpoint and port number of an ApsaraDB RDS for MariaDB instance](~~97157~~)
      *
      * @param request ModifyDBInstanceConnectionStringRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceConnectionStringResponse
     */
    async modifyDBInstanceConnectionStringWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.babelfishPort)) {
            query["BabelfishPort"] = request.babelfishPort;
        }
        if (!tea_util_1.default.isUnset(request.connectionStringPrefix)) {
            query["ConnectionStringPrefix"] = request.connectionStringPrefix;
        }
        if (!tea_util_1.default.isUnset(request.currentConnectionString)) {
            query["CurrentConnectionString"] = request.currentConnectionString;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.generalGroupName)) {
            query["GeneralGroupName"] = request.generalGroupName;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.PGBouncerPort)) {
            query["PGBouncerPort"] = request.PGBouncerPort;
        }
        if (!tea_util_1.default.isUnset(request.port)) {
            query["Port"] = request.port;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceConnectionString",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceConnectionStringResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
      * *   [Change the endpoint and port number of an ApsaraDB RDS for MySQL instance](~~96163~~)
      * *   [Change the endpoint and port number of an ApsaraDB RDS for PostgreSQL instance](~~96788~~)
      * *   [Change the endpoint and port number of an ApsaraDB RDS for SQL Server instance](~~95740~~)
      * *   [Change the endpoint and port number of an ApsaraDB RDS for MariaDB instance](~~97157~~)
      *
      * @param request ModifyDBInstanceConnectionStringRequest
      * @return ModifyDBInstanceConnectionStringResponse
     */
    async modifyDBInstanceConnectionString(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceConnectionStringWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Configure a data replication latency for a read-only ApsaraDB RDS for MySQL instance](~~96056~~)
      *
      * @param request ModifyDBInstanceDelayedReplicationTimeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceDelayedReplicationTimeResponse
     */
    async modifyDBInstanceDelayedReplicationTimeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.readSQLReplicationTime)) {
            query["ReadSQLReplicationTime"] = request.readSQLReplicationTime;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceDelayedReplicationTime",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceDelayedReplicationTimeResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Configure a data replication latency for a read-only ApsaraDB RDS for MySQL instance](~~96056~~)
      *
      * @param request ModifyDBInstanceDelayedReplicationTimeRequest
      * @return ModifyDBInstanceDelayedReplicationTimeResponse
     */
    async modifyDBInstanceDelayedReplicationTime(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceDelayedReplicationTimeWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Enable and disable instance release protection for an ApsaraDB RDS for MySQL instance](~~414512~~)
      * *   [Enable and disable instance release protection for an ApsaraDB RDS for PostgreSQL instance](~~471512~~)
      * *   [Enable and disable instance release protection for an ApsaraDB RDS for SQL Server instance](~~416209~~)
      * *   [Enable and disable release protection for an ApsaraDB RDS for MariaDB instance](~~414512~~)
      *
      * @param request ModifyDBInstanceDeletionProtectionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceDeletionProtectionResponse
     */
    async modifyDBInstanceDeletionProtectionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.deletionProtection)) {
            query["DeletionProtection"] = request.deletionProtection;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceDeletionProtection",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceDeletionProtectionResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Enable and disable instance release protection for an ApsaraDB RDS for MySQL instance](~~414512~~)
      * *   [Enable and disable instance release protection for an ApsaraDB RDS for PostgreSQL instance](~~471512~~)
      * *   [Enable and disable instance release protection for an ApsaraDB RDS for SQL Server instance](~~416209~~)
      * *   [Enable and disable release protection for an ApsaraDB RDS for MariaDB instance](~~414512~~)
      *
      * @param request ModifyDBInstanceDeletionProtectionRequest
      * @return ModifyDBInstanceDeletionProtectionResponse
     */
    async modifyDBInstanceDeletionProtection(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceDeletionProtectionWithOptions(request, runtime);
    }
    async modifyDBInstanceDescriptionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceDescription)) {
            query["DBInstanceDescription"] = request.DBInstanceDescription;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceDescription",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceDescriptionResponse({}));
    }
    async modifyDBInstanceDescription(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceDescriptionWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * RDS MySQL
      *
      * @param tmpReq ModifyDBInstanceEndpointRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceEndpointResponse
     */
    async modifyDBInstanceEndpointWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new ModifyDBInstanceEndpointShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.nodeItems)) {
            request.nodeItemsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.nodeItems, "NodeItems", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceEndpointDescription)) {
            query["DBInstanceEndpointDescription"] = request.DBInstanceEndpointDescription;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceEndpointId)) {
            query["DBInstanceEndpointId"] = request.DBInstanceEndpointId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.nodeItemsShrink)) {
            query["NodeItems"] = request.nodeItemsShrink;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceEndpoint",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceEndpointResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * RDS MySQL
      *
      * @param request ModifyDBInstanceEndpointRequest
      * @return ModifyDBInstanceEndpointResponse
     */
    async modifyDBInstanceEndpoint(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceEndpointWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * RDS MySQL
      * ### [](#)Precautions
      * *   You can modify the following information about the endpoint of an instance: the public and internal endpoints, the public and internal ports, and the virtual private cloud (VPC), vSwitch, and IP address of the internal endpoint.
      * *   The VPC and vSwitch must be modified at the same time. If you specify the VPC, vSwitch, and IP address of the internal endpoint, you do not need to specify the endpoint and port. If you specify the endpoint and port, you do not need to specify the VPC, vSwitch, and IP address of the internal endpoint.
      *
      * @param request ModifyDBInstanceEndpointAddressRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceEndpointAddressResponse
     */
    async modifyDBInstanceEndpointAddressWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.connectionString)) {
            query["ConnectionString"] = request.connectionString;
        }
        if (!tea_util_1.default.isUnset(request.connectionStringPrefix)) {
            query["ConnectionStringPrefix"] = request.connectionStringPrefix;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceEndpointId)) {
            query["DBInstanceEndpointId"] = request.DBInstanceEndpointId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.port)) {
            query["Port"] = request.port;
        }
        if (!tea_util_1.default.isUnset(request.privateIpAddress)) {
            query["PrivateIpAddress"] = request.privateIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        if (!tea_util_1.default.isUnset(request.vpcId)) {
            query["VpcId"] = request.vpcId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceEndpointAddress",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceEndpointAddressResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * RDS MySQL
      * ### [](#)Precautions
      * *   You can modify the following information about the endpoint of an instance: the public and internal endpoints, the public and internal ports, and the virtual private cloud (VPC), vSwitch, and IP address of the internal endpoint.
      * *   The VPC and vSwitch must be modified at the same time. If you specify the VPC, vSwitch, and IP address of the internal endpoint, you do not need to specify the endpoint and port. If you specify the endpoint and port, you do not need to specify the VPC, vSwitch, and IP address of the internal endpoint.
      *
      * @param request ModifyDBInstanceEndpointAddressRequest
      * @return ModifyDBInstanceEndpointAddressResponse
     */
    async modifyDBInstanceEndpointAddress(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceEndpointAddressWithOptions(request, runtime);
    }
    async modifyDBInstanceHAConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dbInstanceId)) {
            query["DbInstanceId"] = request.dbInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.HAMode)) {
            query["HAMode"] = request.HAMode;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.syncMode)) {
            query["SyncMode"] = request.syncMode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceHAConfig",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceHAConfigResponse({}));
    }
    async modifyDBInstanceHAConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceHAConfigWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Set a maintenance window for an ApsaraDB RDS for MySQL instance](~~96052~~)
      * *   [Set a maintenance window for an ApsaraDB RDS for PostgreSQL instance](~~96799~~)
      * *   [Set a maintenance window for an ApsaraDB RDS for SQL Sever instance](~~95657~~)
      * *   [Set a maintenance window for an ApsaraDB RDS for MariaDB instance](~~97473~~)
      *
      * @param request ModifyDBInstanceMaintainTimeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceMaintainTimeResponse
     */
    async modifyDBInstanceMaintainTimeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.maintainTime)) {
            query["MaintainTime"] = request.maintainTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceMaintainTime",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceMaintainTimeResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Set a maintenance window for an ApsaraDB RDS for MySQL instance](~~96052~~)
      * *   [Set a maintenance window for an ApsaraDB RDS for PostgreSQL instance](~~96799~~)
      * *   [Set a maintenance window for an ApsaraDB RDS for SQL Sever instance](~~95657~~)
      * *   [Set a maintenance window for an ApsaraDB RDS for MariaDB instance](~~97473~~)
      *
      * @param request ModifyDBInstanceMaintainTimeRequest
      * @return ModifyDBInstanceMaintainTimeResponse
     */
    async modifyDBInstanceMaintainTime(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceMaintainTimeWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [View the Enhanced Monitoring metrics](~~299200~~)
      *
      * @param request ModifyDBInstanceMetricsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceMetricsResponse
     */
    async modifyDBInstanceMetricsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceName)) {
            query["DBInstanceName"] = request.DBInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.metricsConfig)) {
            query["MetricsConfig"] = request.metricsConfig;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.scope)) {
            query["Scope"] = request.scope;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceMetrics",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceMetricsResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [View the Enhanced Monitoring metrics](~~299200~~)
      *
      * @param request ModifyDBInstanceMetricsRequest
      * @return ModifyDBInstanceMetricsResponse
     */
    async modifyDBInstanceMetrics(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceMetricsWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### [](#)Usage notes
      * If you use the Every 5 Seconds monitoring frequency, you are charged additional fees. Before you call this operation, make sure that you understand the [billing methods and pricing](~~45020~~) of ApsaraDB RDS.
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Configure the monitoring frequency for an ApsaraDB RDS for MySQL instance](~~96112~~)
      * *   [Configure the monitoring frequency for an ApsaraDB RDS for SQL Server instance](~~95710~~)
      *
      * @param request ModifyDBInstanceMonitorRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceMonitorResponse
     */
    async modifyDBInstanceMonitorWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.period)) {
            query["Period"] = request.period;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceMonitor",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceMonitorResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### [](#)Usage notes
      * If you use the Every 5 Seconds monitoring frequency, you are charged additional fees. Before you call this operation, make sure that you understand the [billing methods and pricing](~~45020~~) of ApsaraDB RDS.
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Configure the monitoring frequency for an ApsaraDB RDS for MySQL instance](~~96112~~)
      * *   [Configure the monitoring frequency for an ApsaraDB RDS for SQL Server instance](~~95710~~)
      *
      * @param request ModifyDBInstanceMonitorRequest
      * @return ModifyDBInstanceMonitorResponse
     */
    async modifyDBInstanceMonitor(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceMonitorWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### [](#)References
      * *   [Configure the hybrid access solution for an ApsaraDB RDS for MySQL instance](~~96110~~)
      * *   [Configure the hybrid access solution for an ApsaraDB RDS for SQL Server instance](~~95708~~)
      *
      * @param request ModifyDBInstanceNetworkExpireTimeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceNetworkExpireTimeResponse
     */
    async modifyDBInstanceNetworkExpireTimeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.classicExpiredDays)) {
            query["ClassicExpiredDays"] = request.classicExpiredDays;
        }
        if (!tea_util_1.default.isUnset(request.connectionString)) {
            query["ConnectionString"] = request.connectionString;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceNetworkExpireTime",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceNetworkExpireTimeResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### [](#)References
      * *   [Configure the hybrid access solution for an ApsaraDB RDS for MySQL instance](~~96110~~)
      * *   [Configure the hybrid access solution for an ApsaraDB RDS for SQL Server instance](~~95708~~)
      *
      * @param request ModifyDBInstanceNetworkExpireTimeRequest
      * @return ModifyDBInstanceNetworkExpireTimeResponse
     */
    async modifyDBInstanceNetworkExpireTime(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceNetworkExpireTimeWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Change the network type of an ApsaraDB RDS for MySQL instance](~~96109~~)
      * *   [Change the network type of an ApsaraDB RDS for PostgreSQL instance](~~96761~~)
      * *   [Change the network type of an ApsaraDB RDS for SQL Server instance](~~95707~~)
      *
      * @param request ModifyDBInstanceNetworkTypeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceNetworkTypeResponse
     */
    async modifyDBInstanceNetworkTypeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.classicExpiredDays)) {
            query["ClassicExpiredDays"] = request.classicExpiredDays;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.instanceNetworkType)) {
            query["InstanceNetworkType"] = request.instanceNetworkType;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.privateIpAddress)) {
            query["PrivateIpAddress"] = request.privateIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.readWriteSplittingClassicExpiredDays)) {
            query["ReadWriteSplittingClassicExpiredDays"] = request.readWriteSplittingClassicExpiredDays;
        }
        if (!tea_util_1.default.isUnset(request.readWriteSplittingPrivateIpAddress)) {
            query["ReadWriteSplittingPrivateIpAddress"] = request.readWriteSplittingPrivateIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.retainClassic)) {
            query["RetainClassic"] = request.retainClassic;
        }
        if (!tea_util_1.default.isUnset(request.VPCId)) {
            query["VPCId"] = request.VPCId;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceNetworkType",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceNetworkTypeResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Change the network type of an ApsaraDB RDS for MySQL instance](~~96109~~)
      * *   [Change the network type of an ApsaraDB RDS for PostgreSQL instance](~~96761~~)
      * *   [Change the network type of an ApsaraDB RDS for SQL Server instance](~~95707~~)
      *
      * @param request ModifyDBInstanceNetworkTypeRequest
      * @return ModifyDBInstanceNetworkTypeResponse
     */
    async modifyDBInstanceNetworkType(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceNetworkTypeWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * >  Fees of an instance are changed if the call is successful. Before you call this operation, carefully read the following topics:
      * *   [Change the billing method of an ApsaraDB RDS for MySQL instance from pay-as-you-go to subscription](~~96048~~)
      * *   [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from pay-as-you-go to subscription](~~96743~~)
      * *   [Change the billing method of an ApsaraDB RDS for SQL Server instance from pay-as-you-go to subscription](~~95631~~)
      * *   [Change the billing method of an ApsaraDB RDS for MariaDB instance from pay-as-you-go to subscription](~~97120~~)
      *
      * @param request ModifyDBInstancePayTypeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstancePayTypeResponse
     */
    async modifyDBInstancePayTypeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.payType)) {
            query["PayType"] = request.payType;
        }
        if (!tea_util_1.default.isUnset(request.period)) {
            query["Period"] = request.period;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.usedTime)) {
            query["UsedTime"] = request.usedTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstancePayType",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstancePayTypeResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * >  Fees of an instance are changed if the call is successful. Before you call this operation, carefully read the following topics:
      * *   [Change the billing method of an ApsaraDB RDS for MySQL instance from pay-as-you-go to subscription](~~96048~~)
      * *   [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from pay-as-you-go to subscription](~~96743~~)
      * *   [Change the billing method of an ApsaraDB RDS for SQL Server instance from pay-as-you-go to subscription](~~95631~~)
      * *   [Change the billing method of an ApsaraDB RDS for MariaDB instance from pay-as-you-go to subscription](~~97120~~)
      *
      * @param request ModifyDBInstancePayTypeRequest
      * @return ModifyDBInstancePayTypeResponse
     */
    async modifyDBInstancePayType(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstancePayTypeWithOptions(request, runtime);
    }
    /**
      * > This operation is phased out.
      *
      * @param request ModifyDBInstanceProxyConfigurationRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceProxyConfigurationResponse
     */
    async modifyDBInstanceProxyConfigurationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.proxyConfigurationKey)) {
            query["ProxyConfigurationKey"] = request.proxyConfigurationKey;
        }
        if (!tea_util_1.default.isUnset(request.proxyConfigurationValue)) {
            query["ProxyConfigurationValue"] = request.proxyConfigurationValue;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceProxyConfiguration",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceProxyConfigurationResponse({}));
    }
    /**
      * > This operation is phased out.
      *
      * @param request ModifyDBInstanceProxyConfigurationRequest
      * @return ModifyDBInstanceProxyConfigurationResponse
     */
    async modifyDBInstanceProxyConfiguration(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceProxyConfigurationWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Use the SSL encryption feature for an ApsaraDB RDS for MySQL instance](~~96120~~)
      * *   [Use the SSL encryption feature for an ApsaraDB RDS for PostgreSQL instance](~~229517~~)
      * *   [Use the SSL encryption feature for an ApsaraDB RDS for SQL Server instance](~~95715~~)
      *
      * @param request ModifyDBInstanceSSLRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceSSLResponse
     */
    async modifyDBInstanceSSLWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ACL)) {
            query["ACL"] = request.ACL;
        }
        if (!tea_util_1.default.isUnset(request.CAType)) {
            query["CAType"] = request.CAType;
        }
        if (!tea_util_1.default.isUnset(request.clientCACert)) {
            query["ClientCACert"] = request.clientCACert;
        }
        if (!tea_util_1.default.isUnset(request.clientCAEnabled)) {
            query["ClientCAEnabled"] = request.clientCAEnabled;
        }
        if (!tea_util_1.default.isUnset(request.clientCertRevocationList)) {
            query["ClientCertRevocationList"] = request.clientCertRevocationList;
        }
        if (!tea_util_1.default.isUnset(request.clientCrlEnabled)) {
            query["ClientCrlEnabled"] = request.clientCrlEnabled;
        }
        if (!tea_util_1.default.isUnset(request.connectionString)) {
            query["ConnectionString"] = request.connectionString;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.replicationACL)) {
            query["ReplicationACL"] = request.replicationACL;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.SSLEnabled)) {
            query["SSLEnabled"] = request.SSLEnabled;
        }
        if (!tea_util_1.default.isUnset(request.serverCert)) {
            query["ServerCert"] = request.serverCert;
        }
        if (!tea_util_1.default.isUnset(request.serverKey)) {
            query["ServerKey"] = request.serverKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceSSL",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceSSLResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Use the SSL encryption feature for an ApsaraDB RDS for MySQL instance](~~96120~~)
      * *   [Use the SSL encryption feature for an ApsaraDB RDS for PostgreSQL instance](~~229517~~)
      * *   [Use the SSL encryption feature for an ApsaraDB RDS for SQL Server instance](~~95715~~)
      *
      * @param request ModifyDBInstanceSSLRequest
      * @return ModifyDBInstanceSSLResponse
     */
    async modifyDBInstanceSSL(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceSSLWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Fees are generated if the call is successful. Before you call this operation, carefully read the following documentation:
      * *   [Change the specifications of an ApsaraDB RDS for MySQL instance](~~96061~~)
      * *   [Change the specifications of an ApsaraDB RDS for PostgreSQL instance](~~96750~~)
      * *   [Change the specifications of an ApsaraDB RDS for SQL Server instance](~~95665~~)
      * *   [Change the specifications of an ApsaraDB RDS for MariaDB instance](~~97129~~)
      *
      * @param tmpReq ModifyDBInstanceSpecRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceSpecResponse
     */
    async modifyDBInstanceSpecWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new ModifyDBInstanceSpecShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.serverlessConfiguration)) {
            request.serverlessConfigurationShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.serverlessConfiguration, "ServerlessConfiguration", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.autoUseCoupon)) {
            query["AutoUseCoupon"] = request.autoUseCoupon;
        }
        if (!tea_util_1.default.isUnset(request.burstingEnabled)) {
            query["BurstingEnabled"] = request.burstingEnabled;
        }
        if (!tea_util_1.default.isUnset(request.category)) {
            query["Category"] = request.category;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceClass)) {
            query["DBInstanceClass"] = request.DBInstanceClass;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorage)) {
            query["DBInstanceStorage"] = request.DBInstanceStorage;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorageType)) {
            query["DBInstanceStorageType"] = request.DBInstanceStorageType;
        }
        if (!tea_util_1.default.isUnset(request.dedicatedHostGroupId)) {
            query["DedicatedHostGroupId"] = request.dedicatedHostGroupId;
        }
        if (!tea_util_1.default.isUnset(request.direction)) {
            query["Direction"] = request.direction;
        }
        if (!tea_util_1.default.isUnset(request.effectiveTime)) {
            query["EffectiveTime"] = request.effectiveTime;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.payType)) {
            query["PayType"] = request.payType;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.serverlessConfigurationShrink)) {
            query["ServerlessConfiguration"] = request.serverlessConfigurationShrink;
        }
        if (!tea_util_1.default.isUnset(request.sourceBiz)) {
            query["SourceBiz"] = request.sourceBiz;
        }
        if (!tea_util_1.default.isUnset(request.switchTime)) {
            query["SwitchTime"] = request.switchTime;
        }
        if (!tea_util_1.default.isUnset(request.targetMinorVersion)) {
            query["TargetMinorVersion"] = request.targetMinorVersion;
        }
        if (!tea_util_1.default.isUnset(request.usedTime)) {
            query["UsedTime"] = request.usedTime;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceSpec",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceSpecResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Fees are generated if the call is successful. Before you call this operation, carefully read the following documentation:
      * *   [Change the specifications of an ApsaraDB RDS for MySQL instance](~~96061~~)
      * *   [Change the specifications of an ApsaraDB RDS for PostgreSQL instance](~~96750~~)
      * *   [Change the specifications of an ApsaraDB RDS for SQL Server instance](~~95665~~)
      * *   [Change the specifications of an ApsaraDB RDS for MariaDB instance](~~97129~~)
      *
      * @param request ModifyDBInstanceSpecRequest
      * @return ModifyDBInstanceSpecResponse
     */
    async modifyDBInstanceSpec(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceSpecWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Configure TDE for an ApsaraDB RDS for MySQL instance](~~96121~~)
      * *   [Configure TDE for an ApsaraDB RDS for PostgreSQL instance](~~465652~~)
      * *   [Configure TDE for an ApsaraDB RDS for SQL Server instance](~~95716~~)
      *
      * @param request ModifyDBInstanceTDERequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBInstanceTDEResponse
     */
    async modifyDBInstanceTDEWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.certificate)) {
            query["Certificate"] = request.certificate;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.encryptionKey)) {
            query["EncryptionKey"] = request.encryptionKey;
        }
        if (!tea_util_1.default.isUnset(request.isRotate)) {
            query["IsRotate"] = request.isRotate;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.passWord)) {
            query["PassWord"] = request.passWord;
        }
        if (!tea_util_1.default.isUnset(request.privateKey)) {
            query["PrivateKey"] = request.privateKey;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.roleArn)) {
            query["RoleArn"] = request.roleArn;
        }
        if (!tea_util_1.default.isUnset(request.TDEStatus)) {
            query["TDEStatus"] = request.TDEStatus;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBInstanceTDE",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBInstanceTDEResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Configure TDE for an ApsaraDB RDS for MySQL instance](~~96121~~)
      * *   [Configure TDE for an ApsaraDB RDS for PostgreSQL instance](~~465652~~)
      * *   [Configure TDE for an ApsaraDB RDS for SQL Server instance](~~95716~~)
      *
      * @param request ModifyDBInstanceTDERequest
      * @return ModifyDBInstanceTDEResponse
     */
    async modifyDBInstanceTDE(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBInstanceTDEWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * ### [](#)References
      * > Fees are generated if the call is successful. Before you call this operation, carefully read the following topics:
      * *   [Change the specifications of an ApsaraDB RDS for MySQL instance](~~96061~~)
      *
      * @param tmpReq ModifyDBNodeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBNodeResponse
     */
    async modifyDBNodeWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new ModifyDBNodeShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.DBNode)) {
            request.DBNodeShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.DBNode, "DBNode", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.autoPay)) {
            query["AutoPay"] = request.autoPay;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorage)) {
            query["DBInstanceStorage"] = request.DBInstanceStorage;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorageType)) {
            query["DBInstanceStorageType"] = request.DBInstanceStorageType;
        }
        if (!tea_util_1.default.isUnset(request.DBNodeShrink)) {
            query["DBNode"] = request.DBNodeShrink;
        }
        if (!tea_util_1.default.isUnset(request.dryRun)) {
            query["DryRun"] = request.dryRun;
        }
        if (!tea_util_1.default.isUnset(request.effectiveTime)) {
            query["EffectiveTime"] = request.effectiveTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.produceAsync)) {
            query["ProduceAsync"] = request.produceAsync;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBNode",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBNodeResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * ### [](#)References
      * > Fees are generated if the call is successful. Before you call this operation, carefully read the following topics:
      * *   [Change the specifications of an ApsaraDB RDS for MySQL instance](~~96061~~)
      *
      * @param request ModifyDBNodeRequest
      * @return ModifyDBNodeResponse
     */
    async modifyDBNode(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBNodeWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * >  Starting October 17, 2023, ApsaraDB RDS provides a dedicated proxy free of charge for each ApsaraDB RDS for MySQL instance on RDS Cluster Edition. For more information, see [\\[Special offers/Price changes\\] One proxy is provided free of charge for ApsaraDB RDS for MySQL instances on RDS Cluster Edition](~~2555466~~).
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Enable and configure the dedicated proxy feature for an ApsaraDB RDS for MySQL instance](~~197456~~)
      * *   [Enable and configure the dedicated proxy feature for an ApsaraDB RDS for PostgreSQL instance](~~418272~~)
      *
      * @param request ModifyDBProxyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBProxyResponse
     */
    async modifyDBProxyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.configDBProxyService)) {
            query["ConfigDBProxyService"] = request.configDBProxyService;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyEngineType)) {
            query["DBProxyEngineType"] = request.DBProxyEngineType;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyInstanceNum)) {
            query["DBProxyInstanceNum"] = request.DBProxyInstanceNum;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyInstanceType)) {
            query["DBProxyInstanceType"] = request.DBProxyInstanceType;
        }
        if (!tea_util_1.default.isUnset(request.instanceNetworkType)) {
            query["InstanceNetworkType"] = request.instanceNetworkType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.VPCId)) {
            query["VPCId"] = request.VPCId;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBProxy",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBProxyResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * >  Starting October 17, 2023, ApsaraDB RDS provides a dedicated proxy free of charge for each ApsaraDB RDS for MySQL instance on RDS Cluster Edition. For more information, see [\\[Special offers/Price changes\\] One proxy is provided free of charge for ApsaraDB RDS for MySQL instances on RDS Cluster Edition](~~2555466~~).
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Enable and configure the dedicated proxy feature for an ApsaraDB RDS for MySQL instance](~~197456~~)
      * *   [Enable and configure the dedicated proxy feature for an ApsaraDB RDS for PostgreSQL instance](~~418272~~)
      *
      * @param request ModifyDBProxyRequest
      * @return ModifyDBProxyResponse
     */
    async modifyDBProxy(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBProxyWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Enable and configure the dedicated proxy feature](~~197456~~)
      * *   [Create a database proxy terminal for an ApsaraDB RDS for PostgreSQL instance](~~418273~~)
      *
      * @param request ModifyDBProxyEndpointRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBProxyEndpointResponse
     */
    async modifyDBProxyEndpointWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.configDBProxyFeatures)) {
            query["ConfigDBProxyFeatures"] = request.configDBProxyFeatures;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyEndpointId)) {
            query["DBProxyEndpointId"] = request.DBProxyEndpointId;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyEngineType)) {
            query["DBProxyEngineType"] = request.DBProxyEngineType;
        }
        if (!tea_util_1.default.isUnset(request.dbEndpointAliases)) {
            query["DbEndpointAliases"] = request.dbEndpointAliases;
        }
        if (!tea_util_1.default.isUnset(request.dbEndpointOperator)) {
            query["DbEndpointOperator"] = request.dbEndpointOperator;
        }
        if (!tea_util_1.default.isUnset(request.dbEndpointReadWriteMode)) {
            query["DbEndpointReadWriteMode"] = request.dbEndpointReadWriteMode;
        }
        if (!tea_util_1.default.isUnset(request.dbEndpointType)) {
            query["DbEndpointType"] = request.dbEndpointType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.readOnlyInstanceDistributionType)) {
            query["ReadOnlyInstanceDistributionType"] = request.readOnlyInstanceDistributionType;
        }
        if (!tea_util_1.default.isUnset(request.readOnlyInstanceMaxDelayTime)) {
            query["ReadOnlyInstanceMaxDelayTime"] = request.readOnlyInstanceMaxDelayTime;
        }
        if (!tea_util_1.default.isUnset(request.readOnlyInstanceWeight)) {
            query["ReadOnlyInstanceWeight"] = request.readOnlyInstanceWeight;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBProxyEndpoint",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBProxyEndpointResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Enable and configure the dedicated proxy feature](~~197456~~)
      * *   [Create a database proxy terminal for an ApsaraDB RDS for PostgreSQL instance](~~418273~~)
      *
      * @param request ModifyDBProxyEndpointRequest
      * @return ModifyDBProxyEndpointResponse
     */
    async modifyDBProxyEndpoint(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBProxyEndpointWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](~~184921~~)
      * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for PostgreSQL instance](~~418274~~)
      *
      * @param request ModifyDBProxyEndpointAddressRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBProxyEndpointAddressResponse
     */
    async modifyDBProxyEndpointAddressWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyConnectStringNetType)) {
            query["DBProxyConnectStringNetType"] = request.DBProxyConnectStringNetType;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyEndpointId)) {
            query["DBProxyEndpointId"] = request.DBProxyEndpointId;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyEngineType)) {
            query["DBProxyEngineType"] = request.DBProxyEngineType;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyNewConnectString)) {
            query["DBProxyNewConnectString"] = request.DBProxyNewConnectString;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyNewConnectStringPort)) {
            query["DBProxyNewConnectStringPort"] = request.DBProxyNewConnectStringPort;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBProxyEndpointAddress",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBProxyEndpointAddressResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for MySQL instance](~~184921~~)
      * *   [Configure the dedicated proxy endpoint of an ApsaraDB RDS for PostgreSQL instance](~~418274~~)
      *
      * @param request ModifyDBProxyEndpointAddressRequest
      * @return ModifyDBProxyEndpointAddressResponse
     */
    async modifyDBProxyEndpointAddress(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBProxyEndpointAddressWithOptions(request, runtime);
    }
    /**
      * Before you call the ModifyDBProxyInstance operation, make sure that the [ModifyDBProxy](~~141054~~) operation is called to enable the database proxy feature for the instance.
      * *   The dedicated proxy feature of ApsaraDB RDS for MySQL provides capabilities such as read/write splitting and short-lived connection optimization. For more information, see [What are database proxies?](~~138705~~)
      * *   The database proxy feature of ApsaraDB RDS for PostgreSQL supports read/write splitting. For more information, see [What are database proxies?](~~412194~~)
      *
      * @param request ModifyDBProxyInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDBProxyInstanceResponse
     */
    async modifyDBProxyInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyEngineType)) {
            query["DBProxyEngineType"] = request.DBProxyEngineType;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyInstanceNum)) {
            query["DBProxyInstanceNum"] = request.DBProxyInstanceNum;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyInstanceType)) {
            query["DBProxyInstanceType"] = request.DBProxyInstanceType;
        }
        if (!tea_util_1.default.isUnset(request.effectiveSpecificTime)) {
            query["EffectiveSpecificTime"] = request.effectiveSpecificTime;
        }
        if (!tea_util_1.default.isUnset(request.effectiveTime)) {
            query["EffectiveTime"] = request.effectiveTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDBProxyInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDBProxyInstanceResponse({}));
    }
    /**
      * Before you call the ModifyDBProxyInstance operation, make sure that the [ModifyDBProxy](~~141054~~) operation is called to enable the database proxy feature for the instance.
      * *   The dedicated proxy feature of ApsaraDB RDS for MySQL provides capabilities such as read/write splitting and short-lived connection optimization. For more information, see [What are database proxies?](~~138705~~)
      * *   The database proxy feature of ApsaraDB RDS for PostgreSQL supports read/write splitting. For more information, see [What are database proxies?](~~412194~~)
      *
      * @param request ModifyDBProxyInstanceRequest
      * @return ModifyDBProxyInstanceResponse
     */
    async modifyDBProxyInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDBProxyInstanceWithOptions(request, runtime);
    }
    /**
      * Distributed transaction whitelists allow for distributed transactions between an Elastic Compute Service (ECS) instance and an RDS instance. For more information, see [Configure a distributed transaction whitelist](~~124321~~).
      * This operation is applicable to instances that run one of the following SQL Server versions in the RDS High-Availability Edition: 2012 SE, 2012 EE, 2014 SE, 2016 SE, 2016 EE, and 2017 SE.
      *
      * @param request ModifyDTCSecurityIpHostsForSQLServerRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDTCSecurityIpHostsForSQLServerResponse
     */
    async modifyDTCSecurityIpHostsForSQLServerWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityIpHosts)) {
            query["SecurityIpHosts"] = request.securityIpHosts;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        if (!tea_util_1.default.isUnset(request.whiteListGroupName)) {
            query["WhiteListGroupName"] = request.whiteListGroupName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDTCSecurityIpHostsForSQLServer",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDTCSecurityIpHostsForSQLServerResponse({}));
    }
    /**
      * Distributed transaction whitelists allow for distributed transactions between an Elastic Compute Service (ECS) instance and an RDS instance. For more information, see [Configure a distributed transaction whitelist](~~124321~~).
      * This operation is applicable to instances that run one of the following SQL Server versions in the RDS High-Availability Edition: 2012 SE, 2012 EE, 2014 SE, 2016 SE, 2016 EE, and 2017 SE.
      *
      * @param request ModifyDTCSecurityIpHostsForSQLServerRequest
      * @return ModifyDTCSecurityIpHostsForSQLServerResponse
     */
    async modifyDTCSecurityIpHostsForSQLServer(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDTCSecurityIpHostsForSQLServerWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Configure automatic storage expansion for ApsaraDB RDS for MySQL](~~173826~~)
      * *   [Configure automatic storage expansion for ApsaraDB RDS for PostgreSQL](~~432496~~)
      *
      * @param request ModifyDasInstanceConfigRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDasInstanceConfigResponse
     */
    async modifyDasInstanceConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.storageAutoScale)) {
            query["StorageAutoScale"] = request.storageAutoScale;
        }
        if (!tea_util_1.default.isUnset(request.storageThreshold)) {
            query["StorageThreshold"] = request.storageThreshold;
        }
        if (!tea_util_1.default.isUnset(request.storageUpperBound)) {
            query["StorageUpperBound"] = request.storageUpperBound;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDasInstanceConfig",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDasInstanceConfigResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Configure automatic storage expansion for ApsaraDB RDS for MySQL](~~173826~~)
      * *   [Configure automatic storage expansion for ApsaraDB RDS for PostgreSQL](~~432496~~)
      *
      * @param request ModifyDasInstanceConfigRequest
      * @return ModifyDasInstanceConfigResponse
     */
    async modifyDasInstanceConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDasInstanceConfigWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engine
      * *   SQL Server
      *
      * @param request ModifyDatabaseConfigRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDatabaseConfigResponse
     */
    async modifyDatabaseConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.databasePropertyName)) {
            query["DatabasePropertyName"] = request.databasePropertyName;
        }
        if (!tea_util_1.default.isUnset(request.databasePropertyValue)) {
            query["DatabasePropertyValue"] = request.databasePropertyValue;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDatabaseConfig",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDatabaseConfigResponse({}));
    }
    /**
      * ### [](#)Supported database engine
      * *   SQL Server
      *
      * @param request ModifyDatabaseConfigRequest
      * @return ModifyDatabaseConfigResponse
     */
    async modifyDatabaseConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDatabaseConfigWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * RDS MySQL
      * ### [](#)References
      * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
      * [Configure SSL encryption for a proxy endpoint](~~188164~~)
      *
      * @param request ModifyDbProxyInstanceSslRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyDbProxyInstanceSslResponse
     */
    async modifyDbProxyInstanceSslWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBProxyEngineType)) {
            query["DBProxyEngineType"] = request.DBProxyEngineType;
        }
        if (!tea_util_1.default.isUnset(request.dbInstanceId)) {
            query["DbInstanceId"] = request.dbInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.dbInstanceId)) {
            query["DbInstanceId"] = request.dbInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.dbProxyConnectString)) {
            query["DbProxyConnectString"] = request.dbProxyConnectString;
        }
        if (!tea_util_1.default.isUnset(request.dbProxyEndpointId)) {
            query["DbProxyEndpointId"] = request.dbProxyEndpointId;
        }
        if (!tea_util_1.default.isUnset(request.dbProxySslEnabled)) {
            query["DbProxySslEnabled"] = request.dbProxySslEnabled;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyDbProxyInstanceSsl",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyDbProxyInstanceSslResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * RDS MySQL
      * ### [](#)References
      * > : Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
      * [Configure SSL encryption for a proxy endpoint](~~188164~~)
      *
      * @param request ModifyDbProxyInstanceSslRequest
      * @return ModifyDbProxyInstanceSslResponse
     */
    async modifyDbProxyInstanceSsl(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyDbProxyInstanceSslWithOptions(request, runtime);
    }
    async modifyEventInfoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.actionParams)) {
            query["ActionParams"] = request.actionParams;
        }
        if (!tea_util_1.default.isUnset(request.eventAction)) {
            query["EventAction"] = request.eventAction;
        }
        if (!tea_util_1.default.isUnset(request.eventId)) {
            query["EventId"] = request.eventId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyEventInfo",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyEventInfoResponse({}));
    }
    async modifyEventInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyEventInfoWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [What is availability check?](~~207467~~)
      *
      * @param request ModifyHADiagnoseConfigRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyHADiagnoseConfigResponse
     */
    async modifyHADiagnoseConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.tcpConnectionType)) {
            query["TcpConnectionType"] = request.tcpConnectionType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyHADiagnoseConfig",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyHADiagnoseConfigResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [What is availability check?](~~207467~~)
      *
      * @param request ModifyHADiagnoseConfigRequest
      * @return ModifyHADiagnoseConfigResponse
     */
    async modifyHADiagnoseConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyHADiagnoseConfigWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for MySQL instance](~~96054~~)
      * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for PostgreSQL instance](~~96747~~)
      * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for SQL Server instance](~~95659~~)
      * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for MariaDB instance](~~97127~~)
      *
      * @param request ModifyHASwitchConfigRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyHASwitchConfigResponse
     */
    async modifyHASwitchConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.HAConfig)) {
            query["HAConfig"] = request.HAConfig;
        }
        if (!tea_util_1.default.isUnset(request.manualHATime)) {
            query["ManualHATime"] = request.manualHATime;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyHASwitchConfig",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyHASwitchConfigResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for MySQL instance](~~96054~~)
      * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for PostgreSQL instance](~~96747~~)
      * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for SQL Server instance](~~95659~~)
      * *   [Use the automatic primary/secondary switchover feature for an ApsaraDB RDS for MariaDB instance](~~97127~~)
      *
      * @param request ModifyHASwitchConfigRequest
      * @return ModifyHASwitchConfigResponse
     */
    async modifyHASwitchConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyHASwitchConfigWithOptions(request, runtime);
    }
    /**
      * If you enable auto-renewal for your instance, you do not need to manually renew your subscription or be concerned about business interruptions caused by subscription expiration. For more information, see [Configure auto-renewal](~~96049~~).
      *
      * @param request ModifyInstanceAutoRenewalAttributeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyInstanceAutoRenewalAttributeResponse
     */
    async modifyInstanceAutoRenewalAttributeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.autoRenew)) {
            query["AutoRenew"] = request.autoRenew;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.duration)) {
            query["Duration"] = request.duration;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyInstanceAutoRenewalAttribute",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyInstanceAutoRenewalAttributeResponse({}));
    }
    /**
      * If you enable auto-renewal for your instance, you do not need to manually renew your subscription or be concerned about business interruptions caused by subscription expiration. For more information, see [Configure auto-renewal](~~96049~~).
      *
      * @param request ModifyInstanceAutoRenewalAttributeRequest
      * @return ModifyInstanceAutoRenewalAttributeResponse
     */
    async modifyInstanceAutoRenewalAttribute(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyInstanceAutoRenewalAttributeWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
      *
      * @param request ModifyInstanceCrossBackupPolicyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyInstanceCrossBackupPolicyResponse
     */
    async modifyInstanceCrossBackupPolicyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupEnabled)) {
            query["BackupEnabled"] = request.backupEnabled;
        }
        if (!tea_util_1.default.isUnset(request.crossBackupRegion)) {
            query["CrossBackupRegion"] = request.crossBackupRegion;
        }
        if (!tea_util_1.default.isUnset(request.crossBackupType)) {
            query["CrossBackupType"] = request.crossBackupType;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.logBackupEnabled)) {
            query["LogBackupEnabled"] = request.logBackupEnabled;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.retentType)) {
            query["RetentType"] = request.retentType;
        }
        if (!tea_util_1.default.isUnset(request.retention)) {
            query["Retention"] = request.retention;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyInstanceCrossBackupPolicy",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyInstanceCrossBackupPolicyResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Use the cross-region backup feature of an ApsaraDB RDS for MySQL instance](~~120824~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for PostgreSQL instance](~~206671~~)
      * *   [Use the cross-region backup feature for an ApsaraDB RDS for SQL Server instance](~~187923~~)
      *
      * @param request ModifyInstanceCrossBackupPolicyRequest
      * @return ModifyInstanceCrossBackupPolicyResponse
     */
    async modifyInstanceCrossBackupPolicy(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyInstanceCrossBackupPolicyWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * RDS PostgreSQL
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Connect an ApsaraDB RDS for PostgreSQL instance to a self-managed AD domain](~~349288~~)
      * *   [The pg_hba.conf File](https://www.postgresql.org/docs/11/auth-pg-hba-conf.html)
      *
      * @param request ModifyPGHbaConfigRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyPGHbaConfigResponse
     */
    async modifyPGHbaConfigWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.hbaItem)) {
            query["HbaItem"] = request.hbaItem;
        }
        if (!tea_util_1.default.isUnset(request.opsType)) {
            query["OpsType"] = request.opsType;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyPGHbaConfig",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyPGHbaConfigResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * RDS PostgreSQL
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Connect an ApsaraDB RDS for PostgreSQL instance to a self-managed AD domain](~~349288~~)
      * *   [The pg_hba.conf File](https://www.postgresql.org/docs/11/auth-pg-hba-conf.html)
      *
      * @param request ModifyPGHbaConfigRequest
      * @return ModifyPGHbaConfigResponse
     */
    async modifyPGHbaConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyPGHbaConfigWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Modify the parameters of an ApsaraDB RDS for MySQL instance](~~96063~~)
      * *   [Modify the parameters of an ApsaraDB RDS for PostgreSQL instance](~~96751~~)
      * *   [Modify the parameters of an ApsaraDB RDS for SQL Server instance](~~95667~~)
      * *   [Modify the parameters of an ApsaraDB RDS for MariaDB instance](~~97130~~)
      *
      * @param request ModifyParameterRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyParameterResponse
     */
    async modifyParameterWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.forcerestart)) {
            query["Forcerestart"] = request.forcerestart;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.parameterGroupId)) {
            query["ParameterGroupId"] = request.parameterGroupId;
        }
        if (!tea_util_1.default.isUnset(request.parameters)) {
            query["Parameters"] = request.parameters;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.switchTime)) {
            query["SwitchTime"] = request.switchTime;
        }
        if (!tea_util_1.default.isUnset(request.switchTimeMode)) {
            query["SwitchTimeMode"] = request.switchTimeMode;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyParameter",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyParameterResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Modify the parameters of an ApsaraDB RDS for MySQL instance](~~96063~~)
      * *   [Modify the parameters of an ApsaraDB RDS for PostgreSQL instance](~~96751~~)
      * *   [Modify the parameters of an ApsaraDB RDS for SQL Server instance](~~95667~~)
      * *   [Modify the parameters of an ApsaraDB RDS for MariaDB instance](~~97130~~)
      *
      * @param request ModifyParameterRequest
      * @return ModifyParameterResponse
     */
    async modifyParameter(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyParameterWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
      *
      * @param request ModifyParameterGroupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyParameterGroupResponse
     */
    async modifyParameterGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.modifyMode)) {
            query["ModifyMode"] = request.modifyMode;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.parameterGroupDesc)) {
            query["ParameterGroupDesc"] = request.parameterGroupDesc;
        }
        if (!tea_util_1.default.isUnset(request.parameterGroupId)) {
            query["ParameterGroupId"] = request.parameterGroupId;
        }
        if (!tea_util_1.default.isUnset(request.parameterGroupName)) {
            query["ParameterGroupName"] = request.parameterGroupName;
        }
        if (!tea_util_1.default.isUnset(request.parameters)) {
            query["Parameters"] = request.parameters;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyParameterGroup",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyParameterGroupResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for MySQL instances](~~130565~~)
      * *   [Use a parameter template to configure the parameters of ApsaraDB RDS for PostgreSQL instances](~~457176~~)
      *
      * @param request ModifyParameterGroupRequest
      * @return ModifyParameterGroupResponse
     */
    async modifyParameterGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyParameterGroupWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### [](#)Prerequisites
      * Before you call this operation, make sure that the following requirements are met:
      * *   The shared proxy feature is enabled for your ApsaraDB RDS for MySQL instance.
      * *   The read/write splitting feature is enabled for your ApsaraDB RDS for MySQL instance.
      * *   The instance must run one of the following database engine versions and RDS editions:
      *     *   MySQL 5.7 on RDS High-availability Edition with local disks
      *     *   MySQL 5.6
      *     *   SQL Server on RDS Cluster Edition
      *
      * @param request ModifyReadWriteSplittingConnectionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyReadWriteSplittingConnectionResponse
     */
    async modifyReadWriteSplittingConnectionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.connectionStringPrefix)) {
            query["ConnectionStringPrefix"] = request.connectionStringPrefix;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.distributionType)) {
            query["DistributionType"] = request.distributionType;
        }
        if (!tea_util_1.default.isUnset(request.maxDelayTime)) {
            query["MaxDelayTime"] = request.maxDelayTime;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.port)) {
            query["Port"] = request.port;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.weight)) {
            query["Weight"] = request.weight;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyReadWriteSplittingConnection",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyReadWriteSplittingConnectionResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### [](#)Prerequisites
      * Before you call this operation, make sure that the following requirements are met:
      * *   The shared proxy feature is enabled for your ApsaraDB RDS for MySQL instance.
      * *   The read/write splitting feature is enabled for your ApsaraDB RDS for MySQL instance.
      * *   The instance must run one of the following database engine versions and RDS editions:
      *     *   MySQL 5.7 on RDS High-availability Edition with local disks
      *     *   MySQL 5.6
      *     *   SQL Server on RDS Cluster Edition
      *
      * @param request ModifyReadWriteSplittingConnectionRequest
      * @return ModifyReadWriteSplittingConnectionResponse
     */
    async modifyReadWriteSplittingConnection(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyReadWriteSplittingConnectionWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * RDS MySQL
      * ### References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Set the data replication latency of a read-only ApsaraDB RDS for MySQL instance](~~96056~~)
      *
      * @param request ModifyReadonlyInstanceDelayReplicationTimeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyReadonlyInstanceDelayReplicationTimeResponse
     */
    async modifyReadonlyInstanceDelayReplicationTimeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.readSQLReplicationTime)) {
            query["ReadSQLReplicationTime"] = request.readSQLReplicationTime;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyReadonlyInstanceDelayReplicationTime",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyReadonlyInstanceDelayReplicationTimeResponse({}));
    }
    /**
      * ### Supported database engines
      * RDS MySQL
      * ### References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Set the data replication latency of a read-only ApsaraDB RDS for MySQL instance](~~96056~~)
      *
      * @param request ModifyReadonlyInstanceDelayReplicationTimeRequest
      * @return ModifyReadonlyInstanceDelayReplicationTimeResponse
     */
    async modifyReadonlyInstanceDelayReplicationTime(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyReadonlyInstanceDelayReplicationTimeWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Transfer resources across resource groups](~~94487~~)
      *
      * @param request ModifyResourceGroupRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyResourceGroupResponse
     */
    async modifyResourceGroupWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyResourceGroup",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyResourceGroupResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Transfer resources across resource groups](~~94487~~)
      *
      * @param request ModifyResourceGroupRequest
      * @return ModifyResourceGroupResponse
     */
    async modifyResourceGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyResourceGroupWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Use the SQL Explorer and Audit feature for an ApsaraDB RDS for MySQL instance](~~476574~~)
      * *   [Use the SQL Audit feature for an ApsaraDB RDS for PostgreSQL instance](~~96766~~)
      * *   [Use the SQL Audit feature for an ApsaraDB RDS for SQL Server instance](~~95712~~)
      *
      * @param request ModifySQLCollectorPolicyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifySQLCollectorPolicyResponse
     */
    async modifySQLCollectorPolicyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.SQLCollectorStatus)) {
            query["SQLCollectorStatus"] = request.SQLCollectorStatus;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifySQLCollectorPolicy",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifySQLCollectorPolicyResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Use the SQL Explorer and Audit feature for an ApsaraDB RDS for MySQL instance](~~476574~~)
      * *   [Use the SQL Audit feature for an ApsaraDB RDS for PostgreSQL instance](~~96766~~)
      * *   [Use the SQL Audit feature for an ApsaraDB RDS for SQL Server instance](~~95712~~)
      *
      * @param request ModifySQLCollectorPolicyRequest
      * @return ModifySQLCollectorPolicyResponse
     */
    async modifySQLCollectorPolicy(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifySQLCollectorPolicyWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * RDS MySQL
      * ### Precautions
      * After you shorten the log backup retention period, log backup files that are stored longer than the specified log backup retention period are immediately deleted.
      * ### References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Use the SQL Explorer and Audit feature](~~476574~~)
      *
      * @param request ModifySQLCollectorRetentionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifySQLCollectorRetentionResponse
     */
    async modifySQLCollectorRetentionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.configValue)) {
            query["ConfigValue"] = request.configValue;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifySQLCollectorRetention",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifySQLCollectorRetentionResponse({}));
    }
    /**
      * ### Supported database engines
      * RDS MySQL
      * ### Precautions
      * After you shorten the log backup retention period, log backup files that are stored longer than the specified log backup retention period are immediately deleted.
      * ### References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Use the SQL Explorer and Audit feature](~~476574~~)
      *
      * @param request ModifySQLCollectorRetentionRequest
      * @return ModifySQLCollectorRetentionResponse
     */
    async modifySQLCollectorRetention(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifySQLCollectorRetentionWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Configure a security group for an ApsaraDB RDS for MySQL instance](~~201042~~)
      * *   [Configure a security group for an ApsaraDB RDS for PostgreSQL instance](~~206310~~)
      * *   [Configure a security group for an ApsaraDB RDS for SQL Server instance](~~2392322~~)
      *
      * @param request ModifySecurityGroupConfigurationRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifySecurityGroupConfigurationResponse
     */
    async modifySecurityGroupConfigurationWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityGroupId)) {
            query["SecurityGroupId"] = request.securityGroupId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifySecurityGroupConfiguration",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifySecurityGroupConfigurationResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Configure a security group for an ApsaraDB RDS for MySQL instance](~~201042~~)
      * *   [Configure a security group for an ApsaraDB RDS for PostgreSQL instance](~~206310~~)
      * *   [Configure a security group for an ApsaraDB RDS for SQL Server instance](~~2392322~~)
      *
      * @param request ModifySecurityGroupConfigurationRequest
      * @return ModifySecurityGroupConfigurationResponse
     */
    async modifySecurityGroupConfiguration(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifySecurityGroupConfigurationWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Configure an IP address whitelist for an ApsaraDB RDS for MySQL instance](~~96118~~)
      * *   [Configure an IP address whitelist for an ApsaraDB RDS for PostgreSQL instance](~~43187~~)
      * *   [Configure an IP address whitelist for an ApsaraDB RDS for SQL Server instance](~~43186~~)
      * *   [Configure an IP address whitelist for an ApsaraDB RDS for MariaDB instance](~~90336~~)
      *
      * @param request ModifySecurityIpsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifySecurityIpsResponse
     */
    async modifySecurityIpsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceIPArrayAttribute)) {
            query["DBInstanceIPArrayAttribute"] = request.DBInstanceIPArrayAttribute;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceIPArrayName)) {
            query["DBInstanceIPArrayName"] = request.DBInstanceIPArrayName;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.freshWhiteListReadins)) {
            query["FreshWhiteListReadins"] = request.freshWhiteListReadins;
        }
        if (!tea_util_1.default.isUnset(request.modifyMode)) {
            query["ModifyMode"] = request.modifyMode;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityIPType)) {
            query["SecurityIPType"] = request.securityIPType;
        }
        if (!tea_util_1.default.isUnset(request.securityIps)) {
            query["SecurityIps"] = request.securityIps;
        }
        if (!tea_util_1.default.isUnset(request.whitelistNetworkType)) {
            query["WhitelistNetworkType"] = request.whitelistNetworkType;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifySecurityIps",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifySecurityIpsResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Configure an IP address whitelist for an ApsaraDB RDS for MySQL instance](~~96118~~)
      * *   [Configure an IP address whitelist for an ApsaraDB RDS for PostgreSQL instance](~~43187~~)
      * *   [Configure an IP address whitelist for an ApsaraDB RDS for SQL Server instance](~~43186~~)
      * *   [Configure an IP address whitelist for an ApsaraDB RDS for MariaDB instance](~~90336~~)
      *
      * @param request ModifySecurityIpsRequest
      * @return ModifySecurityIpsResponse
     */
    async modifySecurityIps(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifySecurityIpsWithOptions(request, runtime);
    }
    async modifyTaskInfoWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.actionParams)) {
            query["ActionParams"] = request.actionParams;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.securityToken)) {
            query["SecurityToken"] = request.securityToken;
        }
        if (!tea_util_1.default.isUnset(request.stepName)) {
            query["StepName"] = request.stepName;
        }
        if (!tea_util_1.default.isUnset(request.taskAction)) {
            query["TaskAction"] = request.taskAction;
        }
        if (!tea_util_1.default.isUnset(request.taskId)) {
            query["TaskId"] = request.taskId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyTaskInfo",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyTaskInfoResponse({}));
    }
    async modifyTaskInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyTaskInfoWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      *
      * @param request ModifyWhitelistTemplateRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ModifyWhitelistTemplateResponse
     */
    async modifyWhitelistTemplateWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ipWhitelist)) {
            query["IpWhitelist"] = request.ipWhitelist;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.templateId)) {
            query["TemplateId"] = request.templateId;
        }
        if (!tea_util_1.default.isUnset(request.templateName)) {
            query["TemplateName"] = request.templateName;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ModifyWhitelistTemplate",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyWhitelistTemplateResponse({}));
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      *
      * @param request ModifyWhitelistTemplateRequest
      * @return ModifyWhitelistTemplateResponse
     */
    async modifyWhitelistTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.modifyWhitelistTemplateWithOptions(request, runtime);
    }
    async preCheckCreateOrderForCreateDBNodesWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new PreCheckCreateOrderForCreateDBNodesShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.DBNode)) {
            request.DBNodeShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.DBNode, "DBNode", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.autoPay)) {
            query["AutoPay"] = request.autoPay;
        }
        if (!tea_util_1.default.isUnset(request.businessInfo)) {
            query["BusinessInfo"] = request.businessInfo;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.commodityCode)) {
            query["CommodityCode"] = request.commodityCode;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBNodeShrink)) {
            query["DBNode"] = request.DBNodeShrink;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.nodeType)) {
            query["NodeType"] = request.nodeType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.promotionCode)) {
            query["PromotionCode"] = request.promotionCode;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resource)) {
            query["Resource"] = request.resource;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "PreCheckCreateOrderForCreateDBNodes",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PreCheckCreateOrderForCreateDBNodesResponse({}));
    }
    async preCheckCreateOrderForCreateDBNodes(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.preCheckCreateOrderForCreateDBNodesWithOptions(request, runtime);
    }
    async preCheckCreateOrderForDeleteDBNodesWithOptions(tmpReq, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new PreCheckCreateOrderForDeleteDBNodesShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.DBNodeId)) {
            request.DBNodeIdShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.DBNodeId, "DBNodeId", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.autoPay)) {
            query["AutoPay"] = request.autoPay;
        }
        if (!tea_util_1.default.isUnset(request.businessInfo)) {
            query["BusinessInfo"] = request.businessInfo;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.commodityCode)) {
            query["CommodityCode"] = request.commodityCode;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBNodeIdShrink)) {
            query["DBNodeId"] = request.DBNodeIdShrink;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.nodeType)) {
            query["NodeType"] = request.nodeType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.promotionCode)) {
            query["PromotionCode"] = request.promotionCode;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resource)) {
            query["Resource"] = request.resource;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "PreCheckCreateOrderForDeleteDBNodes",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PreCheckCreateOrderForDeleteDBNodesResponse({}));
    }
    async preCheckCreateOrderForDeleteDBNodes(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.preCheckCreateOrderForDeleteDBNodesWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### Description
      * The system automatically uploads log backup files to Object Storage Service (OSS) buckets. If the remaining storage of an instance is insufficient, you can call this operation to upload the log backup files of the instance to OSS buckets. After the upload is complete, the system deletes these files from the instance to release storage. This operation is called to upload log backup files from an instance to OSS buckets and then delete these files from the instance. If the instance runs SQL Server, transaction log backup files are compressed before they are uploaded.
      * ### Precautions
      * *   When you upload log backup files, the data restoration feature is not affected.
      * *   This operation is called to release storage. The backup storage usage is not reduced.
      * *   The OSS buckets to which log backup files are uploaded are provided by the system. You do not need to purchase these OSS buckets. In addition, you cannot access these OSS buckets.
      *
      * @param request PurgeDBInstanceLogRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return PurgeDBInstanceLogResponse
     */
    async purgeDBInstanceLogWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "PurgeDBInstanceLog",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PurgeDBInstanceLogResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### Description
      * The system automatically uploads log backup files to Object Storage Service (OSS) buckets. If the remaining storage of an instance is insufficient, you can call this operation to upload the log backup files of the instance to OSS buckets. After the upload is complete, the system deletes these files from the instance to release storage. This operation is called to upload log backup files from an instance to OSS buckets and then delete these files from the instance. If the instance runs SQL Server, transaction log backup files are compressed before they are uploaded.
      * ### Precautions
      * *   When you upload log backup files, the data restoration feature is not affected.
      * *   This operation is called to release storage. The backup storage usage is not reduced.
      * *   The OSS buckets to which log backup files are uploaded are provided by the system. You do not need to purchase these OSS buckets. In addition, you cannot access these OSS buckets.
      *
      * @param request PurgeDBInstanceLogRequest
      * @return PurgeDBInstanceLogResponse
     */
    async purgeDBInstanceLog(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.purgeDBInstanceLogWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### Feature description
      * The notifications are highlighted at the top of the ApsaraDB RDS console. The notifications include renewal reminders and reminders of instance creation failures.
      * After you call this operation to query notifications, you can call the [ConfirmNotify](~~610444~~) operation to mark the notifications as confirmed, which means that you understand the content of the notifications.
      *
      * @param request QueryNotifyRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return QueryNotifyResponse
     */
    async queryNotifyWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.from)) {
            body["From"] = request.from;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            body["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.to)) {
            body["To"] = request.to;
        }
        if (!tea_util_1.default.isUnset(request.withConfirmed)) {
            body["WithConfirmed"] = request.withConfirmed;
        }
        let req = new $OpenApi.OpenApiRequest({
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryNotify",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryNotifyResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### Feature description
      * The notifications are highlighted at the top of the ApsaraDB RDS console. The notifications include renewal reminders and reminders of instance creation failures.
      * After you call this operation to query notifications, you can call the [ConfirmNotify](~~610444~~) operation to mark the notifications as confirmed, which means that you understand the content of the notifications.
      *
      * @param request QueryNotifyRequest
      * @return QueryNotifyResponse
     */
    async queryNotify(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryNotifyWithOptions(request, runtime);
    }
    async queryRecommendByCodeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.code)) {
            query["Code"] = request.code;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryRecommendByCode",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new QueryRecommendByCodeResponse({}));
    }
    async queryRecommendByCode(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.queryRecommendByCodeWithOptions(request, runtime);
    }
    /**
      * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
      *
      * @param request RebuildDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return RebuildDBInstanceResponse
     */
    async rebuildDBInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.dedicatedHostGroupId)) {
            query["DedicatedHostGroupId"] = request.dedicatedHostGroupId;
        }
        if (!tea_util_1.default.isUnset(request.dedicatedHostId)) {
            query["DedicatedHostId"] = request.dedicatedHostId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.rebuildNodeType)) {
            query["RebuildNodeType"] = request.rebuildNodeType;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RebuildDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RebuildDBInstanceResponse({}));
    }
    /**
      * Dedicated clusters allow you to manage a number of instances at a time. You can create multiple dedicated clusters in a single region. Each dedicated cluster consists of multiple hosts. You can create multiple instances on each host. For more information, see [What is ApsaraDB MyBase?](~~141455~~)
      *
      * @param request RebuildDBInstanceRequest
      * @return RebuildDBInstanceResponse
     */
    async rebuildDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.rebuildDBInstanceWithOptions(request, runtime);
    }
    /**
      * The operation is phased out.
      *
      * @param request ReceiveDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ReceiveDBInstanceResponse
     */
    async receiveDBInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.guardDBInstanceId)) {
            query["GuardDBInstanceId"] = request.guardDBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ReceiveDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ReceiveDBInstanceResponse({}));
    }
    /**
      * The operation is phased out.
      *
      * @param request ReceiveDBInstanceRequest
      * @return ReceiveDBInstanceResponse
     */
    async receiveDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.receiveDBInstanceWithOptions(request, runtime);
    }
    /**
      * You can call this operation to restore databases to a new instance or an existing instance. If you want to restore databases to an existing instance, we recommend that you call the [Copy databases](~~88810~~) operation.
      * If you want to restore databases to a new instance, you must create an instance and then restore specific or all databases to the new instance.
      * *   If you specify the name of a database, only the specified database is restored to the new instance.
      * *   If you do not specify the name of a database, all databases are restored to the new instance.
      * > This operation is supported only for instances that run SQL Server 2012 or later.
      *
      * @param request RecoveryDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return RecoveryDBInstanceResponse
     */
    async recoveryDBInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupId)) {
            query["BackupId"] = request.backupId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceClass)) {
            query["DBInstanceClass"] = request.DBInstanceClass;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorage)) {
            query["DBInstanceStorage"] = request.DBInstanceStorage;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorageType)) {
            query["DBInstanceStorageType"] = request.DBInstanceStorageType;
        }
        if (!tea_util_1.default.isUnset(request.dbNames)) {
            query["DbNames"] = request.dbNames;
        }
        if (!tea_util_1.default.isUnset(request.instanceNetworkType)) {
            query["InstanceNetworkType"] = request.instanceNetworkType;
        }
        if (!tea_util_1.default.isUnset(request.payType)) {
            query["PayType"] = request.payType;
        }
        if (!tea_util_1.default.isUnset(request.period)) {
            query["Period"] = request.period;
        }
        if (!tea_util_1.default.isUnset(request.privateIpAddress)) {
            query["PrivateIpAddress"] = request.privateIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.restoreTime)) {
            query["RestoreTime"] = request.restoreTime;
        }
        if (!tea_util_1.default.isUnset(request.targetDBInstanceId)) {
            query["TargetDBInstanceId"] = request.targetDBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.usedTime)) {
            query["UsedTime"] = request.usedTime;
        }
        if (!tea_util_1.default.isUnset(request.VPCId)) {
            query["VPCId"] = request.VPCId;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RecoveryDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RecoveryDBInstanceResponse({}));
    }
    /**
      * You can call this operation to restore databases to a new instance or an existing instance. If you want to restore databases to an existing instance, we recommend that you call the [Copy databases](~~88810~~) operation.
      * If you want to restore databases to a new instance, you must create an instance and then restore specific or all databases to the new instance.
      * *   If you specify the name of a database, only the specified database is restored to the new instance.
      * *   If you do not specify the name of a database, all databases are restored to the new instance.
      * > This operation is supported only for instances that run SQL Server 2012 or later.
      *
      * @param request RecoveryDBInstanceRequest
      * @return RecoveryDBInstanceResponse
     */
    async recoveryDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.recoveryDBInstanceWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * *   [Release the public endpoint of an ApsaraDB RDS for MySQL instance](~~26128~~)
      * *   [Release the public endpoint of an ApsaraDB RDS for PostgreSQL instance](~~97738~~)
      * *   [Release the public endpoint of an ApsaraDB RDS for SQL Server instance](~~97736~~)
      * *   [Release the public endpoint of an ApsaraDB RDS for MariaDB instance](~~97740~~)
      *
      * @param request ReleaseInstanceConnectionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ReleaseInstanceConnectionResponse
     */
    async releaseInstanceConnectionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentConnectionString)) {
            query["CurrentConnectionString"] = request.currentConnectionString;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.instanceNetworkType)) {
            query["InstanceNetworkType"] = request.instanceNetworkType;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ReleaseInstanceConnection",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ReleaseInstanceConnectionResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * *   [Release the public endpoint of an ApsaraDB RDS for MySQL instance](~~26128~~)
      * *   [Release the public endpoint of an ApsaraDB RDS for PostgreSQL instance](~~97738~~)
      * *   [Release the public endpoint of an ApsaraDB RDS for SQL Server instance](~~97736~~)
      * *   [Release the public endpoint of an ApsaraDB RDS for MariaDB instance](~~97740~~)
      *
      * @param request ReleaseInstanceConnectionRequest
      * @return ReleaseInstanceConnectionResponse
     */
    async releaseInstanceConnection(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.releaseInstanceConnectionWithOptions(request, runtime);
    }
    /**
      * To ensure data security, you can release the public endpoint when you do not need to access the database from the Internet.
      *
      * @param request ReleaseInstancePublicConnectionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ReleaseInstancePublicConnectionResponse
     */
    async releaseInstancePublicConnectionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentConnectionString)) {
            query["CurrentConnectionString"] = request.currentConnectionString;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ReleaseInstancePublicConnection",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ReleaseInstancePublicConnectionResponse({}));
    }
    /**
      * To ensure data security, you can release the public endpoint when you do not need to access the database from the Internet.
      *
      * @param request ReleaseInstancePublicConnectionRequest
      * @return ReleaseInstancePublicConnectionResponse
     */
    async releaseInstancePublicConnection(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.releaseInstancePublicConnectionWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### Prerequisites
      * Before you call this operation, make sure that the following requirements are met:
      * *   The shared proxy feature is enabled for your ApsaraDB RDS for MySQL instance.
      * *   The read/write splitting feature is enabled for the instance.
      * *   The instance must run one of the following database engine versions and RDS editions:
      *     *   MySQL 5.7 on RDS High-availability Edition (with local disks)
      *     *   MySQL 5.6
      *     *   SQL Server on RDS Cluster Edition
      *
      * @param request ReleaseReadWriteSplittingConnectionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ReleaseReadWriteSplittingConnectionResponse
     */
    async releaseReadWriteSplittingConnectionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ReleaseReadWriteSplittingConnection",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ReleaseReadWriteSplittingConnectionResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### Prerequisites
      * Before you call this operation, make sure that the following requirements are met:
      * *   The shared proxy feature is enabled for your ApsaraDB RDS for MySQL instance.
      * *   The read/write splitting feature is enabled for the instance.
      * *   The instance must run one of the following database engine versions and RDS editions:
      *     *   MySQL 5.7 on RDS High-availability Edition (with local disks)
      *     *   MySQL 5.6
      *     *   SQL Server on RDS Cluster Edition
      *
      * @param request ReleaseReadWriteSplittingConnectionRequest
      * @return ReleaseReadWriteSplittingConnectionResponse
     */
    async releaseReadWriteSplittingConnection(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.releaseReadWriteSplittingConnectionWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)Usage notes
      * *   A maximum of 10 tags can be removed in a single request.
      * *   If a tag is removed from all instances to which the tag is added, the tag is automatically deleted.
      * *   If you specify only TagKey, all tags that match the TagKey condition are removed.
      * *   You must specify at least TagKey or a pair of TagKey and TagValue.
      *
      * @param request RemoveTagsFromResourceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return RemoveTagsFromResourceResponse
     */
    async removeTagsFromResourceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            query["Tags"] = request.tags;
        }
        if (!tea_util_1.default.isUnset(request.proxyId)) {
            query["proxyId"] = request.proxyId;
        }
        if (!tea_util_1.default.isUnset(request.tag)) {
            query["Tag"] = request.tag;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RemoveTagsFromResource",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RemoveTagsFromResourceResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)Usage notes
      * *   A maximum of 10 tags can be removed in a single request.
      * *   If a tag is removed from all instances to which the tag is added, the tag is automatically deleted.
      * *   If you specify only TagKey, all tags that match the TagKey condition are removed.
      * *   You must specify at least TagKey or a pair of TagKey and TagValue.
      *
      * @param request RemoveTagsFromResourceRequest
      * @return RemoveTagsFromResourceResponse
     */
    async removeTagsFromResource(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.removeTagsFromResourceWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * >  Fees of an instance are changed if the call is successful. Before you call this operation, carefully read the following topics:
      * *   [Manually renew an ApsaraDB RDS for MySQL instance](~~96050~~)
      * *   [Manually renew an ApsaraDB RDS for PostgreSQL instance](~~96741~~)
      * *   [Manually renew an ApsaraDB RDS for SQL Server instance](~~95637~~)
      * *   [Manually renew an ApsaraDB RDS for MariaDB instance](~~97122~~)
      *
      * @param request RenewInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return RenewInstanceResponse
     */
    async renewInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.autoPay)) {
            query["AutoPay"] = request.autoPay;
        }
        if (!tea_util_1.default.isUnset(request.autoRenew)) {
            query["AutoRenew"] = request.autoRenew;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.period)) {
            query["Period"] = request.period;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RenewInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RenewInstanceResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * >  Fees of an instance are changed if the call is successful. Before you call this operation, carefully read the following topics:
      * *   [Manually renew an ApsaraDB RDS for MySQL instance](~~96050~~)
      * *   [Manually renew an ApsaraDB RDS for PostgreSQL instance](~~96741~~)
      * *   [Manually renew an ApsaraDB RDS for SQL Server instance](~~95637~~)
      * *   [Manually renew an ApsaraDB RDS for MariaDB instance](~~97122~~)
      *
      * @param request RenewInstanceRequest
      * @return RenewInstanceResponse
     */
    async renewInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.renewInstanceWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Reset of the permissions of privileged accounts](~~140724~~)
      *
      * @param request ResetAccountRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ResetAccountResponse
     */
    async resetAccountWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountName)) {
            query["AccountName"] = request.accountName;
        }
        if (!tea_util_1.default.isUnset(request.accountPassword)) {
            query["AccountPassword"] = request.accountPassword;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ResetAccount",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ResetAccountResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Reset of the permissions of privileged accounts](~~140724~~)
      *
      * @param request ResetAccountRequest
      * @return ResetAccountResponse
     */
    async resetAccount(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.resetAccountWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Reset the password of an ApsaraDB RDS for MySQL instance](~~96100~~)
      * *   [Reset the password of an ApsaraDB RDS for PostgreSQL instance](~~96814~~)
      * *   [Reset the password of an ApsaraDB RDS for SQL Server instance](~~95691~~)
      * *   [Reset the password of an ApsaraDB RDS for MariaDB instance](~~97133~~)
      *
      * @param request ResetAccountPasswordRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return ResetAccountPasswordResponse
     */
    async resetAccountPasswordWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountName)) {
            query["AccountName"] = request.accountName;
        }
        if (!tea_util_1.default.isUnset(request.accountPassword)) {
            query["AccountPassword"] = request.accountPassword;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ResetAccountPassword",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ResetAccountPasswordResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Reset the password of an ApsaraDB RDS for MySQL instance](~~96100~~)
      * *   [Reset the password of an ApsaraDB RDS for PostgreSQL instance](~~96814~~)
      * *   [Reset the password of an ApsaraDB RDS for SQL Server instance](~~95691~~)
      * *   [Reset the password of an ApsaraDB RDS for MariaDB instance](~~97133~~)
      *
      * @param request ResetAccountPasswordRequest
      * @return ResetAccountPasswordResponse
     */
    async resetAccountPassword(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.resetAccountPasswordWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      * ### References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Restart an ApsaraDB RDS for MySQL instance](~~96051~~)
      * *   [Restart an ApsaraDB RDS for PostgreSQL instance](~~96798~~)
      * *   [Restart an ApsaraDB RDS for SQL Server instance](~~95656~~)
      * *   [Restart an ApsaraDB RDS for MariaDB instance](~~97472~~)
      *
      * @param request RestartDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return RestartDBInstanceResponse
     */
    async restartDBInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.nodeId)) {
            query["NodeId"] = request.nodeId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RestartDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RestartDBInstanceResponse({}));
    }
    /**
      * ### Supported database engines
      * *   RDS MySQL
      * *   RDS PostgreSQL
      * *   RDS SQL Server
      * *   RDS MariaDB
      * ### References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Restart an ApsaraDB RDS for MySQL instance](~~96051~~)
      * *   [Restart an ApsaraDB RDS for PostgreSQL instance](~~96798~~)
      * *   [Restart an ApsaraDB RDS for SQL Server instance](~~95656~~)
      * *   [Restart an ApsaraDB RDS for MariaDB instance](~~97472~~)
      *
      * @param request RestartDBInstanceRequest
      * @return RestartDBInstanceResponse
     */
    async restartDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.restartDBInstanceWithOptions(request, runtime);
    }
    /**
      * >  Before restoration, you can call the [CheckCreateDdrDBInstance](~~121721~~) operation to check whether a cross-region backup set can be used for cross-region restoration.
      * ### [](#)Supported database engine
      * MySQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~)
      * *   [Restore the data of an ApsaraDB RDS for MySQL instance across regions](~~120875~~)
      *
      * @param request RestoreDdrTableRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return RestoreDdrTableResponse
     */
    async restoreDdrTableWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupId)) {
            query["BackupId"] = request.backupId;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.restoreTime)) {
            query["RestoreTime"] = request.restoreTime;
        }
        if (!tea_util_1.default.isUnset(request.restoreType)) {
            query["RestoreType"] = request.restoreType;
        }
        if (!tea_util_1.default.isUnset(request.sourceDBInstanceName)) {
            query["SourceDBInstanceName"] = request.sourceDBInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.sourceRegion)) {
            query["SourceRegion"] = request.sourceRegion;
        }
        if (!tea_util_1.default.isUnset(request.tableMeta)) {
            query["TableMeta"] = request.tableMeta;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RestoreDdrTable",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RestoreDdrTableResponse({}));
    }
    /**
      * >  Before restoration, you can call the [CheckCreateDdrDBInstance](~~121721~~) operation to check whether a cross-region backup set can be used for cross-region restoration.
      * ### [](#)Supported database engine
      * MySQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Back up an ApsaraDB RDS for MySQL instance across regions](~~120824~~)
      * *   [Restore the data of an ApsaraDB RDS for MySQL instance across regions](~~120875~~)
      *
      * @param request RestoreDdrTableRequest
      * @return RestoreDdrTableResponse
     */
    async restoreDdrTable(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.restoreDdrTableWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * MySQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Restore individual databases and tables](~~103175~~)
      *
      * @param request RestoreTableRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return RestoreTableResponse
     */
    async restoreTableWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupId)) {
            query["BackupId"] = request.backupId;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.instantRecovery)) {
            query["InstantRecovery"] = request.instantRecovery;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.restoreTime)) {
            query["RestoreTime"] = request.restoreTime;
        }
        if (!tea_util_1.default.isUnset(request.tableMeta)) {
            query["TableMeta"] = request.tableMeta;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RestoreTable",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RestoreTableResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * MySQL
      * ### [](#)References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Restore individual databases and tables](~~103175~~)
      *
      * @param request RestoreTableRequest
      * @return RestoreTableResponse
     */
    async restoreTable(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.restoreTableWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)Prerequisites
      * *   The instance is in the Running state.
      * *   The database is in the Running state.
      * ### [](#)Precautions
      * *   The permissions that can be revoked include SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, REFERENCES, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, EVENT, and TRIGGER.
      * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition and run PostgreSQL.
      *
      * @param request RevokeAccountPrivilegeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return RevokeAccountPrivilegeResponse
     */
    async revokeAccountPrivilegeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountName)) {
            query["AccountName"] = request.accountName;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBName)) {
            query["DBName"] = request.DBName;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RevokeAccountPrivilege",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RevokeAccountPrivilegeResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)Prerequisites
      * *   The instance is in the Running state.
      * *   The database is in the Running state.
      * ### [](#)Precautions
      * *   The permissions that can be revoked include SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, REFERENCES, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, EVENT, and TRIGGER.
      * *   This operation is not supported for instances that run SQL Server 2017 on RDS Cluster Edition and run PostgreSQL.
      *
      * @param request RevokeAccountPrivilegeRequest
      * @return RevokeAccountPrivilegeResponse
     */
    async revokeAccountPrivilege(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.revokeAccountPrivilegeWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Grant permissions to the service account of an ApsaraDB RDS for MySQL instance](~~96102~~)
      * *   [Grant permissions to the service account of an ApsaraDB RDS for PostgreSQL instance](~~146887~~)
      * *   [Grant permissions to the service account of an ApsaraDB RDS for SQL Server instance](~~95693~~)
      *
      * @param request RevokeOperatorPermissionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return RevokeOperatorPermissionResponse
     */
    async revokeOperatorPermissionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RevokeOperatorPermission",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RevokeOperatorPermissionResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Grant permissions to the service account of an ApsaraDB RDS for MySQL instance](~~96102~~)
      * *   [Grant permissions to the service account of an ApsaraDB RDS for PostgreSQL instance](~~146887~~)
      * *   [Grant permissions to the service account of an ApsaraDB RDS for SQL Server instance](~~95693~~)
      *
      * @param request RevokeOperatorPermissionRequest
      * @return RevokeOperatorPermissionResponse
     */
    async revokeOperatorPermission(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.revokeOperatorPermissionWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
      * *   [Resume an ApsaraDB RDS for MySQL instance](~~427093~~)
      * *   [Resume an ApsaraDB RDS for PostgreSQL instance](~~452314~~)
      * *   [Resume an ApsaraDB RDS for SQL Server instance](~~462504~~)
      *
      * @param request StartDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return StartDBInstanceResponse
     */
    async startDBInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceTransType)) {
            query["DBInstanceTransType"] = request.DBInstanceTransType;
        }
        if (!tea_util_1.default.isUnset(request.dedicatedHostGroupId)) {
            query["DedicatedHostGroupId"] = request.dedicatedHostGroupId;
        }
        if (!tea_util_1.default.isUnset(request.effectiveTime)) {
            query["EffectiveTime"] = request.effectiveTime;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.specifiedTime)) {
            query["SpecifiedTime"] = request.specifiedTime;
        }
        if (!tea_util_1.default.isUnset(request.storage)) {
            query["Storage"] = request.storage;
        }
        if (!tea_util_1.default.isUnset(request.targetDBInstanceClass)) {
            query["TargetDBInstanceClass"] = request.targetDBInstanceClass;
        }
        if (!tea_util_1.default.isUnset(request.targetDedicatedHostIdForLog)) {
            query["TargetDedicatedHostIdForLog"] = request.targetDedicatedHostIdForLog;
        }
        if (!tea_util_1.default.isUnset(request.targetDedicatedHostIdForMaster)) {
            query["TargetDedicatedHostIdForMaster"] = request.targetDedicatedHostIdForMaster;
        }
        if (!tea_util_1.default.isUnset(request.targetDedicatedHostIdForSlave)) {
            query["TargetDedicatedHostIdForSlave"] = request.targetDedicatedHostIdForSlave;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "StartDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new StartDBInstanceResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation:
      * *   [Resume an ApsaraDB RDS for MySQL instance](~~427093~~)
      * *   [Resume an ApsaraDB RDS for PostgreSQL instance](~~452314~~)
      * *   [Resume an ApsaraDB RDS for SQL Server instance](~~462504~~)
      *
      * @param request StartDBInstanceRequest
      * @return StartDBInstanceResponse
     */
    async startDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.startDBInstanceWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Suspend an ApsaraDB RDS for MySQL instance](~~427093~~)
      * *   [Suspend an ApsaraDB RDS for PostgreSQL instance](~~452314~~)
      * *   [Suspend an ApsaraDB RDS for SQL Server instance](~~462504~~)
      *
      * @param request StopDBInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return StopDBInstanceResponse
     */
    async stopDBInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "StopDBInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new StopDBInstanceResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Suspend an ApsaraDB RDS for MySQL instance](~~427093~~)
      * *   [Suspend an ApsaraDB RDS for PostgreSQL instance](~~452314~~)
      * *   [Suspend an ApsaraDB RDS for SQL Server instance](~~462504~~)
      *
      * @param request StopDBInstanceRequest
      * @return StopDBInstanceResponse
     */
    async stopDBInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.stopDBInstanceWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Switch workloads between primary and secondary ApsaraDB RDS for MySQL instances](~~96054~~)
      * *   [Switch workloads between primary and secondary ApsaraDB RDS for PostgreSQL instances](~~96747~~)
      * *   [Switch workloads between primary and secondary ApsaraDB RDS for SQL Server instances](~~95659~~)
      * *   [Switch workloads between primary and secondary ApsaraDB RDS for MariaDB instances](~~97127~~)
      *
      * @param request SwitchDBInstanceHARequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return SwitchDBInstanceHAResponse
     */
    async switchDBInstanceHAWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.effectiveTime)) {
            query["EffectiveTime"] = request.effectiveTime;
        }
        if (!tea_util_1.default.isUnset(request.force)) {
            query["Force"] = request.force;
        }
        if (!tea_util_1.default.isUnset(request.nodeId)) {
            query["NodeId"] = request.nodeId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SwitchDBInstanceHA",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SwitchDBInstanceHAResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Switch workloads between primary and secondary ApsaraDB RDS for MySQL instances](~~96054~~)
      * *   [Switch workloads between primary and secondary ApsaraDB RDS for PostgreSQL instances](~~96747~~)
      * *   [Switch workloads between primary and secondary ApsaraDB RDS for SQL Server instances](~~95659~~)
      * *   [Switch workloads between primary and secondary ApsaraDB RDS for MariaDB instances](~~97127~~)
      *
      * @param request SwitchDBInstanceHARequest
      * @return SwitchDBInstanceHAResponse
     */
    async switchDBInstanceHA(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.switchDBInstanceHAWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### Prerequisites
      * *   The instance is connected by using its internal or public endpoint.
      * *   The instance is in the Running state.
      * *   The number of times that you have switched the instance between its internal and public endpoints within the last 24 hours does not reach 20.
      * *   The instance resides in the classic network.
      * ### Usage notes
      * After the endpoint that is used to connect to the instance is changed, you must update the endpoint information in the code of your application and restart the application.
      *
      * @param request SwitchDBInstanceNetTypeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return SwitchDBInstanceNetTypeResponse
     */
    async switchDBInstanceNetTypeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.connectionStringPrefix)) {
            query["ConnectionStringPrefix"] = request.connectionStringPrefix;
        }
        if (!tea_util_1.default.isUnset(request.connectionStringType)) {
            query["ConnectionStringType"] = request.connectionStringType;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.port)) {
            query["Port"] = request.port;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SwitchDBInstanceNetType",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SwitchDBInstanceNetTypeResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   SQL Server
      * ### Prerequisites
      * *   The instance is connected by using its internal or public endpoint.
      * *   The instance is in the Running state.
      * *   The number of times that you have switched the instance between its internal and public endpoints within the last 24 hours does not reach 20.
      * *   The instance resides in the classic network.
      * ### Usage notes
      * After the endpoint that is used to connect to the instance is changed, you must update the endpoint information in the code of your application and restart the application.
      *
      * @param request SwitchDBInstanceNetTypeRequest
      * @return SwitchDBInstanceNetTypeResponse
     */
    async switchDBInstanceNetType(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.switchDBInstanceNetTypeWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Change the VPC and vSwitch for an ApsaraDB RDS for MySQL instance](~~137567~~)
      * *   [Change the vSwitch for an ApsaraDB RDS for PostgreSQL instance](~~146885~~)
      * *   [Change the VPC and vSwitch for an ApsaraDB RDS for SQL Server instance](~~347675~~)
      *
      * @param request SwitchDBInstanceVpcRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return SwitchDBInstanceVpcResponse
     */
    async switchDBInstanceVpcWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.privateIpAddress)) {
            query["PrivateIpAddress"] = request.privateIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.VPCId)) {
            query["VPCId"] = request.VPCId;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SwitchDBInstanceVpc",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SwitchDBInstanceVpcResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Change the VPC and vSwitch for an ApsaraDB RDS for MySQL instance](~~137567~~)
      * *   [Change the vSwitch for an ApsaraDB RDS for PostgreSQL instance](~~146885~~)
      * *   [Change the VPC and vSwitch for an ApsaraDB RDS for SQL Server instance](~~347675~~)
      *
      * @param request SwitchDBInstanceVpcRequest
      * @return SwitchDBInstanceVpcResponse
     */
    async switchDBInstanceVpc(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.switchDBInstanceVpcWithOptions(request, runtime);
    }
    /**
      * This operation is phased out.
      *
      * @param request SwitchGuardToMasterInstanceRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return SwitchGuardToMasterInstanceResponse
     */
    async switchGuardToMasterInstanceWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SwitchGuardToMasterInstance",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SwitchGuardToMasterInstanceResponse({}));
    }
    /**
      * This operation is phased out.
      *
      * @param request SwitchGuardToMasterInstanceRequest
      * @return SwitchGuardToMasterInstanceResponse
     */
    async switchGuardToMasterInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.switchGuardToMasterInstanceWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Create tags for an ApsaraDB RDS for MySQL instance](~~96149~~)
      * *   [Create tags for an ApsaraDB RDS for PostgreSQL instance](~~96777~~)
      * *   [Create tags for an ApsaraDB RDS for SQL Server instance](~~95726~~)
      * *   [Create tags for an ApsaraDB RDS for MariaDB instance](~~97152~~)
      *
      * @param request TagResourcesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return TagResourcesResponse
     */
    async tagResourcesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceId)) {
            query["ResourceId"] = request.resourceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.tag)) {
            query["Tag"] = request.tag;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "TagResources",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new TagResourcesResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * *   [Create tags for an ApsaraDB RDS for MySQL instance](~~96149~~)
      * *   [Create tags for an ApsaraDB RDS for PostgreSQL instance](~~96777~~)
      * *   [Create tags for an ApsaraDB RDS for SQL Server instance](~~95726~~)
      * *   [Create tags for an ApsaraDB RDS for MariaDB instance](~~97152~~)
      *
      * @param request TagResourcesRequest
      * @return TagResourcesResponse
     */
    async tagResources(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.tagResourcesWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   SQL Server
      *
      * @param request TerminateMigrateTaskRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return TerminateMigrateTaskResponse
     */
    async terminateMigrateTaskWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.migrateTaskId)) {
            query["MigrateTaskId"] = request.migrateTaskId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "TerminateMigrateTask",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new TerminateMigrateTaskResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   SQL Server
      *
      * @param request TerminateMigrateTaskRequest
      * @return TerminateMigrateTaskResponse
     */
    async terminateMigrateTask(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.terminateMigrateTaskWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Fees are generated if the call is successful. Before you call this operation, you must read the following documentation.
      * *   [Change the billing method of an ApsaraDB RDS for MySQL instance from pay-as-you-go to subscription](~~96048~~) or [Change the billing method of an ApsaraDB RDS for MySQL instance from subscription to pay-as-you-go](~~161875~~)
      * *   [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from pay-as-you-go to subscription](~~96743~~) or [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from subscription to pay-as-you-go](~~162756~~)
      * *   [Change the billing method of an ApsaraDB RDS for SQL Server instance from pay-as-you-go to subscription](~~95631~~) or [Change the billing method of an ApsaraDB RDS for SQL Server instance from subscription to pay-as-you-go](~~162755~~)
      * *   [Change the billing method of an ApsaraDB RDS for MariaDB instance from pay-as-you-go to subscription](~~97120~~) or [Change the billing method of an ApsaraDB RDS for MariaDB instance from subscription to pay-as-you-go](~~169252~~)
      *
      * @param request TransformDBInstancePayTypeRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return TransformDBInstancePayTypeResponse
     */
    async transformDBInstancePayTypeWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.autoRenew)) {
            query["AutoRenew"] = request.autoRenew;
        }
        if (!tea_util_1.default.isUnset(request.businessInfo)) {
            query["BusinessInfo"] = request.businessInfo;
        }
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.payType)) {
            query["PayType"] = request.payType;
        }
        if (!tea_util_1.default.isUnset(request.period)) {
            query["Period"] = request.period;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.usedTime)) {
            query["UsedTime"] = request.usedTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "TransformDBInstancePayType",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new TransformDBInstancePayTypeResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### References
      * > Fees are generated if the call is successful. Before you call this operation, you must read the following documentation.
      * *   [Change the billing method of an ApsaraDB RDS for MySQL instance from pay-as-you-go to subscription](~~96048~~) or [Change the billing method of an ApsaraDB RDS for MySQL instance from subscription to pay-as-you-go](~~161875~~)
      * *   [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from pay-as-you-go to subscription](~~96743~~) or [Change the billing method of an ApsaraDB RDS for PostgreSQL instance from subscription to pay-as-you-go](~~162756~~)
      * *   [Change the billing method of an ApsaraDB RDS for SQL Server instance from pay-as-you-go to subscription](~~95631~~) or [Change the billing method of an ApsaraDB RDS for SQL Server instance from subscription to pay-as-you-go](~~162755~~)
      * *   [Change the billing method of an ApsaraDB RDS for MariaDB instance from pay-as-you-go to subscription](~~97120~~) or [Change the billing method of an ApsaraDB RDS for MariaDB instance from subscription to pay-as-you-go](~~169252~~)
      *
      * @param request TransformDBInstancePayTypeRequest
      * @return TransformDBInstancePayTypeResponse
     */
    async transformDBInstancePayType(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.transformDBInstancePayTypeWithOptions(request, runtime);
    }
    /**
      * ### Supported database engine
      * PostgreSQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Lock an account of an ApsaraDB RDS for PostgreSQL instance](~~147649~~)
      *
      * @param request UnlockAccountRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UnlockAccountResponse
     */
    async unlockAccountWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountName)) {
            query["AccountName"] = request.accountName;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UnlockAccount",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UnlockAccountResponse({}));
    }
    /**
      * ### Supported database engine
      * PostgreSQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Lock an account of an ApsaraDB RDS for PostgreSQL instance](~~147649~~)
      *
      * @param request UnlockAccountRequest
      * @return UnlockAccountResponse
     */
    async unlockAccount(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.unlockAccountWithOptions(request, runtime);
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)Usage notes
      * *   You can remove up to 20 tags at a time.
      * *   If a tag is removed from an instance and is not added to other instances, the tag is automatically deleted.
      *
      * @param request UntagResourcesRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UntagResourcesResponse
     */
    async untagResourcesWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.all)) {
            query["All"] = request.all;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceId)) {
            query["ResourceId"] = request.resourceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            query["ResourceType"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.tagKey)) {
            query["TagKey"] = request.tagKey;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UntagResources",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UntagResourcesResponse({}));
    }
    /**
      * ### [](#)Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * *   MariaDB
      * ### [](#)Usage notes
      * *   You can remove up to 20 tags at a time.
      * *   If a tag is removed from an instance and is not added to other instances, the tag is automatically deleted.
      *
      * @param request UntagResourcesRequest
      * @return UntagResourcesResponse
     */
    async untagResources(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.untagResourcesWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * RDS PostgreSQL
      * ### References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Manage extensions](~~2402409~~)
      *
      * @param request UpdatePostgresExtensionsRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdatePostgresExtensionsResponse
     */
    async updatePostgresExtensionsWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBNames)) {
            query["DBNames"] = request.DBNames;
        }
        if (!tea_util_1.default.isUnset(request.extensions)) {
            query["Extensions"] = request.extensions;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdatePostgresExtensions",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdatePostgresExtensionsResponse({}));
    }
    /**
      * ### Supported database engines
      * RDS PostgreSQL
      * ### References
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Manage extensions](~~2402409~~)
      *
      * @param request UpdatePostgresExtensionsRequest
      * @return UpdatePostgresExtensionsResponse
     */
    async updatePostgresExtensions(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updatePostgresExtensionsWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * RDS MySQL
      * ### References
      * A full backup file contains the data of a self-managed MySQL database. You can restore the data of a self-managed MySQL database from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 or MySQL 8.0 instance to an ApsaraDB RDS for MySQL instance](~~251779~~).
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      *
      * @param request UpdateUserBackupFileRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpdateUserBackupFileResponse
     */
    async updateUserBackupFileWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.backupId)) {
            query["BackupId"] = request.backupId;
        }
        if (!tea_util_1.default.isUnset(request.comment)) {
            query["Comment"] = request.comment;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["RegionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            query["ResourceGroupId"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.retention)) {
            query["Retention"] = request.retention;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateUserBackupFile",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateUserBackupFileResponse({}));
    }
    /**
      * ### Supported database engines
      * RDS MySQL
      * ### References
      * A full backup file contains the data of a self-managed MySQL database. You can restore the data of a self-managed MySQL database from a full backup file to an ApsaraDB RDS for MySQL instance. For more information, see [Migrate the data of a self-managed MySQL 5.7 or MySQL 8.0 instance to an ApsaraDB RDS for MySQL instance](~~251779~~).
      * > : Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      *
      * @param request UpdateUserBackupFileRequest
      * @return UpdateUserBackupFileResponse
     */
    async updateUserBackupFile(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.updateUserBackupFileWithOptions(request, runtime);
    }
    /**
      * ### Supported database engine
      * MySQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Upgrade the major engine version of an ApsaraDB RDS for MySQL instance](~~96058~~)
      *
      * @param request UpgradeDBInstanceEngineVersionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpgradeDBInstanceEngineVersionResponse
     */
    async upgradeDBInstanceEngineVersionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clientToken)) {
            query["ClientToken"] = request.clientToken;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.effectiveTime)) {
            query["EffectiveTime"] = request.effectiveTime;
        }
        if (!tea_util_1.default.isUnset(request.engineVersion)) {
            query["EngineVersion"] = request.engineVersion;
        }
        if (!tea_util_1.default.isUnset(request.ownerAccount)) {
            query["OwnerAccount"] = request.ownerAccount;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpgradeDBInstanceEngineVersion",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpgradeDBInstanceEngineVersionResponse({}));
    }
    /**
      * ### Supported database engine
      * MySQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * [Upgrade the major engine version of an ApsaraDB RDS for MySQL instance](~~96058~~)
      *
      * @param request UpgradeDBInstanceEngineVersionRequest
      * @return UpgradeDBInstanceEngineVersionResponse
     */
    async upgradeDBInstanceEngineVersion(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.upgradeDBInstanceEngineVersionWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Update the minor engine version of an ApsaraDB RDS for MySQL instance](~~96059~~)
      * *   [Update the minor engine version of an ApsaraDB RDS for PostgreSQL instance](~~146895~~)
      * *   [Update the minor engine version of an ApsaraDB RDS for SQL Server instance](~~213582~~)
      *
      * @param request UpgradeDBInstanceKernelVersionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpgradeDBInstanceKernelVersionResponse
     */
    async upgradeDBInstanceKernelVersionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.switchTime)) {
            query["SwitchTime"] = request.switchTime;
        }
        if (!tea_util_1.default.isUnset(request.targetMinorVersion)) {
            query["TargetMinorVersion"] = request.targetMinorVersion;
        }
        if (!tea_util_1.default.isUnset(request.upgradeTime)) {
            query["UpgradeTime"] = request.upgradeTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpgradeDBInstanceKernelVersion",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpgradeDBInstanceKernelVersionResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * *   SQL Server
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Update the minor engine version of an ApsaraDB RDS for MySQL instance](~~96059~~)
      * *   [Update the minor engine version of an ApsaraDB RDS for PostgreSQL instance](~~146895~~)
      * *   [Update the minor engine version of an ApsaraDB RDS for SQL Server instance](~~213582~~)
      *
      * @param request UpgradeDBInstanceKernelVersionRequest
      * @return UpgradeDBInstanceKernelVersionResponse
     */
    async upgradeDBInstanceKernelVersion(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.upgradeDBInstanceKernelVersionWithOptions(request, runtime);
    }
    /**
      * ### Supported database engine
      * PostgreSQL
      * ### References
      * Fees are generated if the call is successful. Before you call this operation, read the following documentation and make sure that you fully understand the billing rules, prerequisites, and impacts of this operation.
      * [Upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance](~~203309~~)
      *
      * @param request UpgradeDBInstanceMajorVersionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpgradeDBInstanceMajorVersionResponse
     */
    async upgradeDBInstanceMajorVersionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.collectStatMode)) {
            query["CollectStatMode"] = request.collectStatMode;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceClass)) {
            query["DBInstanceClass"] = request.DBInstanceClass;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorage)) {
            query["DBInstanceStorage"] = request.DBInstanceStorage;
        }
        if (!tea_util_1.default.isUnset(request.DBInstanceStorageType)) {
            query["DBInstanceStorageType"] = request.DBInstanceStorageType;
        }
        if (!tea_util_1.default.isUnset(request.instanceNetworkType)) {
            query["InstanceNetworkType"] = request.instanceNetworkType;
        }
        if (!tea_util_1.default.isUnset(request.payType)) {
            query["PayType"] = request.payType;
        }
        if (!tea_util_1.default.isUnset(request.period)) {
            query["Period"] = request.period;
        }
        if (!tea_util_1.default.isUnset(request.privateIpAddress)) {
            query["PrivateIpAddress"] = request.privateIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.switchOver)) {
            query["SwitchOver"] = request.switchOver;
        }
        if (!tea_util_1.default.isUnset(request.switchTime)) {
            query["SwitchTime"] = request.switchTime;
        }
        if (!tea_util_1.default.isUnset(request.switchTimeMode)) {
            query["SwitchTimeMode"] = request.switchTimeMode;
        }
        if (!tea_util_1.default.isUnset(request.targetMajorVersion)) {
            query["TargetMajorVersion"] = request.targetMajorVersion;
        }
        if (!tea_util_1.default.isUnset(request.usedTime)) {
            query["UsedTime"] = request.usedTime;
        }
        if (!tea_util_1.default.isUnset(request.VPCId)) {
            query["VPCId"] = request.VPCId;
        }
        if (!tea_util_1.default.isUnset(request.vSwitchId)) {
            query["VSwitchId"] = request.vSwitchId;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            query["ZoneId"] = request.zoneId;
        }
        if (!tea_util_1.default.isUnset(request.zoneIdSlave1)) {
            query["ZoneIdSlave1"] = request.zoneIdSlave1;
        }
        if (!tea_util_1.default.isUnset(request.zoneIdSlave2)) {
            query["ZoneIdSlave2"] = request.zoneIdSlave2;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpgradeDBInstanceMajorVersion",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpgradeDBInstanceMajorVersionResponse({}));
    }
    /**
      * ### Supported database engine
      * PostgreSQL
      * ### References
      * Fees are generated if the call is successful. Before you call this operation, read the following documentation and make sure that you fully understand the billing rules, prerequisites, and impacts of this operation.
      * [Upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance](~~203309~~)
      *
      * @param request UpgradeDBInstanceMajorVersionRequest
      * @return UpgradeDBInstanceMajorVersionResponse
     */
    async upgradeDBInstanceMajorVersion(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.upgradeDBInstanceMajorVersionWithOptions(request, runtime);
    }
    /**
      * ### Supported database engine
      * PostgreSQL
      * ### References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance](~~203309~~)
      *
      * @param request UpgradeDBInstanceMajorVersionPrecheckRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpgradeDBInstanceMajorVersionPrecheckResponse
     */
    async upgradeDBInstanceMajorVersionPrecheckWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.targetMajorVersion)) {
            query["TargetMajorVersion"] = request.targetMajorVersion;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpgradeDBInstanceMajorVersionPrecheck",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpgradeDBInstanceMajorVersionPrecheckResponse({}));
    }
    /**
      * ### Supported database engine
      * PostgreSQL
      * ### References
      * > Before you call this operation, carefully read the following documentation. Make sure that you fully understand the prerequisites and impacts for calling this operation.
      * [Upgrade the major engine version of an ApsaraDB RDS for PostgreSQL instance](~~203309~~)
      *
      * @param request UpgradeDBInstanceMajorVersionPrecheckRequest
      * @return UpgradeDBInstanceMajorVersionPrecheckResponse
     */
    async upgradeDBInstanceMajorVersionPrecheck(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.upgradeDBInstanceMajorVersionPrecheckWithOptions(request, runtime);
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Upgrade the dedicated proxy version of an ApsaraDB RDS for MySQL instance](~~197465~~)
      * *   [Upgrade the dedicated proxy version of an ApsaraDB RDS for PostgreSQL instance](~~418469~~)
      *
      * @param request UpgradeDBProxyInstanceKernelVersionRequest
      * @param runtime runtime options for this request RuntimeOptions
      * @return UpgradeDBProxyInstanceKernelVersionResponse
     */
    async upgradeDBProxyInstanceKernelVersionWithOptions(request, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.DBInstanceId)) {
            query["DBInstanceId"] = request.DBInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.DBProxyEngineType)) {
            query["DBProxyEngineType"] = request.DBProxyEngineType;
        }
        if (!tea_util_1.default.isUnset(request.ownerId)) {
            query["OwnerId"] = request.ownerId;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerAccount)) {
            query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
        }
        if (!tea_util_1.default.isUnset(request.resourceOwnerId)) {
            query["ResourceOwnerId"] = request.resourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.switchTime)) {
            query["SwitchTime"] = request.switchTime;
        }
        if (!tea_util_1.default.isUnset(request.upgradeTime)) {
            query["UpgradeTime"] = request.upgradeTime;
        }
        let req = new $OpenApi.OpenApiRequest({
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpgradeDBProxyInstanceKernelVersion",
            version: "2014-08-15",
            protocol: "HTTPS",
            pathname: "/",
            method: "POST",
            authType: "AK",
            style: "RPC",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpgradeDBProxyInstanceKernelVersionResponse({}));
    }
    /**
      * ### Supported database engines
      * *   MySQL
      * *   PostgreSQL
      * ### References
      * > Before you call this operation, read the following documentation and make sure that you fully understand the prerequisites and impacts of this operation.
      * *   [Upgrade the dedicated proxy version of an ApsaraDB RDS for MySQL instance](~~197465~~)
      * *   [Upgrade the dedicated proxy version of an ApsaraDB RDS for PostgreSQL instance](~~418469~~)
      *
      * @param request UpgradeDBProxyInstanceKernelVersionRequest
      * @return UpgradeDBProxyInstanceKernelVersionResponse
     */
    async upgradeDBProxyInstanceKernelVersion(request) {
        let runtime = new $Util.RuntimeOptions({});
        return await this.upgradeDBProxyInstanceKernelVersionWithOptions(request, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map